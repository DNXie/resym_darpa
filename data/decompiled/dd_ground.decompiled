[[4200016, ".init_proc", "void *init_proc()\n{\n  void *result; // rax\n\n  result = &_gmon_start__;\n  if ( &_gmon_start__ )\n    result = (void *)__gmon_start__();\n  return result;\n}\n"], [4200048, "sub_401670", "__int64 sub_401670()\n{\n  return qword_60E010();\n}\n"], [4200064, ".getenv", "// attributes: thunk\nchar *getenv(const char *name)\n{\n  return getenv(name);\n}\n"], [4200080, ".sigprocmask", "// attributes: thunk\nint sigprocmask(int how, const sigset_t *set, sigset_t *oset)\n{\n  return sigprocmask(how, set, oset);\n}\n"], [4200096, ".raise", "// attributes: thunk\nint raise(int sig)\n{\n  return raise(sig);\n}\n"], [4200112, ".free", "// attributes: thunk\nvoid free(void *ptr)\n{\n  free(ptr);\n}\n"], [4200128, ".abort", "// attributes: thunk\nvoid __noreturn abort(void)\n{\n  abort();\n}\n"], [4200144, ".__errno_location", "// attributes: thunk\nint *__errno_location(void)\n{\n  return _errno_location();\n}\n"], [4200160, ".fdatasync", "// attributes: thunk\nint fdatasync(int fildes)\n{\n  return fdatasync(fildes);\n}\n"], [4200176, ".strncmp", "// attributes: thunk\nint strncmp(const char *s1, const char *s2, size_t n)\n{\n  return strncmp(s1, s2, n);\n}\n"], [4200192, "._exit", "// attributes: thunk\nvoid __noreturn _exit(int status)\n{\n  exit(status);\n}\n"], [4200208, ".__fpending", "// attributes: thunk\nsize_t __fpending(FILE *fp)\n{\n  return _fpending(fp);\n}\n"], [4200224, ".toupper", "// attributes: thunk\nint toupper(int c)\n{\n  return toupper(c);\n}\n"], [4200240, ".sigaction", "// attributes: thunk\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oact)\n{\n  return sigaction(sig, act, oact);\n}\n"], [4200256, ".localeconv", "// attributes: thunk\nstruct lconv *localeconv(void)\n{\n  return localeconv();\n}\n"], [4200272, ".fcntl", "// attributes: thunk\nint fcntl(int fd, int cmd, ...)\n{\n  return fcntl(fd, cmd);\n}\n"], [4200288, ".clock_gettime", "// attributes: thunk\nint clock_gettime(clockid_t clock_id, struct timespec *tp)\n{\n  return clock_gettime(clock_id, tp);\n}\n"], [4200304, ".write", "// attributes: thunk\nssize_t write(int fd, const void *buf, size_t n)\n{\n  return write(fd, buf, n);\n}\n"], [4200320, ".textdomain", "// attributes: thunk\nchar *textdomain(const char *domainname)\n{\n  return textdomain(domainname);\n}\n"], [4200336, ".fclose", "// attributes: thunk\nint fclose(FILE *stream)\n{\n  return fclose(stream);\n}\n"], [4200352, ".bindtextdomain", "// attributes: thunk\nchar *bindtextdomain(const char *domainname, const char *dirname)\n{\n  return bindtextdomain(domainname, dirname);\n}\n"], [4200368, ".__ctype_get_mb_cur_max", "// attributes: thunk\nsize_t __ctype_get_mb_cur_max(void)\n{\n  return _ctype_get_mb_cur_max();\n}\n"], [4200384, ".strlen", "// attributes: thunk\nsize_t strlen(const char *s)\n{\n  return strlen(s);\n}\n"], [4200400, ".__stack_chk_fail", "// attributes: thunk\nvoid __noreturn __stack_chk_fail()\n{\n  _stack_chk_fail();\n}\n"], [4200416, ".getopt_long", "// attributes: thunk\nint getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind)\n{\n  return getopt_long(argc, argv, shortopts, longopts, longind);\n}\n"], [4200432, ".mbrtowc", "// attributes: thunk\nsize_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p)\n{\n  return mbrtowc(pwc, s, n, p);\n}\n"], [4200448, ".gettext", "// attributes: thunk\nchar *gettext(const char *msgid)\n{\n  return gettext(msgid);\n}\n"], [4200464, ".dup2", "// attributes: thunk\nint dup2(int fd, int fd2)\n{\n  return dup2(fd, fd2);\n}\n"], [4200480, ".strchr", "// attributes: thunk\nchar *strchr(const char *s, int c)\n{\n  return strchr(s, c);\n}\n"], [4200496, ".printf", "// attributes: thunk\nint printf(const char *format, ...)\n{\n  return printf(format);\n}\n"], [4200512, ".strrchr", "// attributes: thunk\nchar *strrchr(const char *s, int c)\n{\n  return strrchr(s, c);\n}\n"], [4200528, ".ftruncate", "// attributes: thunk\nint ftruncate(int fd, __off_t length)\n{\n  return ftruncate(fd, length);\n}\n"], [4200544, ".lseek", "// attributes: thunk\n__off_t lseek(int fd, __off_t offset, int whence)\n{\n  return lseek(fd, offset, whence);\n}\n"], [4200560, ".gettimeofday", "// attributes: thunk\nint gettimeofday(struct timeval *tv, __timezone_ptr_t tz)\n{\n  return gettimeofday(tv, tz);\n}\n"], [4200576, ".__assert_fail", "// attributes: thunk\nvoid __noreturn __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function)\n{\n  _assert_fail(assertion, file, line, function);\n}\n"], [4200592, ".memset", "// attributes: thunk\nvoid *memset(void *s, int c, size_t n)\n{\n  return memset(s, c, n);\n}\n"], [4200608, ".ioctl", "// attributes: thunk\nint ioctl(int fd, unsigned __int64 request, ...)\n{\n  return ioctl(fd, request);\n}\n"], [4200624, ".close", "// attributes: thunk\nint close(int fd)\n{\n  return close(fd);\n}\n"], [4200640, ".posix_fadvise", "// attributes: thunk\nint posix_fadvise(int fd, off_t offset, off_t len, int advise)\n{\n  return posix_fadvise(fd, offset, len, advise);\n}\n"], [4200656, ".read", "// attributes: thunk\nssize_t read(int fd, void *buf, size_t nbytes)\n{\n  return read(fd, buf, nbytes);\n}\n"], [4200672, ".__libc_start_main", "// attributes: thunk\nint __fastcall __libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end)\n{\n  return _libc_start_main(main, argc, ubp_av, init, fini, rtld_fini, stack_end);\n}\n"], [4200688, ".memcmp", "// attributes: thunk\nint memcmp(const void *s1, const void *s2, size_t n)\n{\n  return memcmp(s1, s2, n);\n}\n"], [4200704, ".fputs_unlocked", "// attributes: thunk\nint fputs_unlocked(const char *s, FILE *stream)\n{\n  return fputs_unlocked(s, stream);\n}\n"], [4200720, ".ferror_unlocked", "// attributes: thunk\nint ferror_unlocked(FILE *stream)\n{\n  return ferror_unlocked(stream);\n}\n"], [4200736, ".calloc", "// attributes: thunk\nvoid *calloc(size_t nmemb, size_t size)\n{\n  return calloc(nmemb, size);\n}\n"], [4200752, ".fprintf", "// attributes: thunk\nint fprintf(FILE *stream, const char *format, ...)\n{\n  return fprintf(stream, format);\n}\n"], [4200768, ".sigemptyset", "// attributes: thunk\nint sigemptyset(sigset_t *set)\n{\n  return sigemptyset(set);\n}\n"], [4200784, ".__gmon_start__", "// attributes: thunk\n__int64 __gmon_start__(void)\n{\n  return _gmon_start__();\n}\n"], [4200800, ".memcpy", "// attributes: thunk\nvoid *memcpy(void *dest, const void *src, size_t n)\n{\n  return memcpy(dest, src, n);\n}\n"], [4200816, ".fileno", "// attributes: thunk\nint fileno(FILE *stream)\n{\n  return fileno(stream);\n}\n"], [4200832, ".tolower", "// attributes: thunk\nint tolower(int c)\n{\n  return tolower(c);\n}\n"], [4200848, ".putc_unlocked", "// attributes: thunk\nint putc_unlocked(int c, FILE *stream)\n{\n  return putc_unlocked(c, stream);\n}\n"], [4200864, ".malloc", "// attributes: thunk\nvoid *malloc(size_t size)\n{\n  return malloc(size);\n}\n"], [4200880, ".fflush", "// attributes: thunk\nint fflush(FILE *stream)\n{\n  return fflush(stream);\n}\n"], [4200896, ".__fxstat", "// attributes: thunk\nint __fxstat(int ver, int fildes, struct stat *stat_buf)\n{\n  return _fxstat(ver, fildes, stat_buf);\n}\n"], [4200912, ".__freading", "// attributes: thunk\nint __freading(FILE *fp)\n{\n  return _freading(fp);\n}\n"], [4200928, ".realloc", "// attributes: thunk\nvoid *realloc(void *ptr, size_t size)\n{\n  return realloc(ptr, size);\n}\n"], [4200944, ".setlocale", "// attributes: thunk\nchar *setlocale(int category, const char *locale)\n{\n  return setlocale(category, locale);\n}\n"], [4200960, ".memmove", "// attributes: thunk\nvoid *memmove(void *dest, const void *src, size_t n)\n{\n  return memmove(dest, src, n);\n}\n"], [4200976, ".error", "// attributes: thunk\nvoid error(int status, int errnum, const char *format, ...)\n{\n  error(status, errnum, format);\n}\n"], [4200992, ".fsync", "// attributes: thunk\nint fsync(int fd)\n{\n  return fsync(fd);\n}\n"], [4201008, ".open", "// attributes: thunk\nint open(const char *file, int oflag, ...)\n{\n  return open(file, oflag);\n}\n"], [4201024, ".fseeko", "// attributes: thunk\nint fseeko(FILE *stream, __off_t off, int whence)\n{\n  return fseeko(stream, off, whence);\n}\n"], [4201040, ".strtoumax", "// attributes: thunk\nuintmax_t strtoumax(const char *nptr, char **endptr, int base)\n{\n  return strtoumax(nptr, endptr, base);\n}\n"], [4201056, ".__cxa_atexit", "// attributes: thunk\nint __fastcall __cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle)\n{\n  return _cxa_atexit(lpfunc, obj, lpdso_handle);\n}\n"], [4201072, ".getpagesize", "// attributes: thunk\nint getpagesize(void)\n{\n  return getpagesize();\n}\n"], [4201088, ".sprintf", "// attributes: thunk\nint sprintf(char *s, const char *format, ...)\n{\n  return sprintf(s, format);\n}\n"], [4201104, ".sigismember", "// attributes: thunk\nint sigismember(const sigset_t *set, int signo)\n{\n  return sigismember(set, signo);\n}\n"], [4201120, ".exit", "// attributes: thunk\nvoid __noreturn exit(int status)\n{\n  exit(status);\n}\n"], [4201136, ".fwrite", "// attributes: thunk\nsize_t fwrite(const void *ptr, size_t size, size_t n, FILE *s)\n{\n  return fwrite(ptr, size, n, s);\n}\n"], [4201152, ".ngettext", "// attributes: thunk\nchar *ngettext(const char *msgid1, const char *msgid2, unsigned __int64 n)\n{\n  return ngettext(msgid1, msgid2, n);\n}\n"], [4201168, ".mbsinit", "// attributes: thunk\nint mbsinit(const mbstate_t *ps)\n{\n  return mbsinit(ps);\n}\n"], [4201184, ".iswprint", "// attributes: thunk\nint iswprint(wint_t wc)\n{\n  return iswprint(wc);\n}\n"], [4201200, ".sigaddset", "// attributes: thunk\nint sigaddset(sigset_t *set, int signo)\n{\n  return sigaddset(set, signo);\n}\n"], [4201216, ".__ctype_b_loc", "// attributes: thunk\nconst unsigned __int16 **__ctype_b_loc(void)\n{\n  return _ctype_b_loc();\n}\n"], [4201232, "start", "// positive sp value has been detected, the output may be wrong!\nvoid __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))\n{\n  __int64 v3; // rax\n  int v4; // esi\n  __int64 v5; // [rsp-8h] [rbp-8h] BYREF\n  char *retaddr; // [rsp+0h] [rbp+0h] BYREF\n\n  v4 = v5;\n  v5 = v3;\n  __libc_start_main(main, v4, &retaddr, init, fini, a3, &v5);\n  __halt();\n}\n"], [4201280, "sub_401B40", "signed __int64 sub_401B40()\n{\n  signed __int64 result; // rax\n\n  result = &unk_60E2D7 - &unk_60E2D0;\n  if ( (unsigned __int64)(&unk_60E2D7 - &unk_60E2D0) > 0xE )\n    result = 0LL;\n  return result;\n}\n"], [4201328, "sub_401B70", "__int64 sub_401B70()\n{\n  return 0LL;\n}\n"], [4201392, "sub_401BB0", "signed __int64 sub_401BB0()\n{\n  signed __int64 result; // rax\n\n  if ( !byte_60E320 )\n  {\n    result = sub_401B40();\n    byte_60E320 = 1;\n  }\n  return result;\n}\n"], [4201424, "sub_401BD0", "__int64 sub_401BD0()\n{\n  return sub_401B70();\n}\n"], [4201469, "sub_401BFD", "__int64 __fastcall sub_401BFD(unsigned __int8 a1)\n{\n  return a1;\n}\n"], [4201484, "sub_401C0C", "__int64 __fastcall sub_401C0C(__int64 a1)\n{\n  return a1;\n}\n"], [4201498, "sub_401C1A", "unsigned __int64 __fastcall sub_401C1A(__int64 a1, unsigned __int64 a2)\n{\n  return a2 - 1 + a1 - (a2 - 1 + a1) % a2;\n}\n"], [4201568, "sub_401C60", "int sub_401C60()\n{\n  __int64 v0; // rbx\n  char *v1; // rax\n  char *v2; // rax\n  FILE *v3; // rbx\n  char *v4; // rax\n  __int64 v5; // rbx\n  char *v6; // rax\n  __int64 v7; // rbx\n  char *v8; // rax\n  const char *s1; // [rsp+8h] [rbp-18h]\n\n  v0 = sub_4056A1(qword_60E890);\n  v1 = gettext(\"\\nReport %s bugs to %s\\n\");\n  printf(v1, v0, \"bug-coreutils@gnu.org\");\n  v2 = gettext(\"%s home page: <%s>\\n\");\n  printf(v2, \"GNU coreutils\", \"http://www.gnu.org/software/coreutils/\");\n  v3 = stdout;\n  v4 = gettext(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\");\n  fputs_unlocked(v4, v3);\n  s1 = setlocale(5, 0LL);\n  if ( s1 && strncmp(s1, \"en_\", 3uLL) )\n  {\n    v5 = sub_4056A1(qword_60E890);\n    v6 = gettext(\"Report %s translation bugs to <http://translationproject.org/team/>\\n\");\n    printf(v6, v5);\n  }\n  v7 = sub_4056A1(qword_60E890);\n  v8 = gettext(\"For complete documentation, run: info coreutils '%s invocation'\\n\");\n  return printf(v8, v7);\n}\n"], [4201834, "sub_401D6A", "__int64 sub_401D6A()\n{\n  __int64 result; // rax\n\n  if ( byte_60E27A )\n    return sub_4055B6();\n  result = sub_405501(stderr);\n  if ( (_DWORD)result )\n    _exit(1);\n  return result;\n}\n"], [4201887, "sub_401D9F", "void __fastcall __noreturn sub_401D9F(int a1)\n{\n  __int64 v1; // rbx\n  char *v2; // rax\n  __int64 v3; // r12\n  __int64 v4; // rbx\n  char *v5; // rax\n  FILE *v6; // rbx\n  char *v7; // rax\n  FILE *v8; // rbx\n  char *v9; // rax\n  FILE *v10; // rbx\n  char *v11; // rax\n  FILE *v12; // rbx\n  char *v13; // rax\n  FILE *v14; // rbx\n  char *v15; // rax\n  FILE *v16; // rbx\n  char *v17; // rax\n  FILE *v18; // rbx\n  char *v19; // rax\n  FILE *v20; // rbx\n  char *v21; // rax\n  FILE *v22; // rbx\n  char *v23; // rax\n  FILE *v24; // rbx\n  char *v25; // rax\n  FILE *v26; // rbx\n  char *v27; // rax\n  FILE *v28; // rbx\n  char *v29; // rax\n  FILE *v30; // rbx\n  char *v31; // rax\n  FILE *v32; // rbx\n  char *v33; // rax\n  FILE *v34; // rbx\n  char *v35; // rax\n  FILE *v36; // rbx\n  char *v37; // rax\n  char *v38; // rax\n  FILE *v39; // rbx\n  char *v40; // rax\n  FILE *v41; // rbx\n  char *v42; // rax\n\n  if ( a1 )\n  {\n    v1 = qword_60E890;\n    v2 = gettext(\"Try `%s --help' for more information.\\n\");\n    fprintf(stderr, v2, v1);\n  }\n  else\n  {\n    v3 = qword_60E890;\n    v4 = qword_60E890;\n    v5 = gettext(\"Usage: %s [OPERAND]...\\n  or:  %s OPTION\\n\");\n    printf(v5, v4, v3);\n    v6 = stdout;\n    v7 = gettext(\n           \"Copy a file, converting and formatting according to the operands.\\n\"\n           \"\\n\"\n           \"  bs=BYTES        read and write up to BYTES bytes at a time\\n\"\n           \"  cbs=BYTES       convert BYTES bytes at a time\\n\"\n           \"  conv=CONVS      convert the file as per the comma separated symbol list\\n\"\n           \"  count=BLOCKS    copy only BLOCKS input blocks\\n\"\n           \"  ibs=BYTES       read up to BYTES bytes at a time (default: 512)\\n\");\n    fputs_unlocked(v7, v6);\n    v8 = stdout;\n    v9 = gettext(\n           \"  if=FILE         read from FILE instead of stdin\\n\"\n           \"  iflag=FLAGS     read as per the comma separated symbol list\\n\"\n           \"  obs=BYTES       write BYTES bytes at a time (default: 512)\\n\"\n           \"  of=FILE         write to FILE instead of stdout\\n\"\n           \"  oflag=FLAGS     write as per the comma separated symbol list\\n\"\n           \"  seek=BLOCKS     skip BLOCKS obs-sized blocks at start of output\\n\"\n           \"  skip=BLOCKS     skip BLOCKS ibs-sized blocks at start of input\\n\"\n           \"  status=noxfer   suppress transfer statistics\\n\");\n    fputs_unlocked(v9, v8);\n    v10 = stdout;\n    v11 = gettext(\n            \"\\n\"\n            \"BLOCKS and BYTES may be followed by the following multiplicative suffixes:\\n\"\n            \"c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, xM =M\\n\"\n            \"GB =1000*1000*1000, G =1024*1024*1024, and so on for T, P, E, Z, Y.\\n\"\n            \"\\n\"\n            \"Each CONV symbol may be:\\n\"\n            \"\\n\");\n    fputs_unlocked(v11, v10);\n    v12 = stdout;\n    v13 = gettext(\n            \"  ascii     from EBCDIC to ASCII\\n\"\n            \"  ebcdic    from ASCII to EBCDIC\\n\"\n            \"  ibm       from ASCII to alternate EBCDIC\\n\"\n            \"  block     pad newline-terminated records with spaces to cbs-size\\n\"\n            \"  unblock   replace trailing spaces in cbs-size records with newline\\n\"\n            \"  lcase     change upper case to lower case\\n\"\n            \"  ucase     change lower case to upper case\\n\"\n            \"  swab      swap every pair of input bytes\\n\"\n            \"  sync      pad every input block with NULs to ibs-size; when used\\n\"\n            \"            with block or unblock, pad with spaces rather than NULs\\n\");\n    fputs_unlocked(v13, v12);\n    v14 = stdout;\n    v15 = gettext(\n            \"  excl      fail if the output file already exists\\n\"\n            \"  nocreat   do not create the output file\\n\"\n            \"  notrunc   do not truncate the output file\\n\"\n            \"  noerror   continue after read errors\\n\"\n            \"  fdatasync  physically write output file data before finishing\\n\"\n            \"  fsync     likewise, but also write metadata\\n\");\n    fputs_unlocked(v15, v14);\n    v16 = stdout;\n    v17 = gettext(\n            \"\\n\"\n            \"Each FLAG symbol may be:\\n\"\n            \"\\n\"\n            \"  append    append mode (makes sense only for output; conv=notrunc suggested)\\n\");\n    fputs_unlocked(v17, v16);\n    v18 = stdout;\n    v19 = gettext(\"  direct    use direct I/O for data\\n\");\n    fputs_unlocked(v19, v18);\n    v20 = stdout;\n    v21 = gettext(\"  directory  fail unless a directory\\n\");\n    fputs_unlocked(v21, v20);\n    v22 = stdout;\n    v23 = gettext(\"  dsync     use synchronized I/O for data\\n\");\n    fputs_unlocked(v23, v22);\n    v24 = stdout;\n    v25 = gettext(\"  sync      likewise, but also for metadata\\n\");\n    fputs_unlocked(v25, v24);\n    v26 = stdout;\n    v27 = gettext(\"  fullblock  accumulate full blocks of input (iflag only)\\n\");\n    fputs_unlocked(v27, v26);\n    v28 = stdout;\n    v29 = gettext(\"  nonblock  use non-blocking I/O\\n\");\n    fputs_unlocked(v29, v28);\n    v30 = stdout;\n    v31 = gettext(\"  noatime   do not update access time\\n\");\n    fputs_unlocked(v31, v30);\n    v32 = stdout;\n    v33 = gettext(\"  nocache   discard cached data\\n\");\n    fputs_unlocked(v33, v32);\n    v34 = stdout;\n    v35 = gettext(\"  noctty    do not assign controlling terminal from file\\n\");\n    fputs_unlocked(v35, v34);\n    v36 = stdout;\n    v37 = gettext(\"  nofollow  do not follow symlinks\\n\");\n    fputs_unlocked(v37, v36);\n    v38 = gettext(\n            \"\\n\"\n            \"Sending a %s signal to a running `dd' process makes it\\n\"\n            \"print I/O statistics to standard error and then resume copying.\\n\"\n            \"\\n\"\n            \"  $ dd if=/dev/zero of=/dev/null& pid=$!\\n\"\n            \"  $ kill -%s $pid; sleep 1; kill $pid\\n\"\n            \"  18335302+0 records in\\n\"\n            \"  18335302+0 records out\\n\"\n            \"  9387674624 bytes (9.4 GB) copied, 34.6279 seconds, 271 MB/s\\n\"\n            \"\\n\"\n            \"Options are:\\n\"\n            \"\\n\");\n    printf(v38, \"USR1\", \"USR1\");\n    v39 = stdout;\n    v40 = gettext(\"      --help     display this help and exit\\n\");\n    fputs_unlocked(v40, v39);\n    v41 = stdout;\n    v42 = gettext(\"      --version  output version information and exit\\n\");\n    fputs_unlocked(v42, v41);\n    sub_401C60();\n  }\n  exit(a1);\n}\n"], [4202562, "sub_402042", "__int64 __fastcall sub_402042(__int64 a1)\n{\n  __int64 result; // rax\n  int i; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; i <= 255; ++i )\n  {\n    result = i;\n    byte_60E4A0[i] = *(_BYTE *)((unsigned __int8)byte_60E4A0[i] + a1);\n  }\n  byte_60E390 = 1;\n  return result;\n}\n"], [4202639, "sub_40208F", "bool __fastcall sub_40208F(int a1)\n{\n  return (a1 & (a1 - 1)) != 0;\n}\n"], [4202662, "sub_4020A6", "unsigned __int64 sub_4020A6()\n{\n  __int64 v0; // r14\n  __int64 v1; // r13\n  __int64 v2; // r12\n  __int64 v3; // rbx\n  char *v4; // rax\n  __int64 v5; // rbx\n  __int64 v6; // rax\n  char *v7; // rax\n  __int64 v8; // r12\n  __int64 v9; // rbx\n  __int64 v10; // rax\n  char *v11; // rax\n  unsigned __int64 v12; // rax\n  double v13; // xmm0_8\n  char *v14; // rax\n  double v16; // [rsp+18h] [rbp-2E8h]\n  char *v17; // [rsp+20h] [rbp-2E0h]\n  __int64 v18; // [rsp+28h] [rbp-2D8h]\n  char v19[664]; // [rsp+40h] [rbp-2C0h] BYREF\n  unsigned __int64 v20; // [rsp+2D8h] [rbp-28h]\n\n  v20 = __readfsqword(0x28u);\n  v18 = sub_409515();\n  v0 = qword_60E398;\n  v1 = qword_60E3A0;\n  v2 = qword_60E3A8;\n  v3 = qword_60E3B0;\n  v4 = gettext(\"%lu+%lu records in\\n%lu+%lu records out\\n\");\n  fprintf(stderr, v4, v3, v2, v1, v0);\n  if ( qword_60E3E0 )\n  {\n    v5 = qword_60E3E0;\n    v6 = sub_401C0C(qword_60E3E0);\n    v7 = ngettext(\"%lu truncated record\\n\", \"%lu truncated records\\n\", v6);\n    fprintf(stderr, v7, v5);\n  }\n  if ( (dword_60E38C & 1) == 0 )\n  {\n    v8 = sub_405986(qword_60E3B8, v19, 465LL, 1LL, 1LL);\n    v9 = qword_60E3B8;\n    v10 = sub_401C0C(qword_60E3B8);\n    v11 = ngettext(\"%lu byte (%s) copied\", \"%lu bytes (%s) copied\", v10);\n    fprintf(stderr, v11, v9, v8);\n    if ( qword_60E3C0 >= v18 )\n    {\n      v16 = 0.0;\n      v17 = gettext(\"Infinity B\");\n    }\n    else\n    {\n      v12 = v18 - qword_60E3C0;\n      if ( v18 - qword_60E3C0 < 0 )\n        v13 = (double)(int)(v12 & 1 | (v12 >> 1)) + (double)(int)(v12 & 1 | (v12 >> 1));\n      else\n        v13 = (double)(int)v12;\n      v16 = v13 / 1000000000.0;\n      v17 = (char *)sub_405986(qword_60E3B8, v19, 465LL, 1000000000LL, v18 - qword_60E3C0);\n    }\n    v14 = gettext(\", %g s, %s/s\\n\");\n    fprintf(stderr, v14, v17, v16);\n  }\n  return __readfsqword(0x28u) ^ v20;\n}\n"], [4203299, "sub_402323", "__int64 __fastcall sub_402323(unsigned int a1)\n{\n  __int64 result; // rax\n\n  result = a1;\n  dword_60E480 = a1;\n  return result;\n}\n"], [4203317, "sub_402335", "__int64 sub_402335()\n{\n  return (unsigned int)++dword_60E484;\n}\n"], [4203341, "sub_40234D", "int sub_40234D()\n{\n  int result; // eax\n  bool v1; // [rsp+Fh] [rbp-A1h]\n  struct sigaction v2; // [rsp+10h] [rbp-A0h] BYREF\n\n  v1 = getenv(\"POSIXLY_CORRECT\") == 0LL;\n  sigemptyset(&set);\n  if ( v1 )\n  {\n    sigaction(10, 0LL, &v2);\n    if ( v2.sa_handler != (__sighandler_t)1 )\n      sigaddset(&set, 10);\n  }\n  sigaction(2, 0LL, &v2);\n  if ( v2.sa_handler != (__sighandler_t)1 )\n    sigaddset(&set, 2);\n  v2.sa_mask = set;\n  if ( sigismember(&set, 10) )\n  {\n    v2.sa_handler = (__sighandler_t)sub_402335;\n    v2.sa_flags = 0;\n    sigaction(10, &v2, 0LL);\n  }\n  result = sigismember(&set, 2);\n  if ( result )\n  {\n    v2.sa_handler = (__sighandler_t)sub_402323;\n    v2.sa_flags = -1073741824;\n    result = sigaction(2, &v2, 0LL);\n  }\n  return result;\n}\n"], [4203810, "sub_402522", "void sub_402522()\n{\n  __int64 v0; // r12\n  char *v1; // rbx\n  int *v2; // rax\n  __int64 v3; // r12\n  char *v4; // rbx\n  int *v5; // rax\n\n  if ( close(0) < 0 )\n  {\n    v0 = sub_40685B(qword_60E340);\n    v1 = gettext(\"closing input file %s\");\n    v2 = __errno_location();\n    error(1, *v2, v1, v0);\n  }\n  if ( close(1) < 0 )\n  {\n    v3 = sub_40685B(qword_60E348);\n    v4 = gettext(\"closing output file %s\");\n    v5 = __errno_location();\n    error(1, *v5, v4, v3);\n  }\n}\n"], [4203972, "sub_4025C4", "__int64 sub_4025C4()\n{\n  __int64 result; // rax\n  int sig; // [rsp+8h] [rbp-88h]\n  sigset_t oset; // [rsp+10h] [rbp-80h] BYREF\n\n  while ( 1 )\n  {\n    if ( !dword_60E480 )\n    {\n      result = (unsigned int)dword_60E484;\n      if ( !dword_60E484 )\n        break;\n    }\n    sigprocmask(0, &set, &oset);\n    sig = dword_60E480;\n    if ( dword_60E484 )\n      --dword_60E484;\n    sigprocmask(2, &oset, 0LL);\n    if ( sig )\n      sub_402522();\n    sub_4020A6();\n    if ( sig )\n      raise(sig);\n  }\n  return result;\n}\n"], [4204151, "sub_402677", "void __fastcall __noreturn sub_402677(int a1)\n{\n  sub_402522();\n  sub_4020A6();\n  sub_4025C4();\n  exit(a1);\n}\n"], [4204187, "sub_40269B", "__int64 __fastcall sub_40269B(int a1, __int64 a2)\n{\n  void *v2; // rax\n  __int64 v4; // [rsp+0h] [rbp-20h]\n  __int64 v5; // [rsp+18h] [rbp-8h]\n\n  if ( a1 )\n    v2 = &unk_60E5B0;\n  else\n    v2 = &unk_60E5A8;\n  if ( !a2 )\n    return *(_QWORD *)v2;\n  v5 = *(_QWORD *)v2 + a2;\n  *(_QWORD *)v2 = v5 % (unsigned __int64)qword_60E350;\n  if ( *(_QWORD *)v2 >= v5 )\n    v4 = 0LL;\n  else\n    v4 = v5 - *(_QWORD *)v2;\n  return v4;\n}\n"], [4204340, "sub_402734", "bool __fastcall sub_402734(int a1, __int64 a2)\n{\n  __int64 v3; // rax\n  int v4; // [rsp+1Ch] [rbp-14h]\n  __int64 len; // [rsp+20h] [rbp-10h]\n  __int64 v6; // [rsp+28h] [rbp-8h]\n\n  v4 = -1;\n  len = sub_40269B(a1, a2);\n  if ( a2 && !len )\n    return 1;\n  if ( !a2 && !len && qword_60E270 )\n    return 1;\n  if ( a2 )\n    v3 = sub_40269B(a1, 0LL);\n  else\n    v3 = 0LL;\n  v6 = v3;\n  if ( a1 )\n  {\n    if ( a1 == 1 && offset != -1 )\n    {\n      if ( offset < 0 )\n        offset = lseek(1, 0LL, 1) - (len + v3);\n      if ( offset >= 0 )\n      {\n        v4 = posix_fadvise(1, offset, len, 4);\n        offset += v6 + len;\n      }\n    }\n  }\n  else if ( byte_60E3C8 )\n  {\n    v4 = posix_fadvise(0, qword_60E3D0 - len - v3, len, 4);\n  }\n  else\n  {\n    *__errno_location() = 29;\n  }\n  return v4 != -1;\n}\n"], [4204735, "sub_4028BF", "ssize_t __fastcall sub_4028BF(int a1, void *a2, size_t a3)\n{\n  __int64 v3; // rax\n  char *v4; // rax\n  ssize_t v7; // [rsp+20h] [rbp-10h]\n  __int64 v8; // [rsp+28h] [rbp-8h]\n\n  do\n  {\n    sub_4025C4();\n    v7 = read(a1, a2, a3);\n  }\n  while ( v7 < 0 && *__errno_location() == 4 );\n  if ( v7 > 0 && byte_60E3D9 )\n  {\n    if ( qword_60E5B8 > 0 && qword_60E5B8 < a3 )\n    {\n      v8 = qword_60E5B8;\n      v3 = sub_401C0C(qword_60E5B8);\n      v4 = ngettext(\n             \"warning: partial read (%lu byte); suggest iflag=fullblock\",\n             \"warning: partial read (%lu bytes); suggest iflag=fullblock\",\n             v3);\n      error(0, 0, v4, v8);\n      byte_60E3D9 = 0;\n    }\n    qword_60E5B8 = v7;\n  }\n  return v7;\n}\n"], [4204941, "sub_40298D", "ssize_t __fastcall sub_40298D(int a1, char *a2, size_t a3)\n{\n  __int64 v6; // [rsp+20h] [rbp-10h]\n  ssize_t v7; // [rsp+28h] [rbp-8h]\n\n  v6 = 0LL;\n  while ( a3 )\n  {\n    v7 = sub_4028BF(a1, a2, a3);\n    if ( v7 < 0 )\n      return v7;\n    if ( !v7 )\n      break;\n    v6 += v7;\n    a2 += v7;\n    a3 -= v7;\n  }\n  return v6;\n}\n"], [4205054, "sub_4029FE", "unsigned __int64 __fastcall sub_4029FE(int a1, __int64 a2, size_t a3, int a4, int a5, int a6)\n{\n  int v6; // eax\n  int v7; // ecx\n  int v8; // er8\n  int v9; // er9\n  __int64 v10; // r12\n  char *v11; // rbx\n  int *v12; // rax\n  int v13; // eax\n  unsigned __int64 v16; // [rsp+30h] [rbp-20h]\n  ssize_t v17; // [rsp+38h] [rbp-18h]\n\n  v16 = 0LL;\n  if ( (dword_60E388 & 0x4000) != 0 && a3 < n )\n  {\n    v6 = sub_409105(1, 3, a3, a4, a5, a6);\n    BYTE1(v6) &= 0xBFu;\n    if ( (unsigned int)sub_409105(1, 4, v6, v7, v8, v9) )\n    {\n      v10 = sub_40685B(qword_60E348);\n      v11 = gettext(\"failed to turn off O_DIRECT: %s\");\n      v12 = __errno_location();\n      error(0, *v12, v11, v10);\n    }\n    sub_402734(1, 0LL);\n    v13 = dword_60E380;\n    BYTE1(v13) = BYTE1(dword_60E380) | 0x80;\n    dword_60E380 = v13;\n  }\n  while ( v16 < a3 )\n  {\n    sub_4025C4();\n    v17 = write(a1, (const void *)(v16 + a2), a3 - v16);\n    if ( v17 >= 0 )\n    {\n      if ( !v17 )\n      {\n        *__errno_location() = 28;\n        break;\n      }\n      v16 += v17;\n    }\n    else if ( *__errno_location() != 4 )\n    {\n      break;\n    }\n  }\n  if ( byte_60E489 && v16 )\n    sub_402734(a1, v16);\n  return v16;\n}\n"], [4205421, "sub_402B6D", "__int64 __fastcall sub_402B6D(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  __int64 v6; // r12\n  char *v7; // rbx\n  int *v8; // rax\n  __int64 result; // rax\n  unsigned __int64 v10; // [rsp+8h] [rbp-18h]\n\n  v10 = sub_4029FE(1, (__int64)s, n, a4, a5, a6);\n  qword_60E3B8 += v10;\n  if ( v10 != n )\n  {\n    v6 = sub_40685B(qword_60E348);\n    v7 = gettext(\"writing to %s\");\n    v8 = __errno_location();\n    error(0, *v8, v7, v6);\n    if ( v10 )\n      ++qword_60E398;\n    sub_402677(1);\n  }\n  result = ++qword_60E3A0;\n  qword_60E3F0 = 0LL;\n  return result;\n}\n"], [4205631, "sub_402C3F", "_BOOL8 __fastcall sub_402C3F(char *a1, _BYTE *a2, char a3)\n{\n  char *v3; // rax\n  char v4; // cl\n  _BYTE *v5; // rax\n\n  while ( *a2 )\n  {\n    v3 = a1++;\n    v4 = *v3;\n    v5 = a2++;\n    if ( v4 != *v5 )\n      return 0LL;\n  }\n  return !*a1 || *a1 == a3;\n}\n"], [4205742, "sub_402CAE", "__int64 __fastcall sub_402CAE(const char *a1, _BYTE *a2, const char *a3)\n{\n  char *i; // rax\n  bool j; // al\n  size_t v5; // rax\n  const char *v6; // rbx\n  char *v7; // rax\n  char *s; // [rsp+18h] [rbp-38h]\n  unsigned int v11; // [rsp+24h] [rbp-2Ch]\n  _BYTE *v12; // [rsp+28h] [rbp-28h]\n  char *v13; // [rsp+30h] [rbp-20h]\n\n  s = (char *)a1;\n  v11 = 0;\n  for ( i = strchr(a1, 44); ; i = strchr(v13 + 1, 44) )\n  {\n    v13 = i;\n    v12 = a2;\n    for ( j = sub_402C3F(s, a2, 44); !j || !*((_DWORD *)v12 + 3); j = sub_402C3F(s, v12, 44) )\n    {\n      if ( !*v12 )\n      {\n        if ( v13 )\n          v5 = v13 - s;\n        else\n          v5 = strlen(s);\n        v6 = (const char *)sub_407D27(0LL, 6LL, s, v5);\n        v7 = gettext(a3);\n        error(0, 0, \"%s: %s\", v7, v6);\n        sub_401D9F(1);\n      }\n      v12 += 16;\n    }\n    v11 |= *((_DWORD *)v12 + 3);\n    if ( !v13 )\n      break;\n    s = v13 + 1;\n  }\n  return v11;\n}\n"], [4206040, "sub_402DD8", "__int64 __fastcall sub_402DD8(__int64 a1, _BYTE *a2)\n{\n  int v3; // [rsp+14h] [rbp-1Ch]\n  __int64 v4; // [rsp+18h] [rbp-18h] BYREF\n  _BYTE *v5; // [rsp+20h] [rbp-10h] BYREF\n  unsigned __int64 v6; // [rsp+28h] [rbp-8h]\n\n  v3 = sub_408BE4(a1, &v5, 10LL, &v4, \"bcEGkKMPTwYZ0\");\n  if ( v3 == 2 && *v5 == 120 )\n  {\n    v6 = sub_402DD8(v5 + 1, a2);\n    if ( v6 && v6 * v4 / v6 != v4 )\n    {\n      *a2 = 1;\n      return 0LL;\n    }\n    v4 *= v6;\n  }\n  else if ( v3 )\n  {\n    *a2 = 1;\n    return 0LL;\n  }\n  return v4;\n}\n"], [4206229, "sub_402E95", "_BOOL8 __fastcall sub_402E95(char *a1, _BYTE *a2)\n{\n  return sub_402C3F(a1, a2, 61);\n}\n"], [4206271, "sub_402EBF", "__int64 __fastcall sub_402EBF(int a1, __int64 a2)\n{\n  __int64 v2; // rbx\n  char *v3; // rax\n  unsigned __int64 v4; // rax\n  int v5; // eax\n  unsigned __int64 v6; // rax\n  int v7; // eax\n  unsigned __int64 v8; // rax\n  int v9; // eax\n  __int64 v10; // rbx\n  char *v11; // rax\n  __int64 v12; // rbx\n  char *v13; // rax\n  int v14; // eax\n  char *v15; // rax\n  bool v16; // al\n  void *v17; // rax\n  char *v18; // rax\n  char *v19; // rax\n  char *v20; // rax\n  char *v21; // rax\n  char *v22; // rax\n  __int64 result; // rax\n  bool v24; // [rsp+1Bh] [rbp-35h] BYREF\n  int i; // [rsp+1Ch] [rbp-34h]\n  size_t v26; // [rsp+20h] [rbp-30h]\n  char *s; // [rsp+28h] [rbp-28h]\n  char *v28; // [rsp+30h] [rbp-20h]\n  unsigned __int64 v29; // [rsp+38h] [rbp-18h]\n\n  v26 = 0LL;\n  for ( i = optind; i < a1; ++i )\n  {\n    s = *(char **)(8LL * i + a2);\n    v28 = strchr(s, 61);\n    if ( !v28 )\n    {\n      v2 = sub_40685B(s);\n      v3 = gettext(\"unrecognized operand %s\");\n      error(0, 0, v3, v2);\n      sub_401D9F(1);\n    }\n    ++v28;\n    if ( sub_402E95(s, \"if\") )\n    {\n      qword_60E340 = (__int64)v28;\n    }\n    else if ( sub_402E95(s, \"of\") )\n    {\n      qword_60E348 = (__int64)v28;\n    }\n    else if ( sub_402E95(s, \"conv\") )\n    {\n      dword_60E380 |= sub_402CAE(v28, \"ascii\", \"invalid conversion\");\n    }\n    else if ( sub_402E95(s, \"iflag\") )\n    {\n      dword_60E384 |= sub_402CAE(v28, \"append\", \"invalid input flag\");\n    }\n    else if ( sub_402E95(s, \"oflag\") )\n    {\n      dword_60E388 |= sub_402CAE(v28, \"append\", \"invalid output flag\");\n    }\n    else if ( sub_402E95(s, \"status\") )\n    {\n      dword_60E38C |= sub_402CAE(v28, \"noxfer\", \"invalid status flag\");\n    }\n    else\n    {\n      v24 = 0;\n      v29 = sub_402DD8((__int64)v28, &v24);\n      if ( sub_402E95(s, \"ibs\") )\n      {\n        if ( !v29 )\n          goto LABEL_21;\n        v4 = -2 * (qword_60E350 + 2);\n        if ( v4 > 0x7FFFFFFFFFFFFFFFLL )\n          v4 = 0x7FFFFFFFFFFFFFFFLL;\n        if ( v4 >= v29 )\n          v5 = 0;\n        else\nLABEL_21:\n          v5 = 1;\n        v24 = (v24 | v5) != 0;\n        qword_60E358 = v29;\n      }\n      else if ( sub_402E95(s, \"obs\") )\n      {\n        if ( !v29 )\n          goto LABEL_29;\n        v6 = -qword_60E350;\n        if ( (unsigned __int64)-qword_60E350 > 0x7FFFFFFFFFFFFFFFLL )\n          v6 = 0x7FFFFFFFFFFFFFFFLL;\n        if ( v6 >= v29 )\n          v7 = 0;\n        else\nLABEL_29:\n          v7 = 1;\n        v24 = (v24 | v7) != 0;\n        n = v29;\n      }\n      else if ( sub_402E95(s, \"bs\") )\n      {\n        if ( !v29 )\n          goto LABEL_37;\n        v8 = -2 * (qword_60E350 + 2);\n        if ( v8 > 0x7FFFFFFFFFFFFFFFLL )\n          v8 = 0x7FFFFFFFFFFFFFFFLL;\n        if ( v8 >= v29 )\n          v9 = 0;\n        else\nLABEL_37:\n          v9 = 1;\n        v24 = (v24 | v9) != 0;\n        v26 = v29;\n      }\n      else if ( sub_402E95(s, \"cbs\") )\n      {\n        v24 = v24 || v29 == 0;\n        qword_60E368 = v29;\n      }\n      else if ( sub_402E95(s, \"skip\") )\n      {\n        qword_60E370 = v29;\n      }\n      else if ( sub_402E95(s, \"seek\") )\n      {\n        qword_60E378 = v29;\n      }\n      else\n      {\n        if ( !sub_402E95(s, \"count\") )\n        {\n          v10 = sub_40685B(s);\n          v11 = gettext(\"unrecognized operand %s\");\n          error(0, 0, v11, v10);\n          sub_401D9F(1);\n        }\n        qword_60E270 = v29;\n      }\n      if ( v24 )\n      {\n        v12 = sub_40685B(v28);\n        v13 = gettext(\"invalid number %s\");\n        error(1, 0, v13, v12);\n      }\n    }\n  }\n  if ( v26 )\n  {\n    n = v26;\n    qword_60E358 = v26;\n  }\n  else\n  {\n    v14 = dword_60E380;\n    BYTE1(v14) = BYTE1(dword_60E380) | 8;\n    dword_60E380 = v14;\n  }\n  if ( !qword_60E358 )\n    qword_60E358 = 512LL;\n  if ( !n )\n    n = 512LL;\n  if ( !qword_60E368 )\n    dword_60E380 &= 0xFFFFFFE7;\n  if ( (dword_60E384 & 0x101000) != 0 )\n    dword_60E384 |= 0x101000u;\n  if ( (dword_60E388 & 1) != 0 )\n  {\n    v15 = gettext(\"invalid output flag\");\n    error(0, 0, \"%s: %s\", v15, \"'fullblock'\");\n    sub_401D9F(1);\n  }\n  v16 = (dword_60E380 & 0x800) == 0\n     && (dword_60E384 & 1) == 0\n     && (qword_60E370\n      || qword_60E270 && qword_60E270 != -1\n      || (((unsigned __int16)dword_60E384 | (unsigned __int16)dword_60E388) & 0x4000) != 0);\n  byte_60E3D9 = v16;\n  if ( (dword_60E384 & 1) != 0 )\n    v17 = sub_40298D;\n  else\n    v17 = sub_4028BF;\n  qword_60E490 = (__int64)v17;\n  dword_60E384 &= 0xFFFFFFFE;\n  if ( sub_40208F(dword_60E380 & 7) )\n  {\n    v18 = gettext(\"cannot combine any two of {ascii,ebcdic,ibm}\");\n    error(1, 0, v18);\n  }\n  if ( sub_40208F(dword_60E380 & 0x18) )\n  {\n    v19 = gettext(\"cannot combine block and unblock\");\n    error(1, 0, v19);\n  }\n  if ( sub_40208F(dword_60E380 & 0x60) )\n  {\n    v20 = gettext(\"cannot combine lcase and ucase\");\n    error(1, 0, v20);\n  }\n  if ( sub_40208F(dword_60E380 & 0x3000) )\n  {\n    v21 = gettext(\"cannot combine excl and nocreat\");\n    error(1, 0, v21);\n  }\n  if ( sub_40208F(dword_60E384 & 0x4002) || sub_40208F(dword_60E388 & 0x4002) )\n  {\n    v22 = gettext(\"cannot combine direct and nocache\");\n    error(1, 0, v22);\n  }\n  if ( (dword_60E384 & 2) != 0 )\n  {\n    byte_60E488 = 1;\n    dword_60E384 &= 0xFFFFFFFD;\n  }\n  result = dword_60E388 & 2;\n  if ( (dword_60E388 & 2) != 0 )\n  {\n    byte_60E489 = 1;\n    result = dword_60E388 & 0xFFFFFFFD;\n    dword_60E388 &= 0xFFFFFFFD;\n  }\n  return result;\n}\n"], [4208189, "sub_40363D", "__int64 sub_40363D()\n{\n  __int64 result; // rax\n  int i; // [rsp+Ch] [rbp-4h]\n  int j; // [rsp+Ch] [rbp-4h]\n\n  if ( (dword_60E380 & 1) != 0 )\n    sub_402042((__int64)&unk_40A0C0);\n  if ( (dword_60E380 & 0x40) != 0 )\n  {\n    for ( i = 0; i <= 255; ++i )\n      byte_60E4A0[i] = toupper((unsigned __int8)byte_60E4A0[i]);\n    byte_60E390 = 1;\n  }\n  else if ( (dword_60E380 & 0x20) != 0 )\n  {\n    for ( j = 0; j <= 255; ++j )\n      byte_60E4A0[j] = tolower((unsigned __int8)byte_60E4A0[j]);\n    byte_60E390 = 1;\n  }\n  if ( (dword_60E380 & 2) != 0 )\n  {\n    sub_402042((__int64)&unk_409EC0);\n    byte_60E278 = 37;\n    result = 64LL;\n    byte_60E279 = 64;\n  }\n  else\n  {\n    result = dword_60E380 & 4;\n    if ( (dword_60E380 & 4) != 0 )\n    {\n      sub_402042((__int64)&unk_409FC0);\n      byte_60E278 = 37;\n      result = 64LL;\n      byte_60E279 = 64;\n    }\n  }\n  return result;\n}\n"], [4208470, "sub_403756", "unsigned __int8 *__fastcall sub_403756(unsigned __int8 *a1, __int64 a2)\n{\n  unsigned __int8 *result; // rax\n  char v3; // dl\n  unsigned __int8 *v4; // [rsp+10h] [rbp-10h]\n\n  result = a1;\n  v4 = a1;\n  while ( a2 )\n  {\n    v3 = byte_60E4A0[(unsigned __int8)sub_401BFD(*v4)];\n    result = v4;\n    *v4 = v3;\n    --a2;\n    ++v4;\n  }\n  return result;\n}\n"], [4208560, "sub_4037B0", "__int64 __fastcall sub_4037B0(__int64 a1, _QWORD *a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-18h]\n  _BYTE *v4; // [rsp+20h] [rbp-10h]\n  __int64 i; // [rsp+28h] [rbp-8h]\n\n  v3 = a1;\n  if ( byte_60E5A0 )\n  {\n    v3 = a1 - 1;\n    *(_BYTE *)(a1 - 1) = byte_60E5A1;\n    ++*a2;\n    byte_60E5A0 = 0;\n  }\n  if ( (*a2 & 1LL) != 0 )\n  {\n    byte_60E5A1 = *(_BYTE *)(--*a2 + v3);\n    byte_60E5A0 = 1;\n  }\n  v4 = (_BYTE *)(*a2 + v3);\n  for ( i = *a2 >> 1; i; --i )\n  {\n    *v4 = *(v4 - 2);\n    v4 -= 2;\n  }\n  return v3 + 1;\n}\n"], [4208773, "sub_403885", "__int64 __fastcall sub_403885(unsigned __int64 a1)\n{\n  __int64 result; // rax\n\n  qword_60E3D0 += a1;\n  result = qword_60E3D0;\n  if ( qword_60E3D0 < a1 )\n    byte_60E3D8 = 1;\n  return result;\n}\n"], [4208824, "sub_4038B8", "__off_t __fastcall sub_4038B8(__int64 a1, int a2, __off_t a3, int a4)\n{\n  __int64 v4; // rbx\n  char *v5; // rax\n  bool v9; // [rsp+27h] [rbp-79h]\n  __off_t v10; // [rsp+28h] [rbp-78h]\n  char v11[8]; // [rsp+30h] [rbp-70h] BYREF\n  __int64 v12; // [rsp+38h] [rbp-68h]\n  int v13; // [rsp+58h] [rbp-48h]\n  int v14; // [rsp+5Ch] [rbp-44h]\n  __int64 v15[5]; // [rsp+60h] [rbp-40h] BYREF\n  int v16; // [rsp+88h] [rbp-18h]\n  int v17; // [rsp+8Ch] [rbp-14h]\n\n  v9 = ioctl(a2, 0x80306D02uLL, v11) == 0;\n  v10 = lseek(a2, a3, a4);\n  if ( v10 >= 0 && v9 && !ioctl(a2, 0x80306D02uLL, v15) && v12 == v15[1] && v13 == v16 && v14 == v17 )\n  {\n    v4 = v15[0];\n    v5 = gettext(\n           \"warning: working around lseek kernel bug for file (%s)\\n\"\n           \"  of mt_type=0x%0lx -- see <sys/mtio.h> for the list of types\");\n    error(0, 0, v5, a1, v4);\n    *__errno_location() = 0;\n    v10 = -1LL;\n  }\n  return v10;\n}\n"], [4209098, "sub_4039CA", "unsigned __int64 __fastcall sub_4039CA(unsigned int a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4, __int64 a5)\n{\n  __int64 v5; // r12\n  char *v6; // rbx\n  int *v7; // rax\n  unsigned __int64 result; // rax\n  __int64 v9; // rbx\n  char *v10; // rax\n  __int64 v11; // r12\n  char *v12; // rbx\n  int *v13; // rax\n  __int64 v14; // rbx\n  char *v15; // rax\n  unsigned __int64 v18; // [rsp+18h] [rbp-D8h]\n  __off_t v19; // [rsp+18h] [rbp-D8h]\n  int errnum; // [rsp+3Ch] [rbp-B4h]\n  unsigned __int64 v21; // [rsp+40h] [rbp-B0h]\n  signed __int64 v22; // [rsp+48h] [rbp-A8h]\n  struct stat stat_buf; // [rsp+50h] [rbp-A0h] BYREF\n\n  v18 = a3;\n  v21 = a4 * a3;\n  *__errno_location() = 0;\n  if ( 0x7FFFFFFFFFFFFFFFLL / a4 < v18 || sub_4038B8(a2, a1, v21, 1) < 0 )\n  {\n    errnum = *__errno_location();\n    if ( sub_4038B8(a2, a1, 0LL, 2) >= 0 )\n    {\n      if ( !errnum )\n        errnum = 75;\n      v9 = sub_40685B(a2);\n      if ( a1 )\n        v10 = gettext(\"%s: cannot seek\");\n      else\n        v10 = gettext(\"%s: cannot skip\");\n      error(0, errnum, v10, v9);\n      sub_402677(1);\n    }\n    do\n    {\n      v22 = qword_60E490(a1, a5, a4);\n      if ( v22 >= 0 )\n      {\n        if ( !v22 )\n          break;\n        if ( !a1 )\n          sub_403885(v22);\n      }\n      else\n      {\n        if ( a1 )\n        {\n          v14 = sub_40685B(a2);\n          v15 = gettext(\"%s: cannot seek\");\n          error(0, errnum, v15, v14);\nLABEL_24:\n          sub_402677(1);\n        }\n        v11 = sub_40685B(a2);\n        v12 = gettext(\"reading %s\");\n        v13 = __errno_location();\n        error(0, *v13, v12, v11);\n        if ( (dword_60E380 & 0x100) == 0 )\n          goto LABEL_24;\n        sub_4020A6();\n      }\n      --v18;\n    }\n    while ( v18 );\n    result = v18;\n  }\n  else\n  {\n    if ( a1 )\n    {\n      v19 = 0LL;\n    }\n    else\n    {\n      if ( (unsigned int)sub_409AF0(0, &stat_buf) )\n      {\n        v5 = sub_40685B(a2);\n        v6 = gettext(\"cannot fstat %s\");\n        v7 = __errno_location();\n        error(1, *v7, v6, v5);\n      }\n      if ( (stat_buf.st_mode & 0xF000) == 0x8000 && stat_buf.st_size < qword_60E3D0 + v21 )\n      {\n        v19 = (v21 - stat_buf.st_size) / a4;\n        sub_403885(stat_buf.st_size - qword_60E3D0);\n      }\n      else\n      {\n        v19 = 0LL;\n        sub_403885(v21);\n      }\n    }\n    result = v19;\n  }\n  return result;\n}\n"], [4210009, "sub_403D59", "__int64 __fastcall sub_403D59(unsigned __int64 a1)\n{\n  __int64 v2; // rbx\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  __int64 v6; // r12\n  char *v7; // rbx\n  int *v8; // rax\n  __off_t v9; // [rsp+10h] [rbp-20h]\n  unsigned __int64 v10; // [rsp+18h] [rbp-18h]\n\n  if ( byte_60E3C8 != 1 )\n  {\n    if ( dword_60E3CC == 29 )\n      return 1LL;\n    *__errno_location() = dword_60E3CC;\n  }\n  else\n  {\n    sub_403885(a1);\n    byte_60E3D8 = ((unsigned __int8)byte_60E3D8 | (qword_60E3D0 < 0)) != 0;\n    if ( byte_60E3D8 )\n    {\n      v2 = sub_40685B(qword_60E340);\n      v3 = gettext(\"offset overflow while reading file %s\");\n      error(0, 0, v3, v2);\n      return 0LL;\n    }\n    v9 = lseek(0, 0LL, 1);\n    if ( v9 >= 0 )\n    {\n      if ( v9 == qword_60E3D0 )\n        return 1LL;\n      v10 = qword_60E3D0 - v9;\n      if ( qword_60E3D0 - v9 < 0 || v10 > a1 )\n      {\n        v4 = gettext(\"warning: invalid file offset after failed read\");\n        error(0, 0, v4);\n      }\n      if ( sub_4038B8(qword_60E340, 0, v10, 1) >= 0 )\n        return 1LL;\n      if ( !*__errno_location() )\n      {\n        v5 = gettext(\"cannot work around kernel bug after all\");\n        error(0, 0, v5);\n      }\n    }\n  }\n  v6 = sub_40685B(qword_60E340);\n  v7 = gettext(\"%s: cannot seek\");\n  v8 = __errno_location();\n  error(0, *v8, v7, v6);\n  return 0LL;\n}\n"], [4210493, "sub_403F3D", "__int64 __fastcall sub_403F3D(char *a1, size_t a2)\n{\n  size_t v2; // rax\n  __int64 v3; // rsi\n  char *v4; // rdi\n  int v5; // ecx\n  int v6; // er8\n  int v7; // er9\n  __int64 result; // rax\n  size_t n; // [rsp+18h] [rbp-8h]\n\n  do\n  {\n    v2 = a2;\n    if ( ::n - qword_60E3F0 <= a2 )\n      v2 = ::n - qword_60E3F0;\n    n = v2;\n    v3 = (__int64)a1;\n    v4 = (char *)s + qword_60E3F0;\n    memcpy((char *)s + qword_60E3F0, a1, v2);\n    a2 -= n;\n    a1 += n;\n    qword_60E3F0 += n;\n    result = ::n;\n    if ( qword_60E3F0 >= ::n )\n      result = sub_402B6D((__int64)v4, v3, qword_60E3F0, v5, v6, v7);\n  }\n  while ( a2 );\n  return result;\n}\n"], [4210660, "sub_403FE4", "__int64 __fastcall sub_403FE4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6)\n{\n  __int64 result; // rax\n  int v7; // ecx\n  __int64 v8; // rax\n  int v9; // ecx\n  __int64 v10; // rax\n  _BYTE *v11; // [rsp+8h] [rbp-18h]\n  __int64 i; // [rsp+10h] [rbp-10h]\n  unsigned __int64 j; // [rsp+18h] [rbp-8h]\n\n  v11 = (_BYTE *)a1;\n  result = a2;\n  for ( i = a2; i; --i )\n  {\n    if ( *v11 == byte_60E278 )\n    {\n      result = qword_60E368;\n      if ( qword_60E3F8 < (unsigned __int64)qword_60E368 )\n      {\n        for ( j = qword_60E3F8; ; ++j )\n        {\n          result = qword_60E368;\n          if ( j >= qword_60E368 )\n            break;\n          v7 = (int)s;\n          v8 = qword_60E3F0++;\n          *((_BYTE *)s + v8) = byte_60E279;\n          if ( qword_60E3F0 >= n )\n            sub_402B6D(a1, a2, qword_60E3F0, v7, a5, a6);\n        }\n      }\n      qword_60E3F8 = 0LL;\n    }\n    else\n    {\n      if ( qword_60E3F8 == qword_60E368 )\n      {\n        ++qword_60E3E0;\n      }\n      else if ( qword_60E3F8 < (unsigned __int64)qword_60E368 )\n      {\n        v9 = (int)s;\n        v10 = qword_60E3F0++;\n        *((_BYTE *)s + v10) = *v11;\n        if ( qword_60E3F0 >= n )\n          sub_402B6D(a1, a2, qword_60E3F0, v9, a5, a6);\n      }\n      result = ++qword_60E3F8;\n    }\n    ++v11;\n  }\n  return result;\n}\n"], [4211000, "sub_404138", "unsigned __int64 __fastcall sub_404138(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, int a5, int a6)\n{\n  unsigned __int64 v6; // rax\n  int v7; // ecx\n  __int64 v8; // rax\n  __int64 v9; // rdx\n  int v10; // ecx\n  __int64 v11; // rax\n  __int64 v12; // rax\n  unsigned __int64 result; // rax\n  char v14; // [rsp+17h] [rbp-9h]\n  unsigned __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 0LL; ; ++i )\n  {\n    result = i;\n    if ( i >= a2 )\n      break;\n    v14 = *(_BYTE *)(a1 + i);\n    v6 = qword_60E3F8++;\n    if ( v6 >= qword_60E368 )\n    {\n      qword_60E5C0 = 0LL;\n      qword_60E3F8 = 0LL;\n      --i;\n      v7 = (int)s;\n      v8 = qword_60E3F0++;\n      *((_BYTE *)s + v8) = byte_60E278;\n      v9 = qword_60E3F0;\n      if ( qword_60E3F0 < n )\n        continue;\nLABEL_13:\n      sub_402B6D(a1, a2, v9, v7, a5, a6);\n      continue;\n    }\n    if ( v14 == byte_60E279 )\n    {\n      ++qword_60E5C0;\n      continue;\n    }\n    while ( qword_60E5C0 )\n    {\n      v10 = (int)s;\n      v11 = qword_60E3F0++;\n      *((_BYTE *)s + v11) = byte_60E279;\n      if ( qword_60E3F0 >= n )\n        sub_402B6D(a1, a2, qword_60E3F0, v10, a5, a6);\n      --qword_60E5C0;\n    }\n    v7 = (int)s;\n    v12 = qword_60E3F0++;\n    *((_BYTE *)s + v12) = v14;\n    v9 = qword_60E3F0;\n    if ( qword_60E3F0 >= n )\n      goto LABEL_13;\n  }\n  return result;\n}\n"], [4211386, "sub_4042BA", "void __fastcall sub_4042BA(int a1, int a2, __int64 a3, int a4, int a5, int a6)\n{\n  int v6; // ecx\n  int v7; // er8\n  int v8; // er9\n  __int64 v9; // r12\n  char *v10; // rbx\n  int *v11; // rax\n  char v13; // [rsp+17h] [rbp-A9h]\n  unsigned int v14; // [rsp+18h] [rbp-A8h]\n  int v15; // [rsp+1Ch] [rbp-A4h]\n  struct stat stat_buf; // [rsp+20h] [rbp-A0h] BYREF\n\n  if ( (a2 & 0xFFFDFEFF) != 0 )\n  {\n    v15 = sub_409105(a1, 3, a3, a4, a5, a6);\n    v14 = v15 | a2 & 0xFFFDFEFF;\n    v13 = 1;\n    if ( v15 >= 0 )\n    {\n      if ( v15 != v14 )\n      {\n        if ( (v14 & 0x10000) != 0 )\n        {\n          if ( (unsigned int)sub_409AF0(a1, &stat_buf) )\n          {\n            v13 = 0;\n          }\n          else if ( (v14 & 0x10000) != 0 && (stat_buf.st_mode & 0xF000) != 0x4000 )\n          {\n            *__errno_location() = 20;\n            v13 = 0;\n          }\n          v14 &= 0xFFFEFFFF;\n        }\n        if ( v13 && v15 != v14 && (unsigned int)sub_409105(a1, 4, v14, v6, v7, v8) == -1 )\n          v13 = 0;\n      }\n    }\n    else\n    {\n      v13 = 0;\n    }\n    if ( v13 != 1 )\n    {\n      v9 = sub_40685B(a3);\n      v10 = gettext(\"setting flags for %s\");\n      v11 = __errno_location();\n      error(1, *v11, v10, v9);\n    }\n  }\n}\n"], [4211800, "sub_404458", "__int64 __fastcall sub_404458(__int64 a1)\n{\n  return sub_405986(a1, &unk_60E5E0, 497LL, 1LL, 1LL);\n}\n"], [4211852, "sub_40448C", "__int64 sub_40448C()\n{\n  __int64 v0; // r12\n  size_t v1; // rbx\n  char *v2; // rax\n  __int64 v3; // rsi\n  __int64 v4; // rdi\n  __int64 v5; // rcx\n  int v6; // er8\n  int v7; // er9\n  __int64 v8; // r12\n  size_t v9; // rbx\n  char *v10; // rax\n  __int64 v11; // rbx\n  char *v12; // rax\n  __int64 v13; // r12\n  char *v14; // rbx\n  int *v15; // rax\n  __int64 v17; // rdx\n  int v18; // eax\n  __int64 v19; // r12\n  char *v20; // rbx\n  __int64 v21; // rcx\n  int v22; // er8\n  int v23; // er9\n  int v24; // eax\n  __int64 v25; // r12\n  char *v26; // rbx\n  int *v27; // rax\n  __int64 v28; // rax\n  __int64 v29; // rax\n  __int64 v30; // rax\n  __int64 v31; // r12\n  char *v32; // rbx\n  int *v33; // rax\n  int v34; // eax\n  __int64 v35; // r12\n  char *v36; // rbx\n  int *v37; // rax\n  unsigned int v38; // [rsp+Ch] [rbp-74h]\n  size_t v39; // [rsp+10h] [rbp-70h] BYREF\n  char *v40; // [rsp+18h] [rbp-68h]\n  __int64 v41; // [rsp+20h] [rbp-60h]\n  size_t v42; // [rsp+28h] [rbp-58h]\n  unsigned __int64 v43; // [rsp+30h] [rbp-50h]\n  unsigned __int64 i; // [rsp+38h] [rbp-48h]\n  void *s; // [rsp+40h] [rbp-40h]\n  size_t v46; // [rsp+48h] [rbp-38h]\n  unsigned __int64 v47; // [rsp+50h] [rbp-30h]\n  size_t v48; // [rsp+58h] [rbp-28h]\n  unsigned __int64 v49; // [rsp+60h] [rbp-20h]\n  unsigned __int64 v50; // [rsp+68h] [rbp-18h]\n\n  v42 = 0LL;\n  v38 = 0;\n  qword_60E870 = (__int64)malloc(2 * (qword_60E350 + 2) + qword_60E358 - 1);\n  if ( !qword_60E870 )\n  {\n    v0 = sub_404458(qword_60E358);\n    v1 = qword_60E358;\n    v2 = gettext(\"memory exhausted by input buffer of size %zu bytes (%s)\");\n    error(1, 0, v2, v1, v0);\n  }\n  v3 = qword_60E350;\n  v4 = qword_60E870 + 2;\n  s = (void *)sub_401C1A(qword_60E870 + 2, qword_60E350);\n  if ( (dword_60E380 & 0x800) != 0 )\n  {\n    qword_60E878 = (__int64)malloc(qword_60E350 + n - 1);\n    if ( !qword_60E878 )\n    {\n      v8 = sub_404458(n);\n      v9 = n;\n      v10 = gettext(\"memory exhausted by output buffer of size %zu bytes (%s)\");\n      error(1, 0, v10, v9, v8);\n    }\n    v3 = qword_60E350;\n    v4 = qword_60E878;\n    ::s = (void *)sub_401C1A(qword_60E878, qword_60E350);\n  }\n  else\n  {\n    qword_60E878 = 0LL;\n    ::s = s;\n  }\n  if ( qword_60E370 )\n  {\n    v46 = qword_60E358 * qword_60E370 + qword_60E3D0;\n    v3 = qword_60E340;\n    v4 = 0LL;\n    v47 = sub_4039CA(0, qword_60E340, qword_60E370, qword_60E358, (__int64)s);\n    v46 -= qword_60E3D0;\n    if ( v47 || byte_60E3D8 != 1 && v46 )\n    {\n      v11 = sub_40685B(qword_60E340);\n      v12 = gettext(\"%s: cannot skip to specified offset\");\n      v3 = 0LL;\n      v4 = 0LL;\n      error(0, 0, v12, v11);\n    }\n  }\n  if ( qword_60E378 )\n  {\n    v3 = qword_60E348;\n    v4 = 1LL;\n    v43 = sub_4039CA(1u, qword_60E348, qword_60E378, n, (__int64)::s);\n    if ( v43 )\n    {\n      memset(::s, 0, n);\n      do\n      {\n        v3 = (__int64)::s;\n        v4 = 1LL;\n        if ( sub_4029FE(1, (__int64)::s, n, v5, v6, v7) != n )\n        {\n          v13 = sub_40685B(qword_60E348);\n          v14 = gettext(\"writing to %s\");\n          v15 = __errno_location();\n          error(0, *v15, v14, v13);\n          sub_402677(1);\n        }\n        --v43;\n      }\n      while ( v43 );\n    }\n  }\n  if ( !qword_60E270 )\n    return 0LL;\n  while ( 1 )\n  {\n    v17 = qword_60E3B0 + qword_60E3A8;\n    if ( qword_60E3B0 + qword_60E3A8 >= (unsigned __int64)qword_60E270 )\n      break;\n    if ( (dword_60E380 & 0x400) != 0 && (dword_60E380 & 0x100) != 0 )\n    {\n      if ( (dword_60E380 & 0x18) != 0 )\n        v18 = 32;\n      else\n        v18 = 0;\n      memset(s, v18, qword_60E358);\n    }\n    v3 = (__int64)s;\n    v4 = 0LL;\n    v41 = qword_60E490(0LL, s, qword_60E358);\n    if ( v41 >= 0 && byte_60E488 )\n    {\n      v3 = v41;\n      v4 = 0LL;\n      sub_402734(0, v41);\n    }\n    if ( !v41 )\n      break;\n    if ( v41 >= 0 )\n    {\nLABEL_41:\n      v39 = v41;\n      sub_403885(v41);\n      if ( v39 >= qword_60E358 )\n      {\n        ++qword_60E3B0;\n        v42 = 0LL;\n      }\n      else\n      {\n        ++qword_60E3A8;\n        v42 = v39;\n        if ( (dword_60E380 & 0x400) != 0 )\n        {\n          if ( (dword_60E380 & 0x100) == 0 )\n          {\n            if ( (dword_60E380 & 0x18) != 0 )\n              v24 = 32;\n            else\n              v24 = 0;\n            memset((char *)s + v39, v24, qword_60E358 - v39);\n          }\n          v39 = qword_60E358;\n        }\n      }\n      if ( s == ::s )\n      {\n        v3 = (__int64)::s;\n        v4 = 1LL;\n        v49 = sub_4029FE(1, (__int64)::s, v39, v21, v22, v23);\n        qword_60E3B8 += v49;\n        if ( v49 != v39 )\n          goto LABEL_52;\n        if ( v39 == qword_60E358 )\n          ++qword_60E3A0;\n        else\n          ++qword_60E398;\n      }\n      else\n      {\n        if ( byte_60E390 )\n          sub_403756((unsigned __int8 *)s, v39);\n        if ( (dword_60E380 & 0x80) != 0 )\n          v40 = (char *)sub_4037B0((__int64)s, &v39);\n        else\n          v40 = (char *)s;\n        if ( (dword_60E380 & 8) != 0 )\n        {\n          v3 = v39;\n          v4 = (__int64)v40;\n          sub_403FE4((__int64)v40, v39, v39, v21, v22, v23);\n        }\n        else\n        {\n          v3 = v39;\n          v4 = (__int64)v40;\n          if ( (dword_60E380 & 0x10) != 0 )\n            sub_404138((__int64)v40, v39, v39, v21, v22, v23);\n          else\n            sub_403F3D(v40, v39);\n        }\n      }\n    }\n    else\n    {\n      v19 = sub_40685B(qword_60E340);\n      v20 = gettext(\"reading %s\");\n      v3 = (unsigned int)*__errno_location();\n      v4 = 0LL;\n      error(0, v3, v20, v19);\n      if ( (dword_60E380 & 0x100) == 0 )\n      {\n        v38 = 1;\n        break;\n      }\n      sub_4020A6();\n      v48 = qword_60E358 - v42;\n      v3 = qword_60E358 - v42;\n      sub_402734(0, qword_60E358 - v42);\n      v4 = v48;\n      if ( (unsigned __int8)sub_403D59(v48) != 1 )\n      {\n        v38 = 1;\n        byte_60E3C8 = 0;\n        dword_60E3CC = 29;\n      }\n      if ( (dword_60E380 & 0x400) != 0 && !v42 )\n      {\n        v41 = 0LL;\n        goto LABEL_41;\n      }\n    }\n  }\n  if ( byte_60E5A0 )\n  {\n    if ( (dword_60E380 & 8) != 0 )\n    {\n      v3 = 1LL;\n      v4 = (__int64)&byte_60E5A1;\n      sub_403FE4((__int64)&byte_60E5A1, 1LL, v17, v5, v6, v7);\n    }\n    else if ( (dword_60E380 & 0x10) != 0 )\n    {\n      v3 = 1LL;\n      v4 = (__int64)&byte_60E5A1;\n      sub_404138((__int64)&byte_60E5A1, 1uLL, v17, v5, v6, v7);\n    }\n    else\n    {\n      LODWORD(v5) = (_DWORD)::s;\n      v28 = qword_60E3F0++;\n      *((_BYTE *)::s + v28) = byte_60E5A1;\n      if ( qword_60E3F0 >= n )\n        sub_402B6D(v4, v3, qword_60E3F0, v5, v6, v7);\n    }\n  }\n  if ( (dword_60E380 & 8) != 0 && qword_60E3F8 )\n  {\n    for ( i = qword_60E3F8; i < qword_60E368; ++i )\n    {\n      LODWORD(v5) = (_DWORD)::s;\n      v29 = qword_60E3F0++;\n      *((_BYTE *)::s + v29) = byte_60E279;\n      if ( qword_60E3F0 >= n )\n        sub_402B6D(v4, v3, qword_60E3F0, v5, v6, v7);\n    }\n  }\n  if ( qword_60E3F8 )\n  {\n    if ( (dword_60E380 & 0x10) != 0 )\n    {\n      LODWORD(v5) = (_DWORD)::s;\n      v30 = qword_60E3F0++;\n      *((_BYTE *)::s + v30) = byte_60E278;\n      if ( qword_60E3F0 >= n )\n        sub_402B6D(v4, v3, qword_60E3F0, v5, v6, v7);\n    }\n  }\n  if ( qword_60E3F0 )\n  {\n    v50 = sub_4029FE(1, (__int64)::s, qword_60E3F0, v5, v6, v7);\n    qword_60E3B8 += v50;\n    if ( v50 )\n      ++qword_60E398;\n    if ( v50 != qword_60E3F0 )\n    {\nLABEL_52:\n      v25 = sub_40685B(qword_60E348);\n      v26 = gettext(\"writing %s\");\n      v27 = __errno_location();\n      error(0, *v27, v26, v25);\n      return 1LL;\n    }\n  }\n  if ( (dword_60E380 & 0x4000) != 0 && fdatasync(1) )\n  {\n    if ( *__errno_location() != 38 && *__errno_location() != 22 )\n    {\n      v31 = sub_40685B(qword_60E348);\n      v32 = gettext(\"fdatasync failed for %s\");\n      v33 = __errno_location();\n      error(0, *v33, v32, v31);\n      v38 = 1;\n    }\n    v34 = dword_60E380;\n    BYTE1(v34) = BYTE1(dword_60E380) | 0x80;\n    dword_60E380 = v34;\n  }\n  if ( (dword_60E380 & 0x8000) != 0 )\n  {\n    while ( fsync(1) )\n    {\n      if ( *__errno_location() != 4 )\n      {\n        v35 = sub_40685B(qword_60E348);\n        v36 = gettext(\"fsync failed for %s\");\n        v37 = __errno_location();\n        error(0, *v37, v36, v35);\n        return 1LL;\n      }\n    }\n  }\n  return v38;\n}\n"], [4214415, "main", "void __fastcall __noreturn main(int a1, char **a2, char **a3)\n{\n  int v3; // ecx\n  int v4; // er8\n  int v5; // er9\n  __int64 v6; // r12\n  char *v7; // rbx\n  int *v8; // rax\n  __int64 v9; // rax\n  int v10; // ecx\n  int v11; // er8\n  int v12; // er9\n  int v13; // eax\n  int v14; // edx\n  int v15; // eax\n  int v16; // edx\n  int v17; // eax\n  __int64 v18; // r12\n  char *v19; // rbx\n  int *v20; // rax\n  __int64 v21; // rbx\n  char *v22; // rax\n  __int64 v23; // r12\n  char *v24; // rbx\n  int *v25; // rax\n  __int64 v26; // rbx\n  char *v27; // rax\n  __int64 v28; // r12\n  char *v29; // rbx\n  int *v30; // rax\n  __int64 v31; // r12\n  char *v32; // rbx\n  int *v33; // rax\n  int i; // [rsp+34h] [rbp-CCh]\n  int v35; // [rsp+38h] [rbp-C8h]\n  int v36; // [rsp+40h] [rbp-C0h]\n  int errnum; // [rsp+44h] [rbp-BCh]\n  __off_t v38; // [rsp+48h] [rbp-B8h]\n  size_t length; // [rsp+50h] [rbp-B0h]\n  size_t v40; // [rsp+58h] [rbp-A8h]\n  struct stat stat_buf; // [rsp+60h] [rbp-A0h] BYREF\n\n  sub_40234D();\n  sub_406750(*a2);\n  setlocale(6, shortopts);\n  bindtextdomain(\"coreutils\", \"/root/Product/coreutils/exe/share/locale\");\n  textdomain(\"coreutils\");\n  sub_409AD0(sub_401D6A);\n  qword_60E350 = getpagesize();\n  sub_406601(\n    a1,\n    (_DWORD)a2,\n    (unsigned int)\"dd\",\n    (unsigned int)\"coreutils\",\n    (_DWORD)off_60E288,\n    (unsigned int)sub_401D9F,\n    \"Paul Rubin\",\n    \"David MacKenzie\",\n    \"Stuart Kemp\",\n    0LL);\n  byte_60E27A = 0;\n  if ( getopt_long(a1, a2, shortopts, 0LL, 0LL) != -1 )\n    sub_401D9F(1);\n  for ( i = 0; i <= 255; ++i )\n    byte_60E4A0[i] = i;\n  sub_402EBF(a1, (__int64)a2);\n  sub_40363D();\n  if ( qword_60E340 )\n  {\n    if ( (int)sub_409568(0LL, qword_60E340, (unsigned int)dword_60E384, 0LL) < 0 )\n    {\n      v6 = sub_40685B(qword_60E340);\n      v7 = gettext(\"opening %s\");\n      v8 = __errno_location();\n      error(1, *v8, v7, v6);\n    }\n  }\n  else\n  {\n    qword_60E340 = (__int64)gettext(\"standard input\");\n    sub_4042BA(0, dword_60E384, qword_60E340, v3, v4, v5);\n  }\n  v38 = lseek(0, 0LL, 1);\n  byte_60E3C8 = v38 >= 0;\n  v9 = 0LL;\n  if ( v38 >= 0 )\n    v9 = v38;\n  qword_60E3D0 = v9;\n  dword_60E3CC = *__errno_location();\n  if ( qword_60E348 )\n  {\n    if ( (dword_60E380 & 0x1000) != 0 )\n      v13 = 0;\n    else\n      v13 = 64;\n    v14 = v13 | dword_60E388;\n    if ( (dword_60E380 & 0x2000) != 0 )\n      v15 = 128;\n    else\n      v15 = 0;\n    v16 = v15 | v14;\n    if ( qword_60E378 || (dword_60E380 & 0x200) != 0 )\n      v17 = 0;\n    else\n      v17 = 512;\n    v36 = v16 | v17;\n    if ( (!qword_60E378 || (int)sub_409568(1LL, qword_60E348, v36 | 2u, 438LL) < 0)\n      && (int)sub_409568(1LL, qword_60E348, v36 | 1u, 438LL) < 0 )\n    {\n      v18 = sub_40685B(qword_60E348);\n      v19 = gettext(\"opening %s\");\n      v20 = __errno_location();\n      error(1, *v20, v19, v18);\n    }\n    if ( qword_60E378 && (dword_60E380 & 0x200) == 0 )\n    {\n      length = qword_60E378 * n;\n      v40 = n;\n      if ( 0x7FFFFFFFFFFFFFFFLL / n < qword_60E378 )\n      {\n        v21 = qword_60E378;\n        v22 = gettext(\"offset too large: cannot truncate to a length of seek=%lu (%lu-byte) blocks\");\n        error(1, 0, v22, v21, v40);\n      }\n      if ( ftruncate(1, length) )\n      {\n        errnum = *__errno_location();\n        if ( (unsigned int)sub_409AF0(1, &stat_buf) )\n        {\n          v23 = sub_40685B(qword_60E348);\n          v24 = gettext(\"cannot fstat %s\");\n          v25 = __errno_location();\n          error(1, *v25, v24, v23);\n        }\n        if ( (stat_buf.st_mode & 0xF000) == 0x8000 || (stat_buf.st_mode & 0xF000) == 0x4000 )\n        {\n          v26 = sub_40685B(qword_60E348);\n          v27 = gettext(\"failed to truncate to %lu bytes in output file %s\");\n          error(1, errnum, v27, length, v26);\n        }\n      }\n    }\n  }\n  else\n  {\n    qword_60E348 = (__int64)gettext(\"standard output\");\n    sub_4042BA(1, dword_60E388, qword_60E348, v10, v11, v12);\n  }\n  qword_60E3C0 = sub_409515();\n  v35 = sub_40448C();\n  if ( qword_60E270 )\n  {\n    if ( qword_60E270 != -1 )\n    {\n      if ( byte_60E488 )\n        sub_402734(0, 0LL);\n      if ( byte_60E489 )\n        sub_402734(1, 0LL);\n    }\n  }\n  else\n  {\n    if ( byte_60E488 && !sub_402734(0, 0LL) )\n    {\n      v28 = sub_40685B(qword_60E340);\n      v29 = gettext(\"failed to discard cache for: %s\");\n      v30 = __errno_location();\n      error(0, *v30, v29, v28);\n      v35 = 1;\n    }\n    if ( byte_60E489 )\n    {\n      if ( !sub_402734(1, 0LL) )\n      {\n        v31 = sub_40685B(qword_60E348);\n        v32 = gettext(\"failed to discard cache for: %s\");\n        v33 = __errno_location();\n        error(0, *v33, v32, v31);\n        sub_402677(1);\n      }\n    }\n  }\n  sub_402677(v35);\n}\n"], [4216065, "sub_405501", "__int64 __fastcall sub_405501(FILE *a1)\n{\n  bool v2; // [rsp+1Dh] [rbp-3h]\n  bool v3; // [rsp+1Eh] [rbp-2h]\n  bool v4; // [rsp+1Fh] [rbp-1h]\n\n  v2 = __fpending(a1) != 0;\n  v3 = ferror_unlocked(a1) != 0;\n  v4 = (unsigned int)sub_409050(a1) != 0;\n  if ( !v3 && (!v4 || !v2 && *__errno_location() == 9) )\n    return 0LL;\n  if ( !v4 )\n    *__errno_location() = 0;\n  return 0xFFFFFFFFLL;\n}\n"], [4216204, "sub_40558C", "__int64 __fastcall sub_40558C(__int64 a1)\n{\n  __int64 result; // rax\n\n  result = a1;\n  qword_60E880 = a1;\n  return result;\n}\n"], [4216225, "sub_4055A1", "__int64 __fastcall sub_4055A1(unsigned __int8 a1)\n{\n  __int64 result; // rax\n\n  result = a1;\n  byte_60E888 = a1;\n  return result;\n}\n"], [4216246, "sub_4055B6", "__int64 sub_4055B6()\n{\n  const char *v0; // rbx\n  int *v1; // rax\n  int *v2; // rax\n  __int64 result; // rax\n  char *v4; // [rsp+8h] [rbp-18h]\n\n  if ( (unsigned int)sub_405501(stdout) && (byte_60E888 != 1 || *__errno_location() != 32) )\n  {\n    v4 = gettext(\"write error\");\n    if ( qword_60E880 )\n    {\n      v0 = (const char *)sub_407E74(qword_60E880);\n      v1 = __errno_location();\n      error(0, *v1, \"%s: %s\", v0, v4);\n    }\n    else\n    {\n      v2 = __errno_location();\n      error(0, *v2, \"%s\", v4);\n    }\n    _exit(status);\n  }\n  result = sub_405501(stderr);\n  if ( (_DWORD)result )\n    _exit(status);\n  return result;\n}\n"], [4216481, "sub_4056A1", "_BYTE *__fastcall sub_4056A1(_BYTE *a1)\n{\n  char v2; // [rsp+17h] [rbp-11h]\n  _BYTE *i; // [rsp+20h] [rbp-8h]\n\n  v2 = 0;\n  while ( *a1 == 47 )\n    ++a1;\n  for ( i = a1; *i; ++i )\n  {\n    if ( *i == 47 )\n    {\n      v2 = 1;\n    }\n    else if ( v2 )\n    {\n      a1 = i;\n      v2 = 0;\n    }\n  }\n  return a1;\n}\n"], [4216586, "sub_40570A", "size_t __fastcall sub_40570A(const char *a1)\n{\n  size_t i; // [rsp+10h] [rbp-10h]\n\n  for ( i = strlen(a1); i > 1 && a1[i - 1] == 47; --i )\n    ;\n  return i;\n}\n"], [4216664, "sub_405758", "long double __fastcall sub_405758(int a1, long double a2)\n{\n  _BOOL4 v7; // eax\n  long double v9; // [rsp+0h] [rbp-30h]\n  unsigned __int64 v10; // [rsp+28h] [rbp-8h]\n\n  if ( a1 != 1 && a2 < 1.8446744073709551615e19 )\n  {\n    if ( a2 >= 9.223372036854775808e18 )\n      v10 = (__int64)(a2 - 9.223372036854775808e18) ^ 0x8000000000000000LL;\n    else\n      v10 = (__int64)a2;\n    v7 = !a1 && a2 != (long double)v10;\n    a2 = (long double)(v7 + v10);\n  }\n  *(_QWORD *)&v9 = *(_QWORD *)&a2;\n  DWORD2(v9) = DWORD2(a2);\n  return v9;\n}\n"], [4216911, "sub_40584F", "char *__fastcall sub_40584F(char *a1, size_t a2, unsigned __int8 *a3, const char *a4)\n{\n  char *i; // rbx\n  size_t v5; // rax\n  char *v6; // rbx\n  unsigned __int8 v10; // [rsp+27h] [rbp-69h]\n  size_t v11; // [rsp+28h] [rbp-68h]\n  size_t v12; // [rsp+30h] [rbp-60h]\n  size_t v13; // [rsp+38h] [rbp-58h]\n  char dest[56]; // [rsp+40h] [rbp-50h] BYREF\n  unsigned __int64 v15; // [rsp+78h] [rbp-18h]\n\n  v15 = __readfsqword(0x28u);\n  v11 = -1LL;\n  v13 = strlen(a4);\n  v12 = a2;\n  memcpy(dest, a1, a2);\n  for ( i = &a1[a2]; ; memcpy(i, a4, v13) )\n  {\n    v10 = *a3;\n    if ( *a3 )\n    {\n      if ( v10 > 0x7Eu )\n        v5 = v12;\n      else\n        v5 = v10;\n      v11 = v5;\n      ++a3;\n    }\n    if ( v12 < v11 )\n      v11 = v12;\n    v6 = &i[-v11];\n    v12 -= v11;\n    memcpy(v6, &dest[v12], v11);\n    if ( !v12 )\n      break;\n    i = &v6[-v13];\n  }\n  return v6;\n}\n"], [4217222, "sub_405986", "char *__fastcall sub_405986(unsigned __int64 a1, char *a2, __int16 a3, unsigned __int64 a4, unsigned __int64 a5)\n{\n  int v5; // eax\n  int v6; // eax\n  long double v7; // fst7\n  long double v8; // fst7\n  long double v9; // fst7\n  int v10; // eax\n  bool v11; // al\n  bool v12; // al\n  bool v13; // al\n  bool v14; // al\n  char *v15; // rax\n  char v16; // dl\n  char *v17; // rax\n  char *v18; // rax\n  long double v20; // [rsp+0h] [rbp-130h]\n  int v24; // [rsp+44h] [rbp-ECh]\n  int v25; // [rsp+48h] [rbp-E8h]\n  int v26; // [rsp+4Ch] [rbp-E4h]\n  int v27; // [rsp+50h] [rbp-E0h]\n  unsigned int v28; // [rsp+54h] [rbp-DCh]\n  unsigned int v29; // [rsp+5Ch] [rbp-D4h]\n  unsigned int v30; // [rsp+60h] [rbp-D0h]\n  unsigned __int64 v31; // [rsp+68h] [rbp-C8h]\n  char *dest; // [rsp+70h] [rbp-C0h]\n  char *desta; // [rsp+70h] [rbp-C0h]\n  char *v34; // [rsp+78h] [rbp-B8h]\n  char *v35; // [rsp+80h] [rbp-B0h]\n  char *src; // [rsp+88h] [rbp-A8h]\n  size_t v37; // [rsp+90h] [rbp-A0h]\n  const char *v38; // [rsp+98h] [rbp-98h]\n  unsigned __int64 n; // [rsp+A0h] [rbp-90h]\n  size_t v40; // [rsp+A8h] [rbp-88h]\n  unsigned __int64 i; // [rsp+B0h] [rbp-80h]\n  unsigned __int8 *v42; // [rsp+B8h] [rbp-78h]\n  struct lconv *v43; // [rsp+C0h] [rbp-70h]\n  size_t v44; // [rsp+C8h] [rbp-68h]\n  unsigned __int64 v45; // [rsp+E8h] [rbp-48h]\n  long double v46; // [rsp+F0h] [rbp-40h]\n  long double v47; // [rsp+110h] [rbp-20h]\n  long double v48; // [rsp+110h] [rbp-20h]\n\n  v27 = a3 & 3;\n  if ( (a3 & 0x20) != 0 )\n    v5 = 1024;\n  else\n    v5 = 1000;\n  v28 = v5;\n  v25 = -1;\n  src = \".\";\n  v37 = 1LL;\n  v38 = (const char *)&unk_40B40B;\n  v43 = localeconv();\n  v44 = strlen(v43->decimal_point);\n  if ( v44 && v44 <= 0x10 )\n  {\n    src = v43->decimal_point;\n    v37 = v44;\n  }\n  v42 = (unsigned __int8 *)v43->grouping;\n  if ( strlen(v43->thousands_sep) <= 0x10 )\n    v38 = v43->thousands_sep;\n  v34 = a2 + 648;\n  dest = a2 + 648;\n  if ( a5 > a4 )\n  {\n    if ( a4 && !(a5 % a4) )\n    {\n      v45 = 2 * (10 * (a1 % (a5 / a4)) % (a5 / a4));\n      v31 = a1 / (a5 / a4);\n      v24 = 10 * (a1 % (a5 / a4)) / (a5 / a4);\n      if ( v45 >= a5 / a4 )\n      {\n        if ( a5 / a4 >= v45 )\n          v6 = 2;\n        else\n          v6 = 3;\n      }\n      else\n      {\n        v6 = v45 != 0;\n      }\n      v26 = v6;\nLABEL_32:\n      if ( (a3 & 0x10) != 0 )\n      {\n        v25 = 0;\n        if ( v28 <= v31 )\n        {\n          do\n          {\n            v29 = 10 * (v31 % v28) + v24;\n            v30 = 2 * (v29 % v28) + (v26 >> 1);\n            v31 /= v28;\n            v24 = v29 / v28;\n            if ( v30 >= v28 )\n            {\n              if ( v26 + v30 <= v28 )\n                v10 = 2;\n              else\n                v10 = 3;\n            }\n            else\n            {\n              v10 = v26 + v30 != 0;\n            }\n            v26 = v10;\n            ++v25;\n          }\n          while ( v28 <= v31 && v25 < 8 );\n          if ( v31 <= 9 )\n          {\n            if ( v27 == 1 )\n            {\n              v11 = (int)(((v29 / v28) & 1) + v10) > 2;\n            }\n            else\n            {\n              v12 = !v27 && v10 > 0;\n              v11 = v12;\n            }\n            if ( v11 )\n            {\n              ++v24;\n              v26 = 0;\n              if ( v24 == 10 )\n              {\n                ++v31;\n                v24 = 0;\n              }\n            }\n            if ( v31 <= 9 && (v24 || (a3 & 8) == 0) )\n            {\n              a2[647] = v24 + 48;\n              dest = &a2[-v37 + 647];\n              memcpy(dest, src, v37);\n              v26 = 0;\n              v24 = 0;\n            }\n          }\n        }\n      }\n      if ( v27 == 1 )\n      {\n        v13 = ((v31 & 1) + v26 != 0) + v24 > 5;\n      }\n      else\n      {\n        v14 = !v27 && v24 + v26 > 0;\n        v13 = v14;\n      }\n      if ( v13 )\n      {\n        ++v31;\n        if ( (a3 & 0x10) != 0 && v28 == v31 && v25 < 8 )\n        {\n          ++v25;\n          if ( (a3 & 8) == 0 )\n          {\n            desta = dest - 1;\n            *desta = 48;\n            dest = &desta[-v37];\n            memcpy(dest, src, v37);\n          }\n          v31 = 1LL;\n        }\n      }\n      v35 = dest;\n      do\n      {\n        *--dest = v31 % 0xA + 48;\n        v31 /= 0xAuLL;\n      }\n      while ( v31 );\n      goto LABEL_72;\n    }\n  }\n  else if ( !(a4 % a5) )\n  {\n    v31 = a4 / a5 * a1;\n    if ( v31 / (a4 / a5) == a1 )\n    {\n      v24 = 0;\n      v26 = 0;\n      goto LABEL_32;\n    }\n  }\n  v47 = (long double)a1 * ((long double)a4 / (long double)a5);\n  if ( (a3 & 0x10) != 0 )\n  {\n    *(_QWORD *)&v46 = 0x8000000000000000LL;\n    DWORD2(v46) = 0x3FFF;\n    v25 = 0;\n    do\n    {\n      v46 = (long double)v28 * v46;\n      ++v25;\n    }\n    while ( v47 >= (long double)v28 * v46 && v25 < 8 );\n    v48 = v47 / v46;\n    *(_QWORD *)&v20 = *(_QWORD *)&v48;\n    DWORD2(v20) = DWORD2(v48);\n    v8 = sub_405758(v27, v20);\n    sprintf(a2, \"%.1Lf\", v8);\n    n = strlen(a2);\n    v40 = v37 + 1;\n    if ( ((a3 & 0x20) == 0) + v37 + 1 + 1 < n || (a3 & 8) != 0 && a2[n - 1] == 48 )\n    {\n      v9 = sub_405758(v27, v48 * 10.0);\n      sprintf(a2, \"%.0Lf\", v9 / 10.0);\n      n = strlen(a2);\n      v40 = 0LL;\n    }\n  }\n  else\n  {\n    *(_QWORD *)&v20 = *(_QWORD *)&v47;\n    DWORD2(v20) = DWORD2(v47);\n    v7 = sub_405758(v27, v20);\n    sprintf(a2, \"%.0Lf\", v7);\n    n = strlen(a2);\n    v40 = 0LL;\n  }\n  dest = &v34[-n];\n  memmove(&v34[-n], a2, n);\n  v35 = &v34[-v40];\nLABEL_72:\n  if ( (a3 & 4) != 0 )\n    dest = sub_40584F(dest, v35 - dest, v42, v38);\n  if ( (a3 & 0x80) != 0 )\n  {\n    if ( v25 < 0 )\n    {\n      v25 = 0;\n      for ( i = 1LL; i < a5; i *= v28 )\n      {\n        if ( ++v25 == 8 )\n          break;\n      }\n    }\n    if ( v25 | a3 & 0x100 && (a3 & 0x40) != 0 )\n    {\n      v34 = a2 + 649;\n      a2[648] = 32;\n    }\n    if ( v25 )\n    {\n      v15 = v34++;\n      if ( (a3 & 0x20) == 0 && v25 == 1 )\n        v16 = 107;\n      else\n        v16 = byte_40B400[v25];\n      *v15 = v16;\n    }\n    if ( (a3 & 0x100) != 0 )\n    {\n      if ( (a3 & 0x20) != 0 && v25 )\n      {\n        v17 = v34++;\n        *v17 = 105;\n      }\n      v18 = v34++;\n      *v18 = 66;\n    }\n  }\n  *v34 = 0;\n  return dest;\n}\n"], [4219940, "sub_406424", "__int64 sub_406424()\n{\n  __int64 result; // rax\n\n  if ( getenv(\"POSIXLY_CORRECT\") )\n    result = 512LL;\n  else\n    result = 1024LL;\n  return result;\n}\n"], [4219973, "sub_406445", "__int64 __fastcall sub_406445(char *a1, _QWORD *a2, int *a3)\n{\n  char *v5; // [rsp+18h] [rbp-28h]\n  int v6; // [rsp+2Ch] [rbp-14h]\n  int v7; // [rsp+30h] [rbp-10h]\n  unsigned int v8; // [rsp+34h] [rbp-Ch]\n  char *v9; // [rsp+38h] [rbp-8h] BYREF\n\n  v5 = a1;\n  v6 = 0;\n  if ( a1 || (v5 = getenv(\"BLOCK_SIZE\")) != 0LL || (v5 = getenv(\"BLOCKSIZE\")) != 0LL )\n  {\n    if ( *v5 == 39 )\n    {\n      v6 = 4;\n      ++v5;\n    }\n    v7 = sub_4095F1(v5, off_40B430, dword_40B448, 4LL);\n    if ( v7 < 0 )\n    {\n      v8 = sub_408BE4(v5, &v9, 0LL, a2, \"eEgGkKmMpPtTyYzZ0\");\n      if ( v8 )\n      {\n        *a3 = 0;\n        return v8;\n      }\n      while ( *v5 <= 47 || *v5 > 57 )\n      {\n        if ( v5 == v9 )\n        {\n          v6 |= 0x80u;\n          if ( *(v9 - 1) == 66 )\n            v6 |= 0x100u;\n          if ( *(v9 - 1) != 66 || *(v9 - 2) == 105 )\n            v6 |= 0x20u;\n          break;\n        }\n        ++v5;\n      }\n    }\n    else\n    {\n      v6 |= dword_40B448[v7];\n      *a2 = 1LL;\n    }\n  }\n  else\n  {\n    *a2 = sub_406424();\n  }\n  *a3 = v6;\n  return 0LL;\n}\n"], [4220335, "sub_4065AF", "__int64 __fastcall sub_4065AF(char *a1, int *a2, _QWORD *a3)\n{\n  unsigned int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = sub_406445(a1, a3, a2);\n  if ( !*a3 )\n  {\n    *a3 = sub_406424();\n    v5 = 4;\n  }\n  return v5;\n}\n"], [4220417, "sub_406601", "__int64 sub_406601(int a1, char *const *a2, __int64 a3, __int64 a4, __int64 a5, void (__fastcall *a6)(_QWORD), ...)\n{\n  __int64 result; // rax\n  unsigned int v11; // [rsp+30h] [rbp-D0h]\n  int v12; // [rsp+34h] [rbp-CCh]\n  gcc_va_list va; // [rsp+38h] [rbp-C8h] BYREF\n\n  v11 = opterr;\n  opterr = 0;\n  if ( a1 == 2 )\n  {\n    v12 = getopt_long(2, a2, \"+\", &longopts, 0LL);\n    if ( v12 != -1 )\n    {\n      if ( v12 == 104 )\n      {\n        a6(0LL);\n      }\n      else if ( v12 != 118 )\n      {\n        goto LABEL_8;\n      }\n      va_start(va, a6);\n      sub_40864C(stdout, a3, a4, a5, va);\n      exit(0);\n    }\n  }\nLABEL_8:\n  result = v11;\n  opterr = v11;\n  optind = 0;\n  return result;\n}\n"], [4220752, "sub_406750", "char *__fastcall sub_406750(const char *a1)\n{\n  char *v1; // rax\n  char *result; // rax\n  char *s; // [rsp+8h] [rbp-18h]\n  char *v4; // [rsp+10h] [rbp-10h]\n  char *s1; // [rsp+18h] [rbp-8h]\n\n  s = (char *)a1;\n  if ( !a1 )\n  {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\", 1uLL, 0x37uLL, stderr);\n    abort();\n  }\n  v4 = strrchr(a1, 47);\n  if ( v4 )\n    v1 = v4 + 1;\n  else\n    v1 = (char *)a1;\n  s1 = v1;\n  if ( v1 - a1 > 6 && !strncmp(v1 - 7, \"/.libs/\", 7uLL) )\n  {\n    s = s1;\n    if ( !strncmp(s1, \"lt-\", 3uLL) )\n    {\n      s = s1 + 3;\n      program_invocation_short_name = (__int64)(s1 + 3);\n    }\n  }\n  qword_60E890 = (__int64)s;\n  result = s;\n  program_invocation_name = (__int64)s;\n  return result;\n}\n"], [4220983, "sub_406837", "__int64 __fastcall sub_406837(unsigned int a1, __int64 a2)\n{\n  return sub_407CE6(a1, 6LL, a2);\n}\n"], [4221019, "sub_40685B", "__int64 __fastcall sub_40685B(__int64 a1)\n{\n  return sub_406837(0, a1);\n}\n"], [4221050, "sub_40687A", "__int64 __fastcall sub_40687A(__int64 *a1)\n{\n  __int64 *v1; // rax\n  int v3; // [rsp+14h] [rbp-Ch]\n  __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v3 = *__errno_location();\n  if ( a1 )\n    v1 = a1;\n  else\n    v1 = &qword_60E8A0;\n  v4 = sub_408AB1(v1, 56LL);\n  *__errno_location() = v3;\n  return v4;\n}\n"], [4221123, "sub_4068C3", "__int64 __fastcall sub_4068C3(__int64 *a1)\n{\n  __int64 *v1; // rax\n\n  if ( a1 )\n    v1 = a1;\n  else\n    v1 = &qword_60E8A0;\n  return *(unsigned int *)v1;\n}\n"], [4221153, "sub_4068E1", "__int64 *__fastcall sub_4068E1(__int64 *a1, int a2)\n{\n  __int64 *result; // rax\n\n  if ( a1 )\n    result = a1;\n  else\n    result = &qword_60E8A0;\n  *(_DWORD *)result = a2;\n  return result;\n}\n"], [4221189, "sub_406905", "__int64 __fastcall sub_406905(__int64 *a1, unsigned __int8 a2, char a3)\n{\n  __int64 *v3; // rax\n  unsigned int v5; // [rsp+24h] [rbp-Ch]\n\n  if ( a1 )\n    v3 = a1;\n  else\n    v3 = &qword_60E8A0;\n  v5 = (*((_DWORD *)v3 + (a2 >> 5) + 2) >> (a2 & 0x1F)) & 1;\n  *((_DWORD *)v3 + (a2 >> 5) + 2) ^= (v5 ^ a3 & 1) << (a2 & 0x1F);\n  return v5;\n}\n"], [4221325, "sub_40698D", "__int64 __fastcall sub_40698D(__int64 *a1, int a2)\n{\n  __int64 *v3; // [rsp+4h] [rbp-18h]\n  unsigned int v4; // [rsp+18h] [rbp-4h]\n\n  v3 = a1;\n  if ( !a1 )\n    v3 = &qword_60E8A0;\n  v4 = *((_DWORD *)v3 + 1);\n  *((_DWORD *)v3 + 1) = a2;\n  return v4;\n}\n"], [4221376, "sub_4069C0", "__int64 *__fastcall sub_4069C0(__int64 *a1, __int64 a2, __int64 a3)\n{\n  __int64 *result; // rax\n  __int64 *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = a1;\n  if ( !a1 )\n    v4 = &qword_60E8A0;\n  *(_DWORD *)v4 = 8;\n  if ( !a2 || !a3 )\n    abort();\n  v4[5] = a2;\n  result = v4;\n  v4[6] = a3;\n  return result;\n}\n"], [4221466, "sub_406A1A", "_QWORD *__fastcall sub_406A1A(_QWORD *a1, int a2)\n{\n  __int64 v3[7]; // [rsp+10h] [rbp-40h] BYREF\n\n  memset(v3, 0, sizeof(v3));\n  if ( a2 == 8 )\n    abort();\n  LODWORD(v3[0]) = a2;\n  *a1 = v3[0];\n  a1[1] = v3[1];\n  a1[2] = v3[2];\n  a1[3] = v3[3];\n  a1[4] = v3[4];\n  a1[5] = v3[5];\n  a1[6] = v3[6];\n  return a1;\n}\n"], [4221586, "sub_406A92", "char *__fastcall sub_406A92(const char *a1, int a2)\n{\n  char *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = gettext(a1);\n  if ( v3 == a1 && a2 == 7 )\n    v3 = (char *)L\"\\\"`'\";\n  return v3;\n}\n"], [4221647, "sub_406ACF", "unsigned __int64 __fastcall sub_406ACF(__int64 a1, unsigned __int64 a2, __int64 a3, size_t a4, unsigned int a5, int a6, __int64 a7, char *a8, char *a9)\n{\n  int v9; // eax\n  bool v10; // al\n  int v11; // eax\n  char v20; // [rsp+65h] [rbp-6Bh]\n  bool v21; // [rsp+66h] [rbp-6Ah]\n  unsigned __int8 v22; // [rsp+67h] [rbp-69h]\n  char v23; // [rsp+68h] [rbp-68h]\n  char v24; // [rsp+69h] [rbp-67h]\n  bool v25; // [rsp+6Ah] [rbp-66h]\n  bool v26; // [rsp+6Bh] [rbp-65h]\n  wchar_t pwc; // [rsp+6Ch] [rbp-64h] BYREF\n  __int64 i; // [rsp+70h] [rbp-60h]\n  unsigned __int64 v29; // [rsp+78h] [rbp-58h]\n  char *s; // [rsp+80h] [rbp-50h]\n  size_t n; // [rsp+88h] [rbp-48h]\n  unsigned __int64 v32; // [rsp+90h] [rbp-40h]\n  unsigned __int64 j; // [rsp+98h] [rbp-38h]\n  size_t v34; // [rsp+A0h] [rbp-30h]\n  unsigned __int64 v35; // [rsp+A8h] [rbp-28h]\n  mbstate_t p; // [rsp+B0h] [rbp-20h] BYREF\n  unsigned __int64 v37; // [rsp+B8h] [rbp-18h]\n\n  v37 = __readfsqword(0x28u);\n  v29 = 0LL;\n  s = 0LL;\n  n = 0LL;\n  v20 = 0;\n  v26 = __ctype_get_mb_cur_max() == 1;\n  v21 = (a6 & 2) != 0;\n  if ( a5 == 3 )\n    goto LABEL_11;\n  if ( a5 > 3 )\n  {\n    if ( a5 == 5 )\n    {\n      v20 = 1;\n      v21 = 0;\n      goto LABEL_33;\n    }\n    if ( a5 >= 5 )\n    {\n      if ( a5 > 8 )\n        abort();\n      if ( a5 != 8 )\n      {\n        a8 = sub_406A92((const char *)L\"`'\", a5);\n        a9 = sub_406A92((const char *)L\"'\", a5);\n      }\n      if ( (a6 & 2) == 0 )\n      {\n        for ( s = a8; *s; ++s )\n        {\n          if ( v29 < a2 )\n            *(_BYTE *)(v29 + a1) = *s;\n          ++v29;\n        }\n      }\n      v20 = 1;\n      s = a9;\n      n = strlen(a9);\n      goto LABEL_33;\n    }\n    a5 = 3;\n    v21 = 1;\nLABEL_11:\n    if ( !v21 )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(a1 + v29) = 34;\n      ++v29;\n    }\n    v20 = 1;\n    s = (char *)L\"\\\"`'\";\n    n = 1LL;\n    goto LABEL_33;\n  }\n  if ( a5 == 1 )\n  {\n    a5 = 2;\n    v21 = 1;\n    goto LABEL_27;\n  }\n  if ( a5 > 1 )\n  {\nLABEL_27:\n    if ( !v21 )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(a1 + v29) = 39;\n      ++v29;\n    }\n    s = (_BYTE *)(L\"\\\"`'\" + 4);\n    n = 1LL;\n    goto LABEL_33;\n  }\n  v21 = 0;\nLABEL_33:\n  for ( i = 0LL; a4 == -1LL ? *(_BYTE *)(a3 + i) != 0 : i != a4; ++i )\n  {\n    v24 = 0;\n    if ( v20 && n && i + n <= a4 && !memcmp((const void *)(a3 + i), s, n) )\n    {\n      if ( v21 )\n        return sub_406ACF(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n      v24 = 1;\n    }\n    v22 = *(_BYTE *)(a3 + i);\n    if ( v22 > 0x3Au )\n    {\n      if ( v22 == 94 )\n        goto LABEL_144;\n      if ( v22 > 0x5Eu )\n      {\n        if ( v22 <= 0x7Au )\n        {\n          if ( v22 >= 0x61u || v22 == 95 )\n            goto LABEL_206;\n          goto LABEL_144;\n        }\n        if ( v22 != 124 )\n        {\n          if ( v22 < 0x7Cu || v22 == 125 )\n          {\n            if ( a4 == -1LL )\n              v10 = *(_BYTE *)(a3 + 1) != 0;\n            else\n              v10 = a4 != 1;\n            if ( v10 )\n              goto LABEL_206;\n          }\n          else if ( v22 != 126 )\n          {\nLABEL_157:\n            if ( v26 )\n            {\n              v32 = 1LL;\n              v25 = ((*__ctype_b_loc())[v22] & 0x4000) != 0;\n            }\n            else\n            {\n              memset(&p, 0, sizeof(p));\n              v32 = 0LL;\n              v25 = 1;\n              if ( a4 == -1LL )\n                a4 = strlen((const char *)a3);\n              do\n              {\n                v34 = mbrtowc(&pwc, (const char *)(v32 + i + a3), a4 - (v32 + i), &p);\n                if ( !v34 )\n                  break;\n                if ( v34 == -1LL )\n                {\n                  v25 = 0;\n                  break;\n                }\n                if ( v34 == -2LL )\n                {\n                  v25 = 0;\n                  while ( i + v32 < a4 && *(_BYTE *)(v32 + i + a3) )\n                    ++v32;\n                  break;\n                }\n                if ( v21 && a5 == 2 )\n                {\n                  for ( j = 1LL; j < v34; ++j )\n                  {\n                    v11 = *(char *)(j + v32 + i + a3);\n                    if ( v11 == 94 )\n                      return sub_406ACF(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    if ( v11 > 94 )\n                    {\n                      if ( v11 == 96 || v11 == 124 )\n                        return sub_406ACF(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    }\n                    else if ( (unsigned int)(v11 - 91) <= 1 )\n                    {\n                      return sub_406ACF(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    }\n                  }\n                }\n                if ( !iswprint(pwc) )\n                  v25 = 0;\n                v32 += v34;\n              }\n              while ( !mbsinit(&p) );\n            }\n            if ( v32 > 1 || v20 && !v25 )\n            {\n              v35 = i + v32;\n              while ( 1 )\n              {\n                if ( v20 && !v25 )\n                {\n                  if ( v21 )\n                    return sub_406ACF(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                  if ( v29 < a2 )\n                    *(_BYTE *)(a1 + v29) = 92;\n                  if ( ++v29 < a2 )\n                    *(_BYTE *)(v29 + a1) = (v22 >> 6) + 48;\n                  if ( ++v29 < a2 )\n                    *(_BYTE *)(v29 + a1) = ((v22 >> 3) & 7) + 48;\n                  ++v29;\n                  v22 = (v22 & 7) + 48;\n                }\n                else if ( v24 )\n                {\n                  if ( v29 < a2 )\n                    *(_BYTE *)(a1 + v29) = 92;\n                  ++v29;\n                  v24 = 0;\n                }\n                if ( i + 1 >= v35 )\n                  break;\n                if ( v29 < a2 )\n                  *(_BYTE *)(v29 + a1) = v22;\n                ++v29;\n                ++i;\n                v22 = *(_BYTE *)(a3 + i);\n              }\n              goto LABEL_215;\n            }\n            goto LABEL_206;\n          }\n          goto LABEL_143;\n        }\nLABEL_144:\n        if ( a5 == 2 && v21 )\n          return sub_406ACF(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        goto LABEL_206;\n      }\n      if ( v22 > 0x5Au )\n      {\n        if ( v22 == 92 )\n        {\n          v23 = *(_BYTE *)(a3 + i);\n          if ( v20 && v21 && n )\n            goto LABEL_215;\n          goto LABEL_134;\n        }\n        if ( v22 <= 0x5Cu )\n          goto LABEL_144;\n      }\n      else\n      {\n        if ( v22 >= 0x41u )\n          goto LABEL_206;\n        if ( v22 <= 0x3Eu )\n          goto LABEL_144;\n        if ( v22 != 63 )\n          goto LABEL_157;\n        if ( a5 == 2 )\n        {\n          if ( v21 )\n            return sub_406ACF(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        }\n        else if ( a5 == 3 && (a6 & 4) != 0 && i + 2 < a4 && *(_BYTE *)(i + 1 + a3) == 63 )\n        {\n          v9 = *(char *)(i + 2 + a3);\n          if ( v9 != 45 )\n          {\n            if ( v9 > 45 )\n            {\n              if ( v9 != 47 && (v9 < 47 || (unsigned int)(v9 - 60) > 2) )\n                goto LABEL_206;\n            }\n            else if ( v9 != 33 && (v9 < 33 || (unsigned int)(v9 - 39) > 2) )\n            {\n              goto LABEL_206;\n            }\n          }\n          if ( v21 )\n            return sub_406ACF(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          v22 = *(_BYTE *)(i + 2 + a3);\n          i += 2LL;\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 63;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 34;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 34;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 63;\n          ++v29;\n        }\n      }\n    }\n    else\n    {\n      if ( v22 >= 0x2Bu )\n        goto LABEL_206;\n      if ( v22 > 0x22u )\n      {\n        if ( v22 != 38 )\n        {\n          if ( v22 > 0x26u )\n          {\n            if ( v22 == 39 )\n            {\n              if ( a5 == 2 )\n              {\n                if ( v21 )\n                  return sub_406ACF(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                if ( v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 39;\n                if ( ++v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 92;\n                if ( ++v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 39;\n                ++v29;\n              }\n              goto LABEL_206;\n            }\n            goto LABEL_144;\n          }\n          if ( v22 != 36 )\n          {\n            if ( v22 > 0x24u )\n              goto LABEL_206;\nLABEL_143:\n            if ( i )\n              goto LABEL_206;\n          }\n        }\n        goto LABEL_144;\n      }\n      if ( v22 >= 0x20u )\n        goto LABEL_144;\n      if ( v22 == 9 )\n      {\n        v23 = 116;\n        goto LABEL_134;\n      }\n      if ( v22 > 9u )\n      {\n        if ( v22 == 11 )\n        {\n          v23 = 118;\n        }\n        else\n        {\n          if ( v22 < 0xBu )\n          {\n            v23 = 110;\n            goto LABEL_134;\n          }\n          if ( v22 == 12 )\n          {\n            v23 = 102;\n          }\n          else\n          {\n            if ( v22 != 13 )\n              goto LABEL_157;\n            v23 = 114;\nLABEL_134:\n            if ( a5 == 2 && v21 )\n              return sub_406ACF(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          }\n        }\nLABEL_136:\n        if ( v20 )\n        {\n          v22 = v23;\nLABEL_211:\n          if ( v21 )\n            return sub_406ACF(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 92;\n          ++v29;\n          goto LABEL_215;\n        }\n        goto LABEL_206;\n      }\n      if ( v22 == 7 )\n      {\n        v23 = 97;\n        goto LABEL_136;\n      }\n      if ( v22 > 7u )\n      {\n        v23 = 98;\n        goto LABEL_136;\n      }\n      if ( v22 )\n        goto LABEL_157;\n      if ( v20 )\n      {\n        if ( v21 )\n          return sub_406ACF(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        if ( v29 < a2 )\n          *(_BYTE *)(a1 + v29) = 92;\n        ++v29;\n        if ( i + 1 < a4 && *(char *)(i + 1 + a3) > 47 && *(char *)(i + 1 + a3) <= 57 )\n        {\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 48;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 48;\n          ++v29;\n        }\n        v22 = 48;\n      }\n      else if ( (a6 & 1) != 0 )\n      {\n        continue;\n      }\n    }\nLABEL_206:\n    if ( (v20 == 1 || v21) && a7 && (*(_DWORD *)(4LL * (v22 >> 5) + a7) & (1 << (v22 & 0x1F))) != 0 || v24 == 1 )\n      goto LABEL_211;\nLABEL_215:\n    if ( v29 < a2 )\n      *(_BYTE *)(v29 + a1) = v22;\n    ++v29;\n  }\n  if ( !v29 && a5 == 2 && v21 )\n    return sub_406ACF(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n  if ( s && !v21 )\n  {\n    while ( *s )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(v29 + a1) = *s;\n      ++v29;\n      ++s;\n    }\n  }\n  if ( v29 < a2 )\n    *(_BYTE *)(a1 + v29) = 0;\n  return v29;\n}\n"], [4224794, "sub_40771A", "unsigned __int64 __fastcall sub_40771A(__int64 a1, unsigned __int64 a2, __int64 a3, size_t a4, __int64 *a5)\n{\n  __int64 *v5; // rax\n  int v9; // [rsp+4Ch] [rbp-14h]\n  __int64 *v10; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+58h] [rbp-8h]\n\n  if ( a5 )\n    v5 = a5;\n  else\n    v5 = &qword_60E8A0;\n  v10 = v5;\n  v9 = *__errno_location();\n  v11 = sub_406ACF(\n          a1,\n          a2,\n          a3,\n          a4,\n          *(_DWORD *)v10,\n          *((_DWORD *)v10 + 1),\n          (__int64)(v10 + 1),\n          (char *)v10[5],\n          (char *)v10[6]);\n  *__errno_location() = v9;\n  return v11;\n}\n"], [4224954, "sub_4077BA", "__int64 __fastcall sub_4077BA(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_4077EC(a1, a2, 0LL, a3);\n}\n"], [4225004, "sub_4077EC", "__int64 __fastcall sub_4077EC(__int64 a1, size_t a2, _QWORD *a3, __int64 *a4)\n{\n  __int64 *v4; // rax\n  int v7; // [rsp+40h] [rbp-20h]\n  int v8; // [rsp+44h] [rbp-1Ch]\n  __int64 *v9; // [rsp+48h] [rbp-18h]\n  unsigned __int64 v10; // [rsp+50h] [rbp-10h]\n  __int64 v11; // [rsp+58h] [rbp-8h]\n\n  if ( a4 )\n    v4 = a4;\n  else\n    v4 = &qword_60E8A0;\n  v9 = v4;\n  v7 = *__errno_location();\n  v8 = *((_DWORD *)v9 + 1) | (a3 == 0LL);\n  v10 = sub_406ACF(0LL, 0LL, a1, a2, *(_DWORD *)v9, v8, (__int64)(v9 + 1), (char *)v9[5], (char *)v9[6]) + 1;\n  v11 = sub_408973(v10);\n  sub_406ACF(v11, v10, a1, a2, *(_DWORD *)v9, v8, (__int64)(v9 + 1), (char *)v9[5], (char *)v9[6]);\n  *__errno_location() = v7;\n  if ( a3 )\n    *a3 = v10 - 1;\n  return v11;\n}\n"], [4225304, "sub_407918", "void sub_407918()\n{\n  unsigned int i; // [rsp+4h] [rbp-Ch]\n  void **ptr; // [rsp+8h] [rbp-8h]\n\n  ptr = (void **)off_60E2C0;\n  for ( i = 1; i < dword_60E2A0; ++i )\n    free(ptr[2 * i + 1]);\n  if ( ptr[1] != &unk_60E8E0 )\n  {\n    free(ptr[1]);\n    qword_60E2B0 = 256LL;\n    off_60E2B8 = &unk_60E8E0;\n  }\n  if ( ptr != (void **)&qword_60E2B0 )\n  {\n    free(ptr);\n    off_60E2C0 = (__int64)&qword_60E2B0;\n  }\n  dword_60E2A0 = 1;\n}\n"], [4225475, "sub_4079C3", "void *__fastcall sub_4079C3(int a1, __int64 a2, size_t a3, __int64 a4)\n{\n  __int64 v4; // rax\n  void *v5; // rdx\n  bool v9; // [rsp+4Bh] [rbp-45h]\n  int v10; // [rsp+4Ch] [rbp-44h]\n  int v11; // [rsp+54h] [rbp-3Ch]\n  _QWORD *v12; // [rsp+58h] [rbp-38h]\n  void *ptr; // [rsp+60h] [rbp-30h]\n  __int64 v14; // [rsp+68h] [rbp-28h]\n  unsigned __int64 v15; // [rsp+70h] [rbp-20h]\n  unsigned __int64 v16; // [rsp+70h] [rbp-20h]\n  unsigned __int64 v17; // [rsp+78h] [rbp-18h]\n\n  v10 = *__errno_location();\n  v12 = (_QWORD *)off_60E2C0;\n  if ( a1 < 0 )\n    abort();\n  if ( dword_60E2A0 <= (unsigned int)a1 )\n  {\n    v14 = (unsigned int)(a1 + 1);\n    v9 = off_60E2C0 == (_QWORD)&qword_60E2B0;\n    if ( (__int64 *)off_60E2C0 == &qword_60E2B0 )\n      v4 = 0LL;\n    else\n      v4 = off_60E2C0;\n    v12 = (_QWORD *)sub_4089C2(v4, 16 * v14);\n    off_60E2C0 = (__int64)v12;\n    if ( v9 )\n    {\n      v5 = off_60E2B8;\n      *v12 = qword_60E2B0;\n      v12[1] = v5;\n    }\n    memset(&v12[2 * (unsigned int)dword_60E2A0], 0, 16 * (v14 - (unsigned int)dword_60E2A0));\n    dword_60E2A0 = a1 + 1;\n  }\n  v15 = v12[2 * a1];\n  ptr = (void *)v12[2 * a1 + 1];\n  v11 = *(_DWORD *)(a4 + 4) | 1;\n  v17 = sub_406ACF((__int64)ptr, v15, a2, a3, *(_DWORD *)a4, v11, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 48));\n  if ( v15 <= v17 )\n  {\n    v16 = v17 + 1;\n    v12[2 * a1] = v17 + 1;\n    if ( ptr != &unk_60E8E0 )\n      free(ptr);\n    ptr = (void *)sub_408973(v16);\n    v12[2 * a1 + 1] = ptr;\n    sub_406ACF((__int64)ptr, v16, a2, a3, *(_DWORD *)a4, v11, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 48));\n  }\n  *__errno_location() = v10;\n  return ptr;\n}\n"], [4226121, "sub_407C49", "void *__fastcall sub_407C49(int a1, __int64 a2)\n{\n  return sub_4079C3(a1, a2, 0xFFFFFFFFFFFFFFFFLL, (__int64)&qword_60E8A0);\n}\n"], [4226164, "sub_407C74", "void *__fastcall sub_407C74(int a1, __int64 a2, size_t a3)\n{\n  return sub_4079C3(a1, a2, a3, (__int64)&qword_60E8A0);\n}\n"], [4226208, "sub_407CA0", "void *__fastcall sub_407CA0(__int64 a1)\n{\n  return sub_407C49(0, a1);\n}\n"], [4226239, "sub_407CBF", "void *__fastcall sub_407CBF(__int64 a1, size_t a2)\n{\n  return sub_407C74(0, a1, a2);\n}\n"], [4226278, "sub_407CE6", "void *__fastcall sub_407CE6(int a1, int a2, __int64 a3)\n{\n  _QWORD v5[8]; // [rsp+10h] [rbp-40h] BYREF\n\n  sub_406A1A(v5, a2);\n  return sub_4079C3(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)v5);\n}\n"], [4226343, "sub_407D27", "void *__fastcall sub_407D27(int a1, int a2, __int64 a3, size_t a4)\n{\n  _QWORD v7[8]; // [rsp+20h] [rbp-40h] BYREF\n\n  sub_406A1A(v7, a2);\n  return sub_4079C3(a1, a3, a4, (__int64)v7);\n}\n"], [4226406, "sub_407D66", "void *__fastcall sub_407D66(int a1, __int64 a2)\n{\n  return sub_407CE6(0, a1, a2);\n}\n"], [4226442, "sub_407D8A", "void *__fastcall sub_407D8A(int a1, __int64 a2, size_t a3)\n{\n  return sub_407D27(0, a1, a2, a3);\n}\n"], [4226486, "sub_407DB6", "void *__fastcall sub_407DB6(__int64 a1, size_t a2, unsigned __int8 a3)\n{\n  __int64 v4[8]; // [rsp+20h] [rbp-40h] BYREF\n\n  v4[0] = qword_60E8A0;\n  v4[1] = qword_60E8A8;\n  v4[2] = qword_60E8B0;\n  v4[3] = qword_60E8B8;\n  v4[4] = qword_60E8C0;\n  v4[5] = qword_60E8C8;\n  v4[6] = qword_60E8D0;\n  sub_406905(v4, a3, 1);\n  return sub_4079C3(0, a1, a2, (__int64)v4);\n}\n"], [4226634, "sub_407E4A", "void *__fastcall sub_407E4A(__int64 a1, unsigned __int8 a2)\n{\n  return sub_407DB6(a1, 0xFFFFFFFFFFFFFFFFLL, a2);\n}\n"], [4226676, "sub_407E74", "void *__fastcall sub_407E74(__int64 a1)\n{\n  return sub_407E4A(a1, 0x3Au);\n}\n"], [4226707, "sub_407E93", "void *__fastcall sub_407E93(__int64 a1, size_t a2)\n{\n  return sub_407DB6(a1, a2, 0x3Au);\n}\n"], [4226749, "sub_407EBD", "__int64 __fastcall sub_407EBD(unsigned int a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  return sub_407EF3(a1, a2, a3, a4, -1LL);\n}\n"], [4226803, "sub_407EF3", "void *__fastcall sub_407EF3(int a1, __int64 a2, __int64 a3, __int64 a4, size_t a5)\n{\n  __int64 v8[8]; // [rsp+30h] [rbp-40h] BYREF\n\n  v8[0] = qword_60E8A0;\n  v8[1] = qword_60E8A8;\n  v8[2] = qword_60E8B0;\n  v8[3] = qword_60E8B8;\n  v8[4] = qword_60E8C0;\n  v8[5] = qword_60E8C8;\n  v8[6] = qword_60E8D0;\n  sub_4069C0(v8, a2, a3);\n  return sub_4079C3(a1, a4, a5, (__int64)v8);\n}\n"], [4226954, "sub_407F8A", "__int64 __fastcall sub_407F8A(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_407EBD(0, a1, a2, a3);\n}\n"], [4227001, "sub_407FB9", "void *__fastcall sub_407FB9(__int64 a1, __int64 a2, __int64 a3, size_t a4)\n{\n  return sub_407EF3(0, a1, a2, a3, a4);\n}\n"], [4227059, "sub_407FF3", "int __fastcall sub_407FF3(FILE *a1, const char *a2, const char *a3, const char *a4, __int64 *a5, unsigned __int64 a6)\n{\n  char *v6; // rax\n  char *v7; // rax\n  __int64 v8; // rbx\n  char *v9; // rax\n  __int64 v10; // r12\n  __int64 v11; // rbx\n  char *v12; // rax\n  __int64 v13; // r13\n  __int64 v14; // r12\n  __int64 v15; // rbx\n  char *v16; // rax\n  int result; // eax\n  __int64 v18; // r14\n  __int64 v19; // r13\n  __int64 v20; // r12\n  __int64 v21; // rbx\n  char *v22; // rax\n  __int64 v23; // r13\n  __int64 v24; // r15\n  __int64 v25; // r14\n  __int64 v26; // r12\n  __int64 v27; // rbx\n  char *v28; // rax\n  __int64 v29; // r14\n  __int64 v30; // r13\n  __int64 v31; // r15\n  __int64 v32; // r12\n  __int64 v33; // rbx\n  char *v34; // rax\n  __int64 v35; // r15\n  __int64 v36; // r14\n  __int64 v37; // r13\n  __int64 v38; // r12\n  __int64 v39; // rbx\n  char *v40; // rax\n  __int64 v41; // r15\n  __int64 v42; // r14\n  __int64 v43; // r13\n  __int64 v44; // r12\n  __int64 v45; // rbx\n  char *v46; // rax\n  __int64 v47; // r15\n  __int64 v48; // r14\n  __int64 v49; // r13\n  __int64 v50; // r12\n  __int64 v51; // rbx\n  char *v52; // rax\n  __int64 v53; // [rsp+30h] [rbp-80h]\n  __int64 v54; // [rsp+38h] [rbp-78h]\n  __int64 v55; // [rsp+38h] [rbp-78h]\n  __int64 v56; // [rsp+40h] [rbp-70h]\n  __int64 v57; // [rsp+40h] [rbp-70h]\n  __int64 v58; // [rsp+40h] [rbp-70h]\n  __int64 v59; // [rsp+48h] [rbp-68h]\n  __int64 v60; // [rsp+48h] [rbp-68h]\n  __int64 v61; // [rsp+48h] [rbp-68h]\n  __int64 v62; // [rsp+48h] [rbp-68h]\n\n  if ( a2 )\n    fprintf(a1, \"%s (%s) %s\\n\", a2, a3, a4);\n  else\n    fprintf(a1, \"%s %s\\n\", a3, a4);\n  v6 = gettext(\"(C)\");\n  fprintf(a1, \"Copyright %s %d Free Software Foundation, Inc.\", v6, 2011LL);\n  v7 = gettext(\n         \"\\n\"\n         \"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n         \"\\n\");\n  fputs_unlocked(v7, a1);\n  if ( a6 == 4 )\n  {\n    v18 = a5[3];\n    v19 = a5[2];\n    v20 = a5[1];\n    v21 = *a5;\n    v22 = gettext(\"Written by %s, %s, %s,\\nand %s.\\n\");\n    result = fprintf(a1, v22, v21, v20, v19, v18);\n  }\n  else if ( a6 > 4 )\n  {\n    if ( a6 == 7 )\n    {\n      v35 = a5[6];\n      v36 = a5[5];\n      v37 = a5[4];\n      v60 = a5[3];\n      v56 = a5[2];\n      v38 = a5[1];\n      v39 = *a5;\n      v40 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\");\n      result = fprintf(a1, v40, v39, v38, v56, v60, v37, v36, v35);\n    }\n    else if ( a6 > 7 )\n    {\n      if ( a6 == 8 )\n      {\n        v61 = a5[7];\n        v41 = a5[6];\n        v42 = a5[5];\n        v43 = a5[4];\n        v57 = a5[3];\n        v54 = a5[2];\n        v44 = a5[1];\n        v45 = *a5;\n        v46 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\");\n        result = fprintf(a1, v46, v45, v44, v54, v57, v43, v42, v41, v61);\n      }\n      else\n      {\n        v62 = a5[8];\n        v58 = a5[7];\n        v47 = a5[6];\n        v48 = a5[5];\n        v49 = a5[4];\n        v55 = a5[3];\n        v53 = a5[2];\n        v50 = a5[1];\n        v51 = *a5;\n        if ( a6 == 9 )\n          v52 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\");\n        else\n          v52 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\");\n        result = fprintf(a1, v52, v51, v50, v53, v55, v49, v48, v47, v58, v62);\n      }\n    }\n    else if ( a6 == 5 )\n    {\n      v23 = a5[4];\n      v24 = a5[3];\n      v25 = a5[2];\n      v26 = a5[1];\n      v27 = *a5;\n      v28 = gettext(\"Written by %s, %s, %s,\\n%s, and %s.\\n\");\n      result = fprintf(a1, v28, v27, v26, v25, v24, v23);\n    }\n    else\n    {\n      v29 = a5[5];\n      v30 = a5[4];\n      v59 = a5[3];\n      v31 = a5[2];\n      v32 = a5[1];\n      v33 = *a5;\n      v34 = gettext(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\");\n      result = fprintf(a1, v34, v33, v32, v31, v59, v30, v29);\n    }\n  }\n  else\n  {\n    switch ( a6 )\n    {\n      case 1uLL:\n        v8 = *a5;\n        v9 = gettext(\"Written by %s.\\n\");\n        result = fprintf(a1, v9, v8);\n        break;\n      case 0uLL:\n        abort();\n      case 2uLL:\n        v10 = a5[1];\n        v11 = *a5;\n        v12 = gettext(\"Written by %s and %s.\\n\");\n        result = fprintf(a1, v12, v11, v10);\n        break;\n      default:\n        v13 = a5[2];\n        v14 = a5[1];\n        v15 = *a5;\n        v16 = gettext(\"Written by %s, %s, and %s.\\n\");\n        result = fprintf(a1, v16, v15, v14, v13);\n        break;\n    }\n  }\n  return result;\n}\n"], [4228574, "sub_4085DE", "int __fastcall sub_4085DE(FILE *a1, const char *a2, const char *a3, const char *a4, __int64 *a5)\n{\n  unsigned __int64 i; // [rsp+38h] [rbp-8h]\n\n  for ( i = 0LL; a5[i]; ++i )\n    ;\n  return sub_407FF3(a1, a2, a3, a4, a5, i);\n}\n"], [4228684, "sub_40864C", "int __fastcall sub_40864C(FILE *a1, const char *a2, const char *a3, const char *a4, unsigned int *a5)\n{\n  __int64 *v5; // rax\n  unsigned __int64 i; // [rsp+38h] [rbp-58h]\n  __int64 v8[10]; // [rsp+40h] [rbp-50h] BYREF\n\n  for ( i = 0LL; i <= 9; ++i )\n  {\n    if ( *a5 >= 0x30 )\n    {\n      v5 = (__int64 *)*((_QWORD *)a5 + 1);\n      *((_QWORD *)a5 + 1) = v5 + 1;\n    }\n    else\n    {\n      v5 = (__int64 *)(*((_QWORD *)a5 + 2) + *a5);\n      *a5 += 8;\n    }\n    v8[i] = *v5;\n    if ( !v8[i] )\n      break;\n  }\n  return sub_407FF3(a1, a2, a3, a4, v8, i);\n}\n"], [4228901, "sub_408725", "int sub_408725(FILE *a1, const char *a2, const char *a3, const char *a4, ...)\n{\n  gcc_va_list va; // [rsp+28h] [rbp-C8h] BYREF\n\n  va_start(va, a4);\n  return sub_40864C(a1, a2, a3, a4, (unsigned int *)va);\n}\n"], [4229083, "sub_4087DB", "int sub_4087DB()\n{\n  char *v0; // rax\n  char *v1; // rax\n  FILE *v2; // rbx\n  char *v3; // rax\n\n  v0 = gettext(\"\\nReport bugs to: %s\\n\");\n  printf(v0, \"bug-coreutils@gnu.org\");\n  v1 = gettext(\"%s home page: <%s>\\n\");\n  printf(v1, \"GNU coreutils\", \"http://www.gnu.org/software/coreutils/\");\n  v2 = stdout;\n  v3 = gettext(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\");\n  return fputs_unlocked(v3, v2);\n}\n"], [4229188, "sub_408844", "__int64 __fastcall sub_408844(unsigned __int64 a1, unsigned __int64 a2)\n{\n  unsigned __int64 v2; // rdx\n\n  v2 = 0xFFFFFFFFFFFFFFFFLL % a2;\n  if ( 0xFFFFFFFFFFFFFFFFLL / a2 < a1 )\n    sub_408B0F(a1, a2, v2);\n  return sub_40898D(a2 * a1, a2, v2);\n}\n"], [4229250, "sub_408882", "__int64 __fastcall sub_408882(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)\n{\n  unsigned __int64 v3; // rax\n  unsigned __int64 v4; // rdx\n\n  v3 = 0xFFFFFFFFFFFFFFFFLL / a3;\n  v4 = 0xFFFFFFFFFFFFFFFFLL % a3;\n  if ( v3 < a2 )\n    sub_408B0F(a1, a2, v4);\n  return sub_4089C2(a1, a3 * a2);\n}\n"], [4229326, "sub_4088CE", "__int64 __fastcall sub_4088CE(__int64 a1, unsigned __int64 *a2, unsigned __int64 a3)\n{\n  unsigned __int64 v3; // rdx\n  unsigned __int64 v6; // [rsp+28h] [rbp-8h]\n\n  v6 = *a2;\n  if ( a1 )\n  {\n    v3 = 0xAAAAAAAAAAAAAAAALL % a3;\n    if ( 0xAAAAAAAAAAAAAAAALL / a3 <= v6 )\n      sub_408B0F(a1, a2, v3);\n    v6 += (v6 + 1) >> 1;\n  }\n  else if ( !v6 )\n  {\n    v6 = (0x80 / a3 == 0) + 0x80 / a3;\n  }\n  *a2 = v6;\n  return sub_4089C2(a1, a3 * v6);\n}\n"], [4229491, "sub_408973", "__int64 __fastcall sub_408973(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_40898D(a1, a2, a3);\n}\n"], [4229517, "sub_40898D", "void *__fastcall sub_40898D(size_t a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  void *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = malloc(a1);\n  if ( !v4 && a1 )\n    sub_408B0F(a1, a2, v2);\n  return v4;\n}\n"], [4229570, "sub_4089C2", "void *__fastcall sub_4089C2(void *a1, size_t a2)\n{\n  void *result; // rax\n  __int64 v3; // rdx\n  void *ptr; // [rsp+8h] [rbp-8h]\n\n  if ( a2 || !a1 )\n  {\n    ptr = realloc(a1, a2);\n    if ( !ptr )\n    {\n      if ( a2 )\n        sub_408B0F(a1, a2, v3);\n    }\n    result = ptr;\n  }\n  else\n  {\n    free(a1);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4229667, "sub_408A23", "__int64 __fastcall sub_408A23(__int64 a1, unsigned __int64 *a2)\n{\n  return sub_4088CE(a1, a2, 1uLL);\n}\n"], [4229709, "sub_408A4D", "void *__fastcall sub_408A4D(size_t a1, __int64 a2)\n{\n  void *v2; // rax\n\n  v2 = sub_40898D(a1, a2);\n  return memset(v2, 0, a1);\n}\n"], [4229752, "sub_408A78", "void *__fastcall sub_408A78(size_t a1, size_t a2)\n{\n  __int64 v2; // rdx\n  void *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = calloc(a1, a2);\n  if ( !v4 )\n    sub_408B0F(a1, a2, v2);\n  return v4;\n}\n"], [4229809, "sub_408AB1", "void *__fastcall sub_408AB1(const void *a1, size_t a2)\n{\n  void *v2; // rax\n\n  v2 = sub_40898D(a2, a2);\n  return memcpy(v2, a1, a2);\n}\n"], [4229858, "sub_408AE2", "void *__fastcall sub_408AE2(const char *a1)\n{\n  size_t v1; // rax\n\n  v1 = strlen(a1);\n  return sub_408AB1(a1, v1 + 1);\n}\n"], [4229903, "sub_408B0F", "void __noreturn sub_408B0F()\n{\n  char *v0; // rax\n\n  v0 = gettext(\"memory exhausted\");\n  error(status, 0, \"%s\", v0);\n  abort();\n}\n"], [4229956, "sub_408B44", "__int64 __fastcall sub_408B44(unsigned __int64 *a1, int a2)\n{\n  __int64 result; // rax\n\n  if ( 0xFFFFFFFFFFFFFFFFLL / a2 >= *a1 )\n  {\n    *a1 *= a2;\n    result = 0LL;\n  }\n  else\n  {\n    *a1 = -1LL;\n    result = 1LL;\n  }\n  return result;\n}\n"], [4230051, "sub_408BA3", "__int64 __fastcall sub_408BA3(unsigned __int64 *a1, int a2, int a3)\n{\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; a3--; i |= sub_408B44(a1, a2) )\n    ;\n  return i;\n}\n"], [4230116, "sub_408BE4", "__int64 __fastcall sub_408BE4(const char *a1, char **a2, int a3, uintmax_t *a4, const char *a5)\n{\n  char **v5; // rax\n  int v7; // eax\n  int v8; // eax\n  unsigned __int8 i; // [rsp+3Fh] [rbp-31h]\n  unsigned int v13; // [rsp+40h] [rbp-30h]\n  int v14; // [rsp+44h] [rbp-2Ch]\n  int v15; // [rsp+48h] [rbp-28h]\n  int v16; // [rsp+4Ch] [rbp-24h]\n  char v17; // [rsp+50h] [rbp-20h] BYREF\n  uintmax_t v18; // [rsp+58h] [rbp-18h] BYREF\n  unsigned __int8 *v19; // [rsp+60h] [rbp-10h]\n  char **endptr; // [rsp+68h] [rbp-8h]\n\n  v13 = 0;\n  if ( a3 < 0 || a3 > 36 )\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\", \"../../src/lib/xstrtol.c\", 0x53u, \"xstrtoumax\");\n  if ( a2 )\n    v5 = a2;\n  else\n    v5 = (char **)&v17;\n  endptr = v5;\n  v19 = (unsigned __int8 *)a1;\n  for ( i = *a1; ((*__ctype_b_loc())[i] & 0x2000) != 0; i = *v19 )\n    ++v19;\n  if ( i == 45 )\n    return 4LL;\n  *__errno_location() = 0;\n  v18 = strtoumax(a1, endptr, a3);\n  if ( *endptr == a1 )\n  {\n    if ( !a5 || !**endptr || !strchr(a5, **endptr) )\n      return 4LL;\n    v18 = 1LL;\n  }\n  else if ( *__errno_location() )\n  {\n    if ( *__errno_location() != 34 )\n      return 4LL;\n    v13 = 1;\n  }\n  if ( !a5 )\n  {\n    *a4 = v18;\n    return v13;\n  }\n  if ( !**endptr )\n    goto LABEL_76;\n  v14 = 1024;\n  v15 = 1;\n  if ( !strchr(a5, **endptr) )\n  {\n    *a4 = v18;\n    return v13 | 2;\n  }\n  if ( strchr(a5, 48) )\n  {\n    v7 = (*endptr)[1];\n    if ( v7 == 68 )\n      goto LABEL_35;\n    if ( v7 != 105 )\n    {\n      if ( v7 != 66 )\n        goto LABEL_36;\nLABEL_35:\n      v14 = 1000;\n      v15 = 2;\n      goto LABEL_36;\n    }\n    if ( (*endptr)[2] == 66 )\n      v15 = 3;\n  }\nLABEL_36:\n  v8 = **endptr;\n  if ( v8 != 89 )\n  {\n    if ( v8 > 89 )\n    {\n      if ( v8 == 103 )\n      {\nLABEL_65:\n        v16 = sub_408BA3(&v18, v14, 3);\n        goto LABEL_74;\n      }\n      if ( v8 <= 103 )\n      {\n        switch ( v8 )\n        {\n          case 'b':\n            v16 = sub_408B44(&v18, 512);\n            break;\n          case 'c':\n            v16 = 0;\n            break;\n          case 'Z':\n            v16 = sub_408BA3(&v18, v14, 7);\n            break;\n          default:\n            goto LABEL_73;\n        }\n        goto LABEL_74;\n      }\n      if ( v8 == 109 )\n        goto LABEL_67;\n      if ( v8 > 109 )\n      {\n        if ( v8 != 116 )\n        {\n          if ( v8 != 119 )\n            goto LABEL_73;\n          v16 = sub_408B44(&v18, 2);\n          goto LABEL_74;\n        }\nLABEL_69:\n        v16 = sub_408BA3(&v18, v14, 4);\n        goto LABEL_74;\n      }\n      if ( v8 != 107 )\n        goto LABEL_73;\n    }\n    else if ( v8 != 75 )\n    {\n      if ( v8 <= 75 )\n      {\n        if ( v8 == 69 )\n        {\n          v16 = sub_408BA3(&v18, v14, 6);\n          goto LABEL_74;\n        }\n        if ( v8 != 71 )\n        {\n          if ( v8 != 66 )\n          {\nLABEL_73:\n            *a4 = v18;\n            return v13 | 2;\n          }\n          v16 = sub_408B44(&v18, 1024);\n          goto LABEL_74;\n        }\n        goto LABEL_65;\n      }\n      if ( v8 == 80 )\n      {\n        v16 = sub_408BA3(&v18, v14, 5);\n        goto LABEL_74;\n      }\n      if ( v8 != 84 )\n      {\n        if ( v8 != 77 )\n          goto LABEL_73;\nLABEL_67:\n        v16 = sub_408BA3(&v18, v14, 2);\n        goto LABEL_74;\n      }\n      goto LABEL_69;\n    }\n    v16 = sub_408BA3(&v18, v14, 1);\n    goto LABEL_74;\n  }\n  v16 = sub_408BA3(&v18, v14, 8);\nLABEL_74:\n  v13 |= v16;\n  *endptr += v15;\n  if ( **endptr )\n    v13 |= 2u;\nLABEL_76:\n  *a4 = v18;\n  return v13;\n}\n"], [4231248, "sub_409050", "int __fastcall sub_409050(FILE *a1)\n{\n  int v2; // eax\n  int v3; // [rsp+14h] [rbp-Ch]\n  int v4; // [rsp+18h] [rbp-8h]\n\n  v3 = 0;\n  if ( fileno(a1) < 0 )\n    return fclose(a1);\n  if ( !__freading(a1) || (v2 = fileno(a1), lseek(v2, 0LL, 1) != -1) )\n  {\n    if ( (unsigned int)sub_4093F2(a1) )\n      v3 = *__errno_location();\n  }\n  v4 = fclose(a1);\n  if ( v3 )\n  {\n    *__errno_location() = v3;\n    v4 = -1;\n  }\n  return v4;\n}\n"], [4231429, "sub_409105", "__int64 __fastcall sub_409105(int a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __m128 a7, __m128 a8, __m128 a9, __m128 a10, __m128 a11, __m128 a12, __m128 a13, __m128 a14)\n{\n  int v14; // ecx\n  int v15; // er8\n  int v16; // er9\n  int v18; // [rsp+10h] [rbp-E0h]\n  int v19; // [rsp+14h] [rbp-DCh]\n  int v20; // [rsp+18h] [rbp-D8h]\n  int v21; // [rsp+1Ch] [rbp-D4h]\n  __int64 v22; // [rsp+50h] [rbp-A0h]\n  __int64 v23; // [rsp+58h] [rbp-98h]\n  __int64 v24; // [rsp+60h] [rbp-90h]\n  __int64 v25; // [rsp+68h] [rbp-88h]\n  __m128 v26; // [rsp+70h] [rbp-80h]\n  __m128 v27; // [rsp+80h] [rbp-70h]\n  __m128 v28; // [rsp+90h] [rbp-60h]\n  __m128 v29; // [rsp+A0h] [rbp-50h]\n  __m128 v30; // [rsp+B0h] [rbp-40h]\n  __m128 v31; // [rsp+C0h] [rbp-30h]\n  __m128 v32; // [rsp+D0h] [rbp-20h]\n  __m128 v33; // [rsp+E0h] [rbp-10h]\n\n  v22 = a3;\n  v23 = a4;\n  v24 = a5;\n  v25 = a6;\n  v26 = a7;\n  v27 = a8;\n  v28 = a9;\n  v29 = a10;\n  v30 = a11;\n  v31 = a12;\n  v32 = a13;\n  v33 = a14;\n  if ( a2 != 1030 )\n    return (unsigned int)fcntl(a1, a2, v22);\n  v19 = v22;\n  if ( dword_60E9E0 < 0 )\n  {\n    v18 = sub_409105(a1, 0, v22, a4, a5, a6);\n  }\n  else\n  {\n    v18 = fcntl(a1, 1030, (unsigned int)v22);\n    if ( v18 < 0 && *__errno_location() == 22 )\n    {\n      v18 = sub_409105(a1, 0, v19, v14, v15, v16);\n      if ( v18 < 0 )\n        return (unsigned int)v18;\n      dword_60E9E0 = -1;\n    }\n    else\n    {\n      dword_60E9E0 = 1;\n    }\n  }\n  if ( v18 >= 0 && dword_60E9E0 == -1 )\n  {\n    v20 = fcntl(v18, 1);\n    if ( v20 < 0 || fcntl(v18, 2, v20 | 1u) == -1 )\n    {\n      v21 = *__errno_location();\n      close(v18);\n      *__errno_location() = v21;\n      v18 = -1;\n    }\n  }\n  return (unsigned int)v18;\n}\n"], [4232127, "sub_4093BF", "__int64 __fastcall sub_4093BF(_DWORD *a1)\n{\n  __int64 result; // rax\n\n  result = *a1 & 0x100;\n  if ( (_DWORD)result )\n    result = sub_40943D(a1, 0LL, 1LL);\n  return result;\n}\n"], [4232178, "sub_4093F2", "int __fastcall sub_4093F2(FILE *a1)\n{\n  if ( !a1 || !__freading(a1) )\n    return fflush(a1);\n  sub_4093BF(a1);\n  return fflush(a1);\n}\n"], [4232253, "sub_40943D", "int __fastcall sub_40943D(FILE *a1, __off_t a2, int a3)\n{\n  int v3; // eax\n  __off_t v6; // [rsp+28h] [rbp-8h]\n\n  if ( a1->_IO_read_end != a1->_IO_read_ptr || a1->_IO_write_ptr != a1->_IO_write_base || a1->_IO_save_base )\n    return fseeko(a1, a2, a3);\n  v3 = fileno(a1);\n  v6 = lseek(v3, a2, a3);\n  if ( v6 == -1 )\n    return -1;\n  a1->_flags &= 0xFFFFFFEF;\n  a1->_offset = v6;\n  return 0;\n}\n"], [4232437, "sub_4094F5", "__int64 __fastcall sub_4094F5(__int64 a1, __int64 a2)\n{\n  return 1000000000 * a1 + a2;\n}\n"], [4232469, "sub_409515", "__int64 sub_409515()\n{\n  struct timespec tp; // [rsp+0h] [rbp-10h] BYREF\n\n  if ( clock_gettime(1, &tp) )\n    sub_4099ED(&tp);\n  return sub_4094F5(tp.tv_sec, tp.tv_nsec);\n}\n"], [4232552, "sub_409568", "__int64 __fastcall sub_409568(int a1, const char *a2, int a3, unsigned int a4)\n{\n  int fd; // [rsp+24h] [rbp-Ch]\n  unsigned int v6; // [rsp+28h] [rbp-8h]\n  int v7; // [rsp+2Ch] [rbp-4h]\n\n  fd = open(a2, a3, a4);\n  if ( fd == a1 || fd < 0 )\n    return (unsigned int)fd;\n  v6 = dup2(fd, a1);\n  v7 = *__errno_location();\n  close(fd);\n  *__errno_location() = v7;\n  return v6;\n}\n"], [4232673, "sub_4095E1", "void __noreturn sub_4095E1()\n{\n  sub_401D9F(1);\n}\n"], [4232689, "sub_4095F1", "__int64 __fastcall sub_4095F1(const char *a1, __int64 a2, __int64 a3, size_t a4)\n{\n  __int64 result; // rax\n  char v7; // [rsp+27h] [rbp-19h]\n  __int64 i; // [rsp+28h] [rbp-18h]\n  __int64 v9; // [rsp+30h] [rbp-10h]\n  size_t n; // [rsp+38h] [rbp-8h]\n\n  v9 = -1LL;\n  v7 = 0;\n  n = strlen(a1);\n  for ( i = 0LL; *(_QWORD *)(8 * i + a2); ++i )\n  {\n    if ( !strncmp(*(const char **)(8 * i + a2), a1, n) )\n    {\n      if ( strlen(*(const char **)(8 * i + a2)) == n )\n        return i;\n      if ( v9 == -1 )\n      {\n        v9 = i;\n      }\n      else if ( !a3 || memcmp((const void *)(a4 * v9 + a3), (const void *)(i * a4 + a3), a4) )\n      {\n        v7 = 1;\n      }\n    }\n  }\n  if ( v7 )\n    result = -2LL;\n  else\n    result = v9;\n  return result;\n}\n"], [4232992, "sub_409720", "void __fastcall sub_409720(__int64 a1, __int64 a2, __int64 a3)\n{\n  char *v3; // rax\n  __int64 v4; // rbx\n  void *v5; // rax\n  char *format; // [rsp+28h] [rbp-18h]\n\n  if ( a3 == -1 )\n    v3 = gettext(\"invalid argument %s for %s\");\n  else\n    v3 = gettext(\"ambiguous argument %s for %s\");\n  format = v3;\n  v4 = sub_406837(1u, a1);\n  v5 = sub_407CE6(0, 6, a2);\n  error(0, 0, format, v5, v4);\n}\n"], [4233131, "sub_4097AB", "int __fastcall sub_4097AB(__int64 a1, __int64 a2, size_t a3)\n{\n  char *v3; // rax\n  __int64 i; // [rsp+20h] [rbp-10h]\n  void *s1; // [rsp+28h] [rbp-8h]\n\n  s1 = 0LL;\n  v3 = gettext(\"Valid arguments are:\");\n  fprintf(stderr, v3);\n  for ( i = 0LL; *(_QWORD *)(8 * i + a1); ++i )\n  {\n    if ( i && !memcmp(s1, (const void *)(i * a3 + a2), a3) )\n    {\n      fprintf(stderr, \", `%s'\", *(const char **)(8 * i + a1));\n    }\n    else\n    {\n      fprintf(stderr, \"\\n  - `%s'\", *(const char **)(8 * i + a1));\n      s1 = (void *)(i * a3 + a2);\n    }\n  }\n  return putc_unlocked(10, stderr);\n}\n"], [4233435, "sub_4098DB", "__int64 __fastcall sub_4098DB(__int64 a1, const char *a2, __int64 a3, __int64 a4, size_t a5, void (*a6)(void))\n{\n  __int64 v11; // [rsp+38h] [rbp-8h]\n\n  v11 = sub_4095F1(a2, a3, a4, a5);\n  if ( v11 >= 0 )\n    return v11;\n  sub_409720(a1, (__int64)a2, v11);\n  sub_4097AB(a3, a4, a5);\n  a6();\n  return -1LL;\n}\n"], [4233569, "sub_409961", "__int64 __fastcall sub_409961(const void *a1, __int64 a2, __int64 a3, size_t a4)\n{\n  __int64 i; // [rsp+28h] [rbp-8h]\n\n  for ( i = 0LL; *(_QWORD *)(8 * i + a2); ++i )\n  {\n    if ( !memcmp(a1, (const void *)(i * a4 + a3), a4) )\n      return *(_QWORD *)(8 * i + a2);\n  }\n  return 0LL;\n}\n"], [4233709, "sub_4099ED", "int __fastcall sub_4099ED(struct timespec *a1)\n{\n  int result; // eax\n  struct timeval tv; // [rsp+10h] [rbp-10h] BYREF\n\n  result = clock_gettime(0, a1);\n  if ( result )\n  {\n    gettimeofday(&tv, 0LL);\n    a1->tv_sec = tv.tv_sec;\n    result = (int)a1;\n    a1->tv_nsec = 1000 * tv.tv_usec;\n  }\n  return result;\n}\n"], [4233808, "init", "void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)\n{\n  __int64 v4; // rbx\n  signed __int64 v5; // rbp\n\n  v4 = 0LL;\n  v5 = &off_60DE18 - off_60DE10;\n  init_proc();\n  if ( v5 )\n  {\n    do\n      ((void (__fastcall *)(_QWORD, __int64, __int64))off_60DE10[v4++])(a1, a2, a3);\n    while ( v4 != v5 );\n  }\n}\n"], [4233920, "fini", "void fini(void)\n{\n  ;\n}\n"], [4233936, "sub_409AD0", "int __fastcall sub_409AD0(void (__fastcall *a1)(void *))\n{\n  void *v1; // rdx\n\n  if ( &qword_60E268 )\n    v1 = (void *)qword_60E268;\n  else\n    v1 = 0LL;\n  return __cxa_atexit(a1, 0LL, v1);\n}\n"], [4233968, "sub_409AF0", "int __fastcall sub_409AF0(int fildes, struct stat *stat_buf)\n{\n  return __fxstat(1, fildes, stat_buf);\n}\n"], [4233984, ".term_proc", "void term_proc()\n{\n  ;\n}\n"]]