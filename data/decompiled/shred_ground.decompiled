[[4200128, ".init_proc", "void *init_proc()\n{\n  void *result; // rax\n\n  result = &_gmon_start__;\n  if ( &_gmon_start__ )\n    result = (void *)__gmon_start__();\n  return result;\n}\n"], [4200160, "sub_4016E0", "__int64 sub_4016E0()\n{\n  return qword_60D010();\n}\n"], [4200176, ".getenv", "// attributes: thunk\nchar *getenv(const char *name)\n{\n  return getenv(name);\n}\n"], [4200192, ".free", "// attributes: thunk\nvoid free(void *ptr)\n{\n  free(ptr);\n}\n"], [4200208, ".abort", "// attributes: thunk\nvoid __noreturn abort(void)\n{\n  abort();\n}\n"], [4200224, ".__errno_location", "// attributes: thunk\nint *__errno_location(void)\n{\n  return _errno_location();\n}\n"], [4200240, ".fdatasync", "// attributes: thunk\nint fdatasync(int fildes)\n{\n  return fdatasync(fildes);\n}\n"], [4200256, ".unlink", "// attributes: thunk\nint unlink(const char *name)\n{\n  return unlink(name);\n}\n"], [4200272, ".strncmp", "// attributes: thunk\nint strncmp(const char *s1, const char *s2, size_t n)\n{\n  return strncmp(s1, s2, n);\n}\n"], [4200288, "._exit", "// attributes: thunk\nvoid __noreturn _exit(int status)\n{\n  exit(status);\n}\n"], [4200304, ".strcpy", "// attributes: thunk\nchar *strcpy(char *dest, const char *src)\n{\n  return strcpy(dest, src);\n}\n"], [4200320, ".__fpending", "// attributes: thunk\nsize_t __fpending(FILE *fp)\n{\n  return _fpending(fp);\n}\n"], [4200336, ".isatty", "// attributes: thunk\nint isatty(int fd)\n{\n  return isatty(fd);\n}\n"], [4200352, ".localeconv", "// attributes: thunk\nstruct lconv *localeconv(void)\n{\n  return localeconv();\n}\n"], [4200368, ".fcntl", "// attributes: thunk\nint fcntl(int fd, int cmd, ...)\n{\n  return fcntl(fd, cmd);\n}\n"], [4200384, ".write", "// attributes: thunk\nssize_t write(int fd, const void *buf, size_t n)\n{\n  return write(fd, buf, n);\n}\n"], [4200400, ".getpid", "// attributes: thunk\n__pid_t getpid(void)\n{\n  return getpid();\n}\n"], [4200416, ".fread_unlocked", "// attributes: thunk\nsize_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream)\n{\n  return fread_unlocked(ptr, size, n, stream);\n}\n"], [4200432, ".textdomain", "// attributes: thunk\nchar *textdomain(const char *domainname)\n{\n  return textdomain(domainname);\n}\n"], [4200448, ".fclose", "// attributes: thunk\nint fclose(FILE *stream)\n{\n  return fclose(stream);\n}\n"], [4200464, ".bindtextdomain", "// attributes: thunk\nchar *bindtextdomain(const char *domainname, const char *dirname)\n{\n  return bindtextdomain(domainname, dirname);\n}\n"], [4200480, ".__ctype_get_mb_cur_max", "// attributes: thunk\nsize_t __ctype_get_mb_cur_max(void)\n{\n  return _ctype_get_mb_cur_max();\n}\n"], [4200496, ".strlen", "// attributes: thunk\nsize_t strlen(const char *s)\n{\n  return strlen(s);\n}\n"], [4200512, ".__lxstat", "// attributes: thunk\nint __lxstat(int ver, const char *filename, struct stat *stat_buf)\n{\n  return _lxstat(ver, filename, stat_buf);\n}\n"], [4200528, ".__stack_chk_fail", "// attributes: thunk\nvoid __noreturn __stack_chk_fail()\n{\n  _stack_chk_fail();\n}\n"], [4200544, ".getuid", "// attributes: thunk\n__uid_t getuid(void)\n{\n  return getuid();\n}\n"], [4200560, ".getopt_long", "// attributes: thunk\nint getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind)\n{\n  return getopt_long(argc, argv, shortopts, longopts, longind);\n}\n"], [4200576, ".mbrtowc", "// attributes: thunk\nsize_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p)\n{\n  return mbrtowc(pwc, s, n, p);\n}\n"], [4200592, ".gettext", "// attributes: thunk\nchar *gettext(const char *msgid)\n{\n  return gettext(msgid);\n}\n"], [4200608, ".strchr", "// attributes: thunk\nchar *strchr(const char *s, int c)\n{\n  return strchr(s, c);\n}\n"], [4200624, ".printf", "// attributes: thunk\nint printf(const char *format, ...)\n{\n  return printf(format);\n}\n"], [4200640, ".strrchr", "// attributes: thunk\nchar *strrchr(const char *s, int c)\n{\n  return strrchr(s, c);\n}\n"], [4200656, ".ftruncate", "// attributes: thunk\nint ftruncate(int fd, __off_t length)\n{\n  return ftruncate(fd, length);\n}\n"], [4200672, ".lseek", "// attributes: thunk\n__off_t lseek(int fd, __off_t offset, int whence)\n{\n  return lseek(fd, offset, whence);\n}\n"], [4200688, ".gettimeofday", "// attributes: thunk\nint gettimeofday(struct timeval *tv, __timezone_ptr_t tz)\n{\n  return gettimeofday(tv, tz);\n}\n"], [4200704, ".__assert_fail", "// attributes: thunk\nvoid __noreturn __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function)\n{\n  _assert_fail(assertion, file, line, function);\n}\n"], [4200720, ".memset", "// attributes: thunk\nvoid *memset(void *s, int c, size_t n)\n{\n  return memset(s, c, n);\n}\n"], [4200736, ".close", "// attributes: thunk\nint close(int fd)\n{\n  return close(fd);\n}\n"], [4200752, ".read", "// attributes: thunk\nssize_t read(int fd, void *buf, size_t nbytes)\n{\n  return read(fd, buf, nbytes);\n}\n"], [4200768, ".__libc_start_main", "// attributes: thunk\nint __fastcall __libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end)\n{\n  return _libc_start_main(main, argc, ubp_av, init, fini, rtld_fini, stack_end);\n}\n"], [4200784, ".memcmp", "// attributes: thunk\nint memcmp(const void *s1, const void *s2, size_t n)\n{\n  return memcmp(s1, s2, n);\n}\n"], [4200800, ".fputs_unlocked", "// attributes: thunk\nint fputs_unlocked(const char *s, FILE *stream)\n{\n  return fputs_unlocked(s, stream);\n}\n"], [4200816, ".ferror_unlocked", "// attributes: thunk\nint ferror_unlocked(FILE *stream)\n{\n  return ferror_unlocked(stream);\n}\n"], [4200832, ".calloc", "// attributes: thunk\nvoid *calloc(size_t nmemb, size_t size)\n{\n  return calloc(nmemb, size);\n}\n"], [4200848, ".strcmp", "// attributes: thunk\nint strcmp(const char *s1, const char *s2)\n{\n  return strcmp(s1, s2);\n}\n"], [4200864, ".fprintf", "// attributes: thunk\nint fprintf(FILE *stream, const char *format, ...)\n{\n  return fprintf(stream, format);\n}\n"], [4200880, ".__gmon_start__", "// attributes: thunk\n__int64 __gmon_start__(void)\n{\n  return _gmon_start__();\n}\n"], [4200896, ".memcpy", "// attributes: thunk\nvoid *memcpy(void *dest, const void *src, size_t n)\n{\n  return memcpy(dest, src, n);\n}\n"], [4200912, ".time", "// attributes: thunk\ntime_t time(time_t *timer)\n{\n  return time(timer);\n}\n"], [4200928, ".fileno", "// attributes: thunk\nint fileno(FILE *stream)\n{\n  return fileno(stream);\n}\n"], [4200944, ".getgid", "// attributes: thunk\n__gid_t getgid(void)\n{\n  return getgid();\n}\n"], [4200960, ".sync", "// attributes: thunk\nvoid sync(void)\n{\n  sync();\n}\n"], [4200976, ".putc_unlocked", "// attributes: thunk\nint putc_unlocked(int c, FILE *stream)\n{\n  return putc_unlocked(c, stream);\n}\n"], [4200992, ".malloc", "// attributes: thunk\nvoid *malloc(size_t size)\n{\n  return malloc(size);\n}\n"], [4201008, ".fflush", "// attributes: thunk\nint fflush(FILE *stream)\n{\n  return fflush(stream);\n}\n"], [4201024, ".__fxstat", "// attributes: thunk\nint __fxstat(int ver, int fildes, struct stat *stat_buf)\n{\n  return _fxstat(ver, fildes, stat_buf);\n}\n"], [4201040, ".__freading", "// attributes: thunk\nint __freading(FILE *fp)\n{\n  return _freading(fp);\n}\n"], [4201056, ".realloc", "// attributes: thunk\nvoid *realloc(void *ptr, size_t size)\n{\n  return realloc(ptr, size);\n}\n"], [4201072, ".fdopen", "// attributes: thunk\nFILE *fdopen(int fd, const char *modes)\n{\n  return fdopen(fd, modes);\n}\n"], [4201088, ".setlocale", "// attributes: thunk\nchar *setlocale(int category, const char *locale)\n{\n  return setlocale(category, locale);\n}\n"], [4201104, ".setvbuf", "// attributes: thunk\nint setvbuf(FILE *stream, char *buf, int modes, size_t n)\n{\n  return setvbuf(stream, buf, modes, n);\n}\n"], [4201120, ".chmod", "// attributes: thunk\nint chmod(const char *file, __mode_t mode)\n{\n  return chmod(file, mode);\n}\n"], [4201136, ".memmove", "// attributes: thunk\nvoid *memmove(void *dest, const void *src, size_t n)\n{\n  return memmove(dest, src, n);\n}\n"], [4201152, ".error", "// attributes: thunk\nvoid error(int status, int errnum, const char *format, ...)\n{\n  error(status, errnum, format);\n}\n"], [4201168, ".fsync", "// attributes: thunk\nint fsync(int fd)\n{\n  return fsync(fd);\n}\n"], [4201184, ".open", "// attributes: thunk\nint open(const char *file, int oflag, ...)\n{\n  return open(file, oflag);\n}\n"], [4201200, ".fseeko", "// attributes: thunk\nint fseeko(FILE *stream, __off_t off, int whence)\n{\n  return fseeko(stream, off, whence);\n}\n"], [4201216, ".fopen", "// attributes: thunk\nFILE *fopen(const char *filename, const char *modes)\n{\n  return fopen(filename, modes);\n}\n"], [4201232, ".rename", "// attributes: thunk\nint rename(const char *old, const char *a2)\n{\n  return rename(old, a2);\n}\n"], [4201248, ".strtoumax", "// attributes: thunk\nuintmax_t strtoumax(const char *nptr, char **endptr, int base)\n{\n  return strtoumax(nptr, endptr, base);\n}\n"], [4201264, ".__cxa_atexit", "// attributes: thunk\nint __fastcall __cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle)\n{\n  return _cxa_atexit(lpfunc, obj, lpdso_handle);\n}\n"], [4201280, ".sprintf", "// attributes: thunk\nint sprintf(char *s, const char *format, ...)\n{\n  return sprintf(s, format);\n}\n"], [4201296, ".getppid", "// attributes: thunk\n__pid_t getppid(void)\n{\n  return getppid();\n}\n"], [4201312, ".exit", "// attributes: thunk\nvoid __noreturn exit(int status)\n{\n  exit(status);\n}\n"], [4201328, ".fwrite", "// attributes: thunk\nsize_t fwrite(const void *ptr, size_t size, size_t n, FILE *s)\n{\n  return fwrite(ptr, size, n, s);\n}\n"], [4201344, ".mbsinit", "// attributes: thunk\nint mbsinit(const mbstate_t *ps)\n{\n  return mbsinit(ps);\n}\n"], [4201360, ".iswprint", "// attributes: thunk\nint iswprint(wint_t wc)\n{\n  return iswprint(wc);\n}\n"], [4201376, ".__ctype_b_loc", "// attributes: thunk\nconst unsigned __int16 **__ctype_b_loc(void)\n{\n  return _ctype_b_loc();\n}\n"], [4201392, "start", "// positive sp value has been detected, the output may be wrong!\nvoid __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))\n{\n  __int64 v3; // rax\n  int v4; // esi\n  __int64 v5; // [rsp-8h] [rbp-8h] BYREF\n  char *retaddr; // [rsp+0h] [rbp+0h] BYREF\n\n  v4 = v5;\n  v5 = v3;\n  __libc_start_main(main, v4, &retaddr, init, fini, a3, &v5);\n  __halt();\n}\n"], [4201440, "sub_401BE0", "signed __int64 sub_401BE0()\n{\n  signed __int64 result; // rax\n\n  result = &unk_60D2D7 - &unk_60D2D0;\n  if ( (unsigned __int64)(&unk_60D2D7 - &unk_60D2D0) > 0xE )\n    result = 0LL;\n  return result;\n}\n"], [4201488, "sub_401C10", "__int64 sub_401C10()\n{\n  return 0LL;\n}\n"], [4201552, "sub_401C50", "signed __int64 sub_401C50()\n{\n  signed __int64 result; // rax\n\n  if ( !byte_60D338 )\n  {\n    result = sub_401BE0();\n    byte_60D338 = 1;\n  }\n  return result;\n}\n"], [4201584, "sub_401C70", "__int64 sub_401C70()\n{\n  return sub_401C10();\n}\n"], [4201629, "sub_401C9D", "int sub_401C9D()\n{\n  __int64 v0; // rbx\n  char *v1; // rax\n  char *v2; // rax\n  FILE *v3; // rbx\n  char *v4; // rax\n  __int64 v5; // rbx\n  char *v6; // rax\n  __int64 v7; // rbx\n  char *v8; // rax\n  const char *s1; // [rsp+8h] [rbp-18h]\n\n  v0 = sub_404082(qword_60D358);\n  v1 = gettext(\"\\nReport %s bugs to %s\\n\");\n  printf(v1, v0, \"bug-coreutils@gnu.org\");\n  v2 = gettext(\"%s home page: <%s>\\n\");\n  printf(v2, \"GNU coreutils\", \"http://www.gnu.org/software/coreutils/\");\n  v3 = stdout;\n  v4 = gettext(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\");\n  fputs_unlocked(v4, v3);\n  s1 = setlocale(5, 0LL);\n  if ( s1 && strncmp(s1, \"en_\", 3uLL) )\n  {\n    v5 = sub_404082(qword_60D358);\n    v6 = gettext(\"Report %s translation bugs to <http://translationproject.org/team/>\\n\");\n    printf(v6, v5);\n  }\n  v7 = sub_404082(qword_60D358);\n  v8 = gettext(\"For complete documentation, run: info coreutils '%s invocation'\\n\");\n  return printf(v8, v7);\n}\n"], [4201895, "sub_401DA7", "__int64 __fastcall sub_401DA7(__int64 a1, __int64 a2)\n{\n  return sub_406A86(a1, a2 - 1);\n}\n"], [4201936, "sub_401DD0", "void __fastcall __noreturn sub_401DD0(int a1)\n{\n  __int64 v1; // rbx\n  char *v2; // rax\n  char *v3; // rax\n  FILE *v4; // rbx\n  char *v5; // rax\n  FILE *v6; // rbx\n  char *v7; // rax\n  char *v8; // rax\n  FILE *v9; // rbx\n  char *v10; // rax\n  FILE *v11; // rbx\n  char *v12; // rax\n  FILE *v13; // rbx\n  char *v14; // rax\n  FILE *v15; // rbx\n  char *v16; // rax\n  FILE *v17; // rbx\n  char *v18; // rax\n  FILE *v19; // rbx\n  char *v20; // rax\n  FILE *v21; // rbx\n  char *v22; // rax\n  FILE *v23; // rbx\n  char *v24; // rax\n  FILE *v25; // rbx\n  char *v26; // rax\n\n  v1 = qword_60D358;\n  if ( a1 )\n  {\n    v2 = gettext(\"Try `%s --help' for more information.\\n\");\n    fprintf(stderr, v2, v1);\n  }\n  else\n  {\n    v3 = gettext(\"Usage: %s [OPTION]... FILE...\\n\");\n    printf(v3, v1);\n    v4 = stdout;\n    v5 = gettext(\n           \"Overwrite the specified FILE(s) repeatedly, in order to make it harder\\n\"\n           \"for even very expensive hardware probing to recover the data.\\n\"\n           \"\\n\");\n    fputs_unlocked(v5, v4);\n    v6 = stdout;\n    v7 = gettext(\"Mandatory arguments to long options are mandatory for short options too.\\n\");\n    fputs_unlocked(v7, v6);\n    v8 = gettext(\n           \"  -f, --force    change permissions to allow writing if necessary\\n\"\n           \"  -n, --iterations=N  overwrite N times instead of the default (%d)\\n\"\n           \"      --random-source=FILE  get random bytes from FILE\\n\"\n           \"  -s, --size=N   shred this many bytes (suffixes like K, M, G accepted)\\n\");\n    printf(v8, 3LL);\n    v9 = stdout;\n    v10 = gettext(\n            \"  -u, --remove   truncate and remove file after overwriting\\n\"\n            \"  -v, --verbose  show progress\\n\"\n            \"  -x, --exact    do not round file sizes up to the next full block;\\n\"\n            \"                   this is the default for non-regular files\\n\"\n            \"  -z, --zero     add a final overwrite with zeros to hide shredding\\n\");\n    fputs_unlocked(v10, v9);\n    v11 = stdout;\n    v12 = gettext(\"      --help     display this help and exit\\n\");\n    fputs_unlocked(v12, v11);\n    v13 = stdout;\n    v14 = gettext(\"      --version  output version information and exit\\n\");\n    fputs_unlocked(v14, v13);\n    v15 = stdout;\n    v16 = gettext(\n            \"\\n\"\n            \"If FILE is -, shred standard output.\\n\"\n            \"\\n\"\n            \"Delete FILE(s) if --remove (-u) is specified.  The default is not to remove\\n\"\n            \"the files because it is common to operate on device files like /dev/hda,\\n\"\n            \"and those files usually should not be removed.  When operating on regular\\n\"\n            \"files, most people use the --remove option.\\n\"\n            \"\\n\");\n    fputs_unlocked(v16, v15);\n    v17 = stdout;\n    v18 = gettext(\n            \"CAUTION: Note that shred relies on a very important assumption:\\n\"\n            \"that the file system overwrites data in place.  This is the traditional\\n\"\n            \"way to do things, but many modern file system designs do not satisfy this\\n\"\n            \"assumption.  The following are examples of file systems on which shred is\\n\"\n            \"not effective, or is not guaranteed to be effective in all file system modes:\\n\"\n            \"\\n\");\n    fputs_unlocked(v18, v17);\n    v19 = stdout;\n    v20 = gettext(\n            \"* log-structured or journaled file systems, such as those supplied with\\n\"\n            \"AIX and Solaris (and JFS, ReiserFS, XFS, Ext3, etc.)\\n\"\n            \"\\n\"\n            \"* file systems that write redundant data and carry on even if some writes\\n\"\n            \"fail, such as RAID-based file systems\\n\"\n            \"\\n\"\n            \"* file systems that make snapshots, such as Network Appliance's NFS server\\n\"\n            \"\\n\");\n    fputs_unlocked(v20, v19);\n    v21 = stdout;\n    v22 = gettext(\n            \"* file systems that cache in temporary locations, such as NFS\\n\"\n            \"version 3 clients\\n\"\n            \"\\n\"\n            \"* compressed file systems\\n\"\n            \"\\n\");\n    fputs_unlocked(v22, v21);\n    v23 = stdout;\n    v24 = gettext(\n            \"In the case of ext3 file systems, the above disclaimer applies\\n\"\n            \"(and shred is thus of limited effectiveness) only in data=journal mode,\\n\"\n            \"which journals file data in addition to just metadata.  In both the\\n\"\n            \"data=ordered (default) and data=writeback modes, shred works as usual.\\n\"\n            \"Ext3 journaling modes can be changed by adding the data=something option\\n\"\n            \"to the mount options for a particular file system in the /etc/fstab file,\\n\"\n            \"as documented in the mount man page (man mount).\\n\"\n            \"\\n\");\n    fputs_unlocked(v24, v23);\n    v25 = stdout;\n    v26 = gettext(\n            \"In addition, file system backups and remote mirrors may contain copies\\n\"\n            \"of the file that cannot be removed, and that will allow a shredded file\\n\"\n            \"to be recovered later.\\n\");\n    fputs_unlocked(v26, v25);\n    sub_401C9D();\n  }\n  exit(a1);\n}\n"], [4202389, "sub_401F95", "size_t __fastcall sub_401F95(__int16 a1, _BYTE *a2, size_t a3)\n{\n  size_t result; // rax\n  unsigned int v5; // [rsp+24h] [rbp-Ch]\n  size_t n; // [rsp+28h] [rbp-8h]\n  size_t na; // [rsp+28h] [rbp-8h]\n\n  v5 = ((a1 & 0xFFF) << 12) | a1 & 0xFFF;\n  *a2 = v5 >> 4;\n  a2[1] = BYTE1(v5);\n  a2[2] = a1;\n  for ( n = 3LL; a3 >> 1 > n; n *= 2LL )\n    memcpy(&a2[n], a2, n);\n  if ( n < a3 )\n    memcpy(&a2[n], a2, a3 - n);\n  result = a1 & 0x1000;\n  if ( (a1 & 0x1000) != 0 )\n  {\n    for ( na = 0LL; ; na += 512LL )\n    {\n      result = na;\n      if ( na >= a3 )\n        break;\n      a2[na] ^= 0x80;\n    }\n  }\n  return result;\n}\n"], [4202648, "sub_402098", "int __fastcall sub_402098(unsigned __int8 *a1, char *a2)\n{\n  int result; // eax\n\n  if ( a1 )\n    result = sprintf(a2, \"%02x%02x%02x\", *a1, a1[1], a1[2]);\n  else\n    result = (unsigned int)memcpy(a2, \"random\", 7uLL);\n  return result;\n}\n"], [4202760, "sub_402108", "_BOOL8 __fastcall sub_402108(int a1)\n{\n  return a1 == 22 || a1 == 9 || a1 == 21;\n}\n"], [4202802, "sub_402132", "__int64 __fastcall sub_402132(int a1, __int64 a2)\n{\n  __int64 result; // rax\n  char *v3; // rax\n  char *v4; // rax\n  int errnum; // [rsp+1Ch] [rbp-4h]\n  int errnuma; // [rsp+1Ch] [rbp-4h]\n\n  if ( !fdatasync(a1) )\n    return 0LL;\n  errnum = *__errno_location();\n  if ( !sub_402108(errnum) )\n  {\n    v3 = gettext(\"%s: fdatasync failed\");\n    error(0, errnum, v3, a2);\n    *__errno_location() = errnum;\n    result = 0xFFFFFFFFLL;\n  }\n  else if ( fsync(a1) )\n  {\n    errnuma = *__errno_location();\n    if ( !sub_402108(errnuma) )\n    {\n      v4 = gettext(\"%s: fsync failed\");\n      error(0, errnuma, v4, a2);\n      *__errno_location() = errnuma;\n      result = 0xFFFFFFFFLL;\n    }\n    else\n    {\n      sync();\n      result = 0LL;\n    }\n  }\n  else\n  {\n    result = 0LL;\n  }\n  return result;\n}\n"], [4203036, "sub_40221C", "__int64 __fastcall sub_40221C(int a1, char a2, int a3, int a4, int a5, int a6)\n{\n  __int64 result; // rax\n  int v7; // ecx\n  int v8; // er8\n  int v9; // er9\n  int v10; // [rsp+18h] [rbp-8h]\n\n  result = sub_409226(a1, 3, a3, a4, a5, a6);\n  v10 = result;\n  if ( (int)result > 0 )\n  {\n    if ( a2 )\n      BYTE1(result) |= 0x40u;\n    else\n      BYTE1(result) &= 0xBFu;\n    result = (unsigned int)result;\n    if ( (_DWORD)result != v10 )\n      result = sub_409226(a1, 4, result, v7, v8, v9);\n  }\n  return result;\n}\n"], [4203137, "sub_402281", "__int64 __fastcall sub_402281(int a1, __int64 a2, __int64 *a3, int a4, __int64 a5, __int64 a6, __int64 a7)\n{\n  char *v7; // rbx\n  int *v8; // rax\n  size_t v10; // rax\n  char *v11; // rax\n  int v12; // edx\n  int v13; // ecx\n  int v14; // er8\n  int v15; // er9\n  __int64 v16; // rbx\n  char *v17; // rax\n  char *v18; // rbx\n  int *v19; // rax\n  char *v20; // rax\n  char *v21; // rax\n  unsigned __int64 v22; // rax\n  char *v23; // rax\n  __int64 v24; // [rsp+18h] [rbp-3898h]\n  unsigned __int8 v29; // [rsp+5Ah] [rbp-3856h]\n  char v30; // [rsp+5Bh] [rbp-3855h]\n  int errnum; // [rsp+5Ch] [rbp-3854h]\n  int v32; // [rsp+64h] [rbp-384Ch]\n  __int64 v33; // [rsp+68h] [rbp-3848h]\n  unsigned __int64 v34; // [rsp+70h] [rbp-3840h]\n  time_t v35; // [rsp+78h] [rbp-3838h]\n  time_t v36; // [rsp+80h] [rbp-3830h]\n  unsigned __int64 v37; // [rsp+88h] [rbp-3828h]\n  unsigned __int64 v38; // [rsp+90h] [rbp-3820h]\n  ssize_t v39; // [rsp+98h] [rbp-3818h]\n  const char *s1; // [rsp+A0h] [rbp-3810h]\n  char *s2; // [rsp+A8h] [rbp-3808h]\n  __int64 v42; // [rsp+C8h] [rbp-37E8h]\n  char v43[16]; // [rsp+D0h] [rbp-37E0h] BYREF\n  char dest[656]; // [rsp+E0h] [rbp-37D0h] BYREF\n  char v45[656]; // [rsp+370h] [rbp-3540h] BYREF\n  char v46[656]; // [rsp+600h] [rbp-32B0h] BYREF\n  unsigned __int8 v47[12296]; // [rsp+890h] [rbp-3020h] BYREF\n  unsigned __int64 v48; // [rsp+3898h] [rbp-18h]\n\n  v48 = __readfsqword(0x28u);\n  v33 = *a3;\n  v36 = 0LL;\n  v29 = 0;\n  v30 = 1;\n  if ( lseek(a1, 0LL, 0) == -1 )\n  {\n    v7 = gettext(\"%s: cannot rewind\");\n    v8 = __errno_location();\n    error(0, *v8, v7, a2);\n    return 0xFFFFFFFFLL;\n  }\n  if ( a4 < 0 )\n  {\n    sub_402098(0LL, v43);\n  }\n  else\n  {\n    if ( v33 < 0 || v33 >= 12288 )\n      v10 = 12288LL;\n    else\n      v10 = v33;\n    sub_401F95(a4, v47, v10);\n    sub_402098(v47, v43);\n  }\n  if ( a7 )\n  {\n    v11 = gettext(\"%s: pass %lu/%lu (%s)...\");\n    error(0, 0, v11, a2, a6, a7, v43);\n    v35 = time(0LL) + 5;\n    s1 = locale;\n  }\n  v34 = 0LL;\n  while ( 1 )\n  {\n    v37 = 12288LL;\n    if ( v33 >= 0 && (__int64)(v33 - v34) < 12288 )\n    {\n      if ( v33 < (__int64)v34 )\n        break;\n      v37 = v33 - v34;\n      if ( v33 == v34 )\n        break;\n    }\n    if ( a4 < 0 )\n      sub_4072EC(a5, v47, v37);\n    v38 = 0LL;\n    while ( v38 < v37 )\n    {\n      v39 = write(a1, &v47[v38], v37 - v38);\n      if ( v39 <= 0 )\n      {\n        if ( v33 < 0 && (!v39 || *__errno_location() == 28) )\n        {\n          v33 = v34 + v38;\n          *a3 = v34 + v38;\n          break;\n        }\n        errnum = *__errno_location();\n        if ( a6 == 1 && v30 && *__errno_location() == 22 )\n        {\n          sub_40221C(a1, 0, v12, v13, v14, v15);\n          v39 = 0LL;\n        }\n        else\n        {\n          v16 = sub_4050F4(v38 + v34, v46);\n          v17 = gettext(\"%s: error writing at offset %s\");\n          error(0, errnum, v17, a2, v16);\n          if ( errnum != 5 || v33 < 0 || (v38 | 0x1FF) >= v37 )\n            return 0xFFFFFFFFLL;\n          if ( lseek(a1, v34 + (v38 | 0x1FF) + 1, 0) == -1 )\n          {\n            v18 = gettext(\"%s: lseek failed\");\n            v19 = __errno_location();\n            error(0, *v19, v18, a2);\n            return 0xFFFFFFFFLL;\n          }\n          v39 = (v38 | 0x1FF) + 1 - v38;\n          v29 = 1;\n        }\n      }\n      v38 += v39;\n      v30 = 0;\n    }\n    if ( (__int64)(0x7FFFFFFFFFFFFFFFLL - v38) < (__int64)v34 )\n    {\n      v20 = gettext(\"%s: file too large\");\n      error(0, 0, v20, a2);\n      return 0xFFFFFFFFLL;\n    }\n    v34 += v38;\n    if ( a7 )\n    {\n      if ( v34 == v33 && *s1 || (v36 = time(0LL), v36 >= v35) )\n      {\n        s2 = (char *)sub_404479(v34, v45, 434LL, 1LL, 1LL);\n        if ( v34 == v33 || strcmp(s1, s2) )\n        {\n          if ( v33 >= 0 )\n          {\n            if ( v33 )\n              v22 = v34 > 0x28F5C28F5C28F5CLL ? v34 / (v33 / 100) : 100 * v34 / v33;\n            else\n              LODWORD(v22) = 100;\n            v32 = v22;\n            v42 = sub_404479(v33, v46, 432LL, 1LL, 1LL);\n            if ( v34 == v33 )\n              s2 = (char *)v42;\n            v23 = gettext(\"%s: pass %lu/%lu (%s)...%s/%s %d%%\");\n            LODWORD(v24) = v32;\n            error(0, 0, v23, a2, a6, a7, v43, s2, v42, v24);\n          }\n          else\n          {\n            v21 = gettext(\"%s: pass %lu/%lu (%s)...%s\");\n            error(0, 0, v21, a2, a6, a7, v43, s2);\n          }\n          strcpy(dest, s2);\n          s1 = dest;\n          v35 = v36 + 5;\n          if ( (unsigned int)sub_402132(a1, a2) )\n          {\n            if ( *__errno_location() != 5 )\n              return 0xFFFFFFFFLL;\n            v29 = 1;\n          }\n        }\n      }\n    }\n  }\n  if ( (unsigned int)sub_402132(a1, a2) )\n  {\n    if ( *__errno_location() != 5 )\n      return 0xFFFFFFFFLL;\n    v29 = 1;\n  }\n  return v29;\n}\n"], [4205298, "sub_402AF2", "void __fastcall sub_402AF2(char *a1, unsigned __int64 a2, __int64 a3)\n{\n  int *v3; // rax\n  int *v4; // rax\n  __int64 v5; // rax\n  __int64 v6; // rax\n  int v8; // [rsp+24h] [rbp-3Ch]\n  int v9; // [rsp+24h] [rbp-3Ch]\n  int v10; // [rsp+24h] [rbp-3Ch]\n  __int64 v11; // [rsp+28h] [rbp-38h]\n  unsigned __int64 v12; // [rsp+28h] [rbp-38h]\n  int *src; // [rsp+30h] [rbp-30h]\n  char *dest; // [rsp+38h] [rbp-28h]\n  unsigned __int64 i; // [rsp+40h] [rbp-20h]\n  unsigned __int64 j; // [rsp+40h] [rbp-20h]\n  unsigned __int64 v17; // [rsp+48h] [rbp-18h]\n  __int64 v18; // [rsp+50h] [rbp-10h]\n\n  if ( a2 )\n  {\n    src = (int *)&unk_40AB80;\n    v11 = 0LL;\n    dest = a1;\n    for ( i = a2; ; i -= v8 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          v3 = src++;\n          v8 = *v3;\n          if ( *v3 )\n            break;\n          src = (int *)&unk_40AB80;\n        }\n        if ( v8 >= 0 )\n          break;\n        v9 = -v8;\n        if ( v9 >= i )\n        {\n          v11 += i;\n          goto LABEL_18;\n        }\n        v11 += v9;\n        i -= v9;\n      }\n      if ( v8 > i )\n        break;\n      memcpy(dest, src, 4LL * v8);\n      src += v8;\n      dest += 4 * v8;\n    }\n    if ( i > 1 && 3 * i >= v8 )\n    {\n      do\n      {\n        if ( v8 == i || sub_401DA7(a3, v8) < i )\n        {\n          v4 = (int *)dest;\n          dest += 4;\n          *v4 = *src;\n          --i;\n        }\n        ++src;\n      }\n      while ( i );\n    }\n    else\n    {\n      v11 += i;\n    }\nLABEL_18:\n    v18 = a2 - v11;\n    v12 = v11 - 1;\n    v17 = v12;\n    for ( j = 0LL; j < a2; ++j )\n    {\n      if ( v17 > v12 )\n      {\n        v6 = sub_401DA7(a3, v18 - j);\n        v10 = *(_DWORD *)&a1[4 * j];\n        *(_DWORD *)&a1[4 * j] = *(_DWORD *)&a1[4 * j + 4 * v6];\n        *(_DWORD *)&a1[4 * j + 4 * v6] = v10;\n      }\n      else\n      {\n        v17 = a2 + v17 - 1;\n        v5 = v18++;\n        *(_DWORD *)&a1[4 * v5] = *(_DWORD *)&a1[4 * j];\n        *(_DWORD *)&a1[4 * j] = -1;\n      }\n      v17 -= v12;\n    }\n  }\n}\n"], [4205962, "sub_402D8A", "__int64 __fastcall sub_402D8A(int a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  int v4; // edx\n  int v5; // ecx\n  int v6; // er8\n  int v7; // er9\n  char *v8; // rbx\n  int *v9; // rax\n  char *v11; // rax\n  char *v12; // rax\n  __blksize_t v13; // rcx\n  __blksize_t v14; // rbx\n  char *v15; // rbx\n  int *v16; // rax\n  unsigned __int8 v19; // [rsp+3Fh] [rbp-D1h]\n  int v20; // [rsp+40h] [rbp-D0h]\n  int v21; // [rsp+44h] [rbp-CCh]\n  __off_t v22; // [rsp+48h] [rbp-C8h] BYREF\n  unsigned __int64 i; // [rsp+50h] [rbp-C0h]\n  __int64 v24; // [rsp+58h] [rbp-B8h]\n  void *s; // [rsp+60h] [rbp-B0h]\n  __int64 v26; // [rsp+68h] [rbp-A8h]\n  struct stat stat_buf; // [rsp+70h] [rbp-A0h] BYREF\n\n  v19 = 1;\n  v24 = 0LL;\n  if ( *(_BYTE *)(a4 + 25) )\n    v24 = *(_QWORD *)(a4 + 8) + *(unsigned __int8 *)(a4 + 27);\n  if ( (unsigned int)sub_409CA0(a1, &stat_buf) )\n  {\n    v8 = gettext(\"%s: fstat failed\");\n    v9 = __errno_location();\n    error(0, *v9, v8, a2);\n    return 0LL;\n  }\n  if ( (stat_buf.st_mode & 0xF000) == 0x2000 && isatty(a1)\n    || (stat_buf.st_mode & 0xF000) == 4096\n    || (stat_buf.st_mode & 0xF000) == 49152 )\n  {\n    v11 = gettext(\"%s: invalid file type\");\n    error(0, 0, v11, a2);\n    return 0LL;\n  }\n  sub_40221C(a1, 1, v4, v5, v6, v7);\n  s = (void *)sub_408965(*(_QWORD *)(a4 + 8), 4LL);\n  v22 = *(_QWORD *)(a4 + 16);\n  if ( v22 == -1 )\n  {\n    if ( (stat_buf.st_mode & 0xF000) == 0x8000 )\n    {\n      v22 = stat_buf.st_size;\n      if ( stat_buf.st_size < 0 )\n      {\n        v12 = gettext(\"%s: file has negative size\");\n        error(0, 0, v12, a2);\n        return 0LL;\n      }\n    }\n    else\n    {\n      v22 = lseek(a1, 0LL, 2);\n      if ( v22 <= 0 )\n        v22 = -1LL;\n    }\n    if ( v22 >= 0 && *(_BYTE *)(a4 + 26) != 1 && (stat_buf.st_mode & 0xF000) == 0x8000 )\n    {\n      if ( stat_buf.st_blksize <= 0 || stat_buf.st_blksize > 0x2000000000000000uLL )\n        v13 = 511LL;\n      else\n        v13 = stat_buf.st_blksize - 1;\n      if ( stat_buf.st_blksize <= 0 || stat_buf.st_blksize > 0x2000000000000000uLL )\n        v14 = 512LL;\n      else\n        v14 = stat_buf.st_blksize;\n      v22 += v13 - (v22 - 1) % v14;\n      if ( v22 < 0 )\n        v22 = 0x7FFFFFFFFFFFFFFFLL;\n    }\n  }\n  sub_402AF2((char *)s, *(_QWORD *)(a4 + 8), a3);\n  v26 = sub_406A63(a3);\n  for ( i = 0LL; *(_QWORD *)(a4 + 8) > i; ++i )\n  {\n    v20 = sub_402281(a1, a2, &v22, *((_DWORD *)s + i), v26, i + 1, v24);\n    if ( v20 )\n    {\n      if ( v20 < 0 )\n      {\n        memset(s, 0, 4LL * *(_QWORD *)(a4 + 8));\n        free(s);\n        return 0LL;\n      }\n      v19 = 0;\n    }\n  }\n  memset(s, 0, 4LL * *(_QWORD *)(a4 + 8));\n  free(s);\n  if ( *(_BYTE *)(a4 + 27) )\n  {\n    v21 = sub_402281(a1, a2, &v22, 0, v26, *(_QWORD *)(a4 + 8) + 1LL, v24);\n    if ( v21 )\n    {\n      if ( v21 < 0 )\n        return 0LL;\n      v19 = 0;\n    }\n  }\n  if ( !*(_BYTE *)(a4 + 24) || !ftruncate(a1, 0LL) || (stat_buf.st_mode & 0xF000) != 0x8000 )\n    return v19;\n  v15 = gettext(\"%s: error truncating\");\n  v16 = __errno_location();\n  error(0, *v16, v15, a2);\n  return 0LL;\n}\n"], [4207327, "sub_4032DF", "__int64 __fastcall sub_4032DF(int a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6)\n{\n  char *v6; // rbx\n  int *v7; // rax\n  __int64 result; // rax\n  char *v9; // rax\n  int v12; // [rsp+2Ch] [rbp-14h]\n\n  v12 = sub_409226(a1, 3, a3, a4, a5, a6);\n  if ( v12 >= 0 )\n  {\n    if ( (v12 & 0x400) != 0 )\n    {\n      v9 = gettext(\"%s: cannot shred append-only file descriptor\");\n      error(0, 0, v9, a2);\n      result = 0LL;\n    }\n    else\n    {\n      result = sub_402D8A(a1, a2, a3, a4);\n    }\n  }\n  else\n  {\n    v6 = gettext(\"%s: fcntl failed\");\n    v7 = __errno_location();\n    error(0, *v7, v6, a2);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4207522, "sub_4033A2", "__int64 __fastcall sub_4033A2(__int64 a1, __int64 a2)\n{\n  char *v5; // [rsp+18h] [rbp-8h]\n\n  while ( a2-- )\n  {\n    v5 = strchr(\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_.\", *(char *)(a1 + a2));\n    if ( !v5 )\n      __assert_fail(\"p\", \"../../src/src/shred.c\", 0x39Cu, \"incname\");\n    if ( v5[1] )\n    {\n      *(_BYTE *)(a2 + a1) = v5[1];\n      return 1LL;\n    }\n    *(_BYTE *)(a2 + a1) = 48;\n  }\n  return 0LL;\n}\n"], [4207694, "sub_40344E", "__int64 __fastcall sub_40344E(const char *a1, const char *a2, __int64 a3)\n{\n  __int64 v3; // rax\n  int v4; // edx\n  int v5; // ecx\n  int v6; // er8\n  int v7; // er9\n  char *v8; // rax\n  const char *v9; // rax\n  char *v10; // rax\n  char *v11; // rbx\n  int *v12; // rax\n  char *v13; // rax\n  char *v14; // rbx\n  int *v15; // rax\n  char v18; // [rsp+2Ah] [rbp-D6h]\n  unsigned __int8 v19; // [rsp+2Bh] [rbp-D5h]\n  int fd; // [rsp+2Ch] [rbp-D4h]\n  __int64 n; // [rsp+30h] [rbp-D0h]\n  char *newa; // [rsp+38h] [rbp-C8h]\n  void *s; // [rsp+40h] [rbp-C0h]\n  void *ptr; // [rsp+48h] [rbp-B8h]\n  void *v25; // [rsp+50h] [rbp-B0h]\n  const char *v26; // [rsp+58h] [rbp-A8h]\n  struct stat stat_buf; // [rsp+60h] [rbp-A0h] BYREF\n\n  newa = (char *)sub_408C03(a1);\n  s = (void *)sub_404082(newa);\n  n = sub_4040EB(s);\n  ptr = (void *)sub_403F34(newa);\n  v3 = sub_40685A(ptr);\n  v25 = (void *)sub_408C03(v3);\n  v18 = 1;\n  v19 = 1;\n  fd = sub_404139((_DWORD)ptr, 67840, v4, v5, v6, v7);\n  if ( *(_BYTE *)(a3 + 25) )\n  {\n    v8 = gettext(\"%s: removing\");\n    error(0, 0, v8, a2);\n  }\n  while ( n )\n  {\n    memset(s, 48, n);\n    *((_BYTE *)s + n) = 0;\n    while ( (int)sub_409CB0(newa, &stat_buf) >= 0 )\n    {\n      if ( !(unsigned __int8)sub_4033A2((__int64)s, n) )\n        goto LABEL_18;\n    }\n    if ( !rename(a1, newa) )\n    {\n      if ( fd >= 0 && (unsigned int)sub_402132(fd, (__int64)v25) )\n        v19 = 0;\n      if ( *(_BYTE *)(a3 + 25) )\n      {\n        if ( v18 )\n          v9 = a2;\n        else\n          v9 = a1;\n        v26 = v9;\n        v10 = gettext(\"%s: renamed to %s\");\n        error(0, 0, v10, v26, newa);\n        v18 = 0;\n      }\n      memcpy((void *)&a1[(_BYTE *)s - newa], s, n + 1);\n    }\nLABEL_18:\n    --n;\n  }\n  if ( unlink(a1) )\n  {\n    v11 = gettext(\"%s: failed to remove\");\n    v12 = __errno_location();\n    error(0, *v12, v11, a2);\n    v19 = 0;\n  }\n  else if ( *(_BYTE *)(a3 + 25) )\n  {\n    v13 = gettext(\"%s: removed\");\n    error(0, 0, v13, a2);\n  }\n  if ( fd >= 0 )\n  {\n    if ( (unsigned int)sub_402132(fd, (__int64)v25) )\n      v19 = 0;\n    if ( close(fd) )\n    {\n      v14 = gettext(\"%s: failed to close\");\n      v15 = __errno_location();\n      error(0, *v15, v14, v25);\n      v19 = 0;\n    }\n  }\n  free(newa);\n  free(ptr);\n  free(v25);\n  return v19;\n}\n"], [4208662, "sub_403816", "__int64 __fastcall sub_403816(const char *a1, const char *a2, __int64 a3, _BYTE *a4, int a5, int a6)\n{\n  int v6; // edx\n  int v7; // ecx\n  int v8; // er8\n  int v9; // er9\n  char *v10; // rbx\n  int *v11; // rax\n  __int64 result; // rax\n  char *v13; // rbx\n  int *v14; // rax\n  unsigned __int8 v17; // [rsp+2Bh] [rbp-15h]\n  int fd; // [rsp+2Ch] [rbp-14h]\n\n  fd = sub_404139((_DWORD)a1, 257, a3, (_DWORD)a4, a5, a6);\n  if ( fd < 0 && *__errno_location() == 13 && *a4 && !chmod(a1, 0x80u) )\n    fd = sub_404139((_DWORD)a1, 257, v6, v7, v8, v9);\n  if ( fd >= 0 )\n  {\n    v17 = sub_402D8A(fd, (__int64)a2, a3, (__int64)a4);\n    if ( close(fd) )\n    {\n      v13 = gettext(\"%s: failed to close\");\n      v14 = __errno_location();\n      error(0, *v14, v13, a2);\n      v17 = 0;\n    }\n    if ( v17 )\n    {\n      if ( a4[24] )\n        v17 = sub_40344E(a1, a2, (__int64)a4);\n    }\n    result = v17;\n  }\n  else\n  {\n    v10 = gettext(\"%s: failed to open for writing\");\n    v11 = __errno_location();\n    error(0, *v11, v10, a2);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4208995, "sub_403963", "__int64 sub_403963()\n{\n  return sub_406C99(qword_60D340);\n}\n"], [4209016, "main", "void __fastcall __noreturn main(int a1, char **a2, char **a3)\n{\n  __int64 v3; // rbx\n  char *v4; // rax\n  char *v5; // rax\n  __int64 v6; // rbx\n  char *v7; // rax\n  char *v8; // rax\n  const char *v9; // rbx\n  int *v10; // rax\n  __int64 v11; // rax\n  int v12; // er8\n  int v13; // er9\n  bool v14; // [rsp+13h] [rbp-5Dh]\n  int i; // [rsp+14h] [rbp-5Ch]\n  int v16; // [rsp+18h] [rbp-58h]\n  int v17; // [rsp+1Ch] [rbp-54h]\n  unsigned __int64 v18; // [rsp+20h] [rbp-50h] BYREF\n  char *s1; // [rsp+28h] [rbp-48h]\n  char **v20; // [rsp+30h] [rbp-40h]\n  void *ptr; // [rsp+38h] [rbp-38h]\n  __int64 v22; // [rsp+40h] [rbp-30h] BYREF\n  unsigned __int64 v23; // [rsp+48h] [rbp-28h]\n  unsigned __int64 v24; // [rsp+50h] [rbp-20h]\n  __int64 v25; // [rsp+58h] [rbp-18h]\n\n  v14 = 1;\n  v22 = 0LL;\n  v23 = 0LL;\n  v24 = 0LL;\n  v25 = 0LL;\n  s1 = 0LL;\n  sub_405179(*a2, a2, a3);\n  setlocale(6, locale);\n  bindtextdomain(\"coreutils\", \"/root/Product/coreutils/exe/share/locale\");\n  textdomain(\"coreutils\");\n  sub_409C80(sub_403E49);\n  v23 = 3LL;\n  v24 = -1LL;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        v16 = getopt_long(a1, a2, \"fn:s:uvxz\", &longopts, 0LL);\n        if ( v16 == -1 )\n        {\n          v20 = &a2[optind];\n          v17 = a1 - optind;\n          if ( a1 == optind )\n          {\n            v8 = gettext(\"missing file operand\");\n            error(0, 0, v8);\n            sub_401DD0(1);\n          }\n          qword_60D340 = sub_406A20(s1, -1LL);\n          if ( !qword_60D340 )\n          {\n            v9 = (const char *)sub_40685A(s1);\n            v10 = __errno_location();\n            error(1, *v10, \"%s\", v9);\n          }\n          sub_409C80(sub_403963);\n          for ( i = 0; i < v17; ++i )\n          {\n            v11 = sub_40685A(v20[i]);\n            ptr = (void *)sub_408C03(v11);\n            if ( !strcmp(v20[i], \"-\") )\n              v14 = (v14 & (unsigned __int8)sub_4032DF(1, (__int64)ptr, qword_60D340, (__int64)&v22, v12, v13)) != 0;\n            else\n              v14 = (v14 & (unsigned __int8)sub_403816(v20[i], (const char *)ptr, qword_60D340, &v22, v12, v13)) != 0;\n            free(ptr);\n          }\n          exit(!v14);\n        }\n        if ( v16 != 115 )\n          break;\n        if ( (unsigned int)sub_408D05(optarg, 0LL, 0LL, &v18, \"cbBkKMGTPEZY0\") )\n        {\n          v6 = sub_40685A(optarg);\n          v7 = gettext(\"%s: invalid file size\");\n          error(1, 0, v7, v6);\n        }\n        v24 = v18;\n      }\n      if ( v16 <= 115 )\n        break;\n      if ( v16 == 120 )\n      {\n        BYTE2(v25) = 1;\n      }\n      else if ( v16 > 120 )\n      {\n        if ( v16 == 122 )\n        {\n          BYTE3(v25) = 1;\n        }\n        else\n        {\n          if ( v16 != 128 )\n            goto LABEL_37;\n          if ( s1 && strcmp(s1, optarg) )\n          {\n            v5 = gettext(\"multiple random sources specified\");\n            error(1, 0, v5);\n          }\n          s1 = optarg;\n        }\n      }\n      else if ( v16 == 117 )\n      {\n        LOBYTE(v25) = 1;\n      }\n      else\n      {\n        if ( v16 != 118 )\n          goto LABEL_37;\n        BYTE1(v25) = 1;\n      }\n    }\n    if ( v16 == -130 )\n      sub_401DD0(0);\n    if ( v16 <= -130 )\n    {\n      if ( v16 == -131 )\n      {\n        sub_408846(\n          (_DWORD)stdout,\n          (unsigned int)\"shred\",\n          (unsigned int)\"GNU coreutils\",\n          (_DWORD)off_60D290,\n          (unsigned int)\"Colin Plumb\",\n          0,\n          (char)a2);\n        exit(0);\n      }\nLABEL_37:\n      sub_401DD0(1);\n    }\n    if ( v16 == 102 )\n    {\n      LOBYTE(v22) = 1;\n    }\n    else\n    {\n      if ( v16 != 110 )\n        goto LABEL_37;\n      if ( (unsigned int)sub_408D05(optarg, 0LL, 10LL, &v18, 0LL) || v18 > 0xFFFFFFFF )\n      {\n        v3 = sub_40685A(optarg);\n        v4 = gettext(\"%s: invalid number of passes\");\n        error(1, 0, v4, v3);\n      }\n      v23 = v18;\n    }\n  }\n}\n"], [4210228, "sub_403E34", "__int64 __fastcall sub_403E34(unsigned __int8 a1)\n{\n  __int64 result; // rax\n\n  result = a1;\n  byte_60D350 = a1;\n  return result;\n}\n"], [4210249, "sub_403E49", "__int64 sub_403E49()\n{\n  const char *v0; // rbx\n  int *v1; // rax\n  int *v2; // rax\n  __int64 result; // rax\n  char *v4; // [rsp+8h] [rbp-18h]\n\n  if ( (unsigned int)sub_409A22(stdout) && (byte_60D350 != 1 || *__errno_location() != 32) )\n  {\n    v4 = gettext(\"write error\");\n    if ( qword_60D348 )\n    {\n      v0 = (const char *)sub_40685A(qword_60D348);\n      v1 = __errno_location();\n      error(0, *v1, \"%s: %s\", v0, v4);\n    }\n    else\n    {\n      v2 = __errno_location();\n      error(0, *v2, \"%s\", v4);\n    }\n    _exit(status);\n  }\n  result = sub_409A22(stderr);\n  if ( (_DWORD)result )\n    _exit(status);\n  return result;\n}\n"], [4210484, "sub_403F34", "__int64 __fastcall sub_403F34(__int64 a1)\n{\n  __int64 v2; // [rsp+18h] [rbp-8h]\n\n  v2 = sub_403FEB(a1);\n  if ( !v2 )\n    sub_408C30();\n  return v2;\n}\n"], [4210530, "sub_403F62", "unsigned __int64 __fastcall sub_403F62(_BYTE *a1)\n{\n  unsigned __int64 i; // [rsp+10h] [rbp-10h]\n  unsigned __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = *a1 == 47;\n  for ( i = sub_404082(a1) - (_QWORD)a1; v3 < i && a1[i - 1] == 47; --i )\n    ;\n  return i;\n}\n"], [4210667, "sub_403FEB", "_BYTE *__fastcall sub_403FEB(_BYTE *a1)\n{\n  unsigned __int64 n; // [rsp+20h] [rbp-10h]\n  _BYTE *dest; // [rsp+28h] [rbp-8h]\n\n  n = sub_403F62(a1);\n  dest = malloc((n == 0) + n + 1);\n  if ( !dest )\n    return 0LL;\n  memcpy(dest, a1, n);\n  if ( !n )\n  {\n    n = 1LL;\n    *dest = 46;\n  }\n  dest[n] = 0;\n  return dest;\n}\n"], [4210818, "sub_404082", "_BYTE *__fastcall sub_404082(_BYTE *a1)\n{\n  char v2; // [rsp+17h] [rbp-11h]\n  _BYTE *i; // [rsp+20h] [rbp-8h]\n\n  v2 = 0;\n  while ( *a1 == 47 )\n    ++a1;\n  for ( i = a1; *i; ++i )\n  {\n    if ( *i == 47 )\n    {\n      v2 = 1;\n    }\n    else if ( v2 )\n    {\n      a1 = i;\n      v2 = 0;\n    }\n  }\n  return a1;\n}\n"], [4210923, "sub_4040EB", "size_t __fastcall sub_4040EB(const char *a1)\n{\n  size_t i; // [rsp+10h] [rbp-10h]\n\n  for ( i = strlen(a1); i > 1 && a1[i - 1] == 47; --i )\n    ;\n  return i;\n}\n"], [4211001, "sub_404139", "__int64 __fastcall sub_404139(const char *a1, char a2, unsigned int a3)\n{\n  unsigned int v3; // eax\n  unsigned int v5; // [rsp+14h] [rbp-CCh]\n\n  v5 = 0;\n  if ( (a2 & 0x40) != 0 )\n    v5 = a3;\n  v3 = open(a1, a2, v5);\n  return sub_4080C7(v3);\n}\n"], [4211275, "sub_40424B", "long double __fastcall sub_40424B(int a1, long double a2)\n{\n  _BOOL4 v7; // eax\n  long double v9; // [rsp+0h] [rbp-30h]\n  unsigned __int64 v10; // [rsp+28h] [rbp-8h]\n\n  if ( a1 != 1 && a2 < 1.8446744073709551615e19 )\n  {\n    if ( a2 >= 9.223372036854775808e18 )\n      v10 = (__int64)(a2 - 9.223372036854775808e18) ^ 0x8000000000000000LL;\n    else\n      v10 = (__int64)a2;\n    v7 = !a1 && a2 != (long double)v10;\n    a2 = (long double)(v7 + v10);\n  }\n  *(_QWORD *)&v9 = *(_QWORD *)&a2;\n  DWORD2(v9) = DWORD2(a2);\n  return v9;\n}\n"], [4211522, "sub_404342", "char *__fastcall sub_404342(char *a1, size_t a2, unsigned __int8 *a3, const char *a4)\n{\n  char *i; // rbx\n  size_t v5; // rax\n  char *v6; // rbx\n  unsigned __int8 v10; // [rsp+27h] [rbp-69h]\n  size_t v11; // [rsp+28h] [rbp-68h]\n  size_t v12; // [rsp+30h] [rbp-60h]\n  size_t v13; // [rsp+38h] [rbp-58h]\n  char dest[56]; // [rsp+40h] [rbp-50h] BYREF\n  unsigned __int64 v15; // [rsp+78h] [rbp-18h]\n\n  v15 = __readfsqword(0x28u);\n  v11 = -1LL;\n  v13 = strlen(a4);\n  v12 = a2;\n  memcpy(dest, a1, a2);\n  for ( i = &a1[a2]; ; memcpy(i, a4, v13) )\n  {\n    v10 = *a3;\n    if ( *a3 )\n    {\n      if ( v10 > 0x7Eu )\n        v5 = v12;\n      else\n        v5 = v10;\n      v11 = v5;\n      ++a3;\n    }\n    if ( v12 < v11 )\n      v11 = v12;\n    v6 = &i[-v11];\n    v12 -= v11;\n    memcpy(v6, &dest[v12], v11);\n    if ( !v12 )\n      break;\n    i = &v6[-v13];\n  }\n  return v6;\n}\n"], [4211833, "sub_404479", "char *__fastcall sub_404479(unsigned __int64 a1, char *a2, __int16 a3, unsigned __int64 a4, unsigned __int64 a5)\n{\n  int v5; // eax\n  int v6; // eax\n  long double v7; // fst7\n  long double v8; // fst7\n  long double v9; // fst7\n  int v10; // eax\n  bool v11; // al\n  bool v12; // al\n  bool v13; // al\n  bool v14; // al\n  char *v15; // rax\n  char v16; // dl\n  char *v17; // rax\n  char *v18; // rax\n  long double v20; // [rsp+0h] [rbp-130h]\n  int v24; // [rsp+44h] [rbp-ECh]\n  int v25; // [rsp+48h] [rbp-E8h]\n  int v26; // [rsp+4Ch] [rbp-E4h]\n  int v27; // [rsp+50h] [rbp-E0h]\n  unsigned int v28; // [rsp+54h] [rbp-DCh]\n  unsigned int v29; // [rsp+5Ch] [rbp-D4h]\n  unsigned int v30; // [rsp+60h] [rbp-D0h]\n  unsigned __int64 v31; // [rsp+68h] [rbp-C8h]\n  char *dest; // [rsp+70h] [rbp-C0h]\n  char *desta; // [rsp+70h] [rbp-C0h]\n  char *v34; // [rsp+78h] [rbp-B8h]\n  char *v35; // [rsp+80h] [rbp-B0h]\n  char *src; // [rsp+88h] [rbp-A8h]\n  size_t v37; // [rsp+90h] [rbp-A0h]\n  const char *v38; // [rsp+98h] [rbp-98h]\n  unsigned __int64 n; // [rsp+A0h] [rbp-90h]\n  size_t v40; // [rsp+A8h] [rbp-88h]\n  unsigned __int64 i; // [rsp+B0h] [rbp-80h]\n  unsigned __int8 *v42; // [rsp+B8h] [rbp-78h]\n  struct lconv *v43; // [rsp+C0h] [rbp-70h]\n  size_t v44; // [rsp+C8h] [rbp-68h]\n  unsigned __int64 v45; // [rsp+E8h] [rbp-48h]\n  long double v46; // [rsp+F0h] [rbp-40h]\n  long double v47; // [rsp+110h] [rbp-20h]\n  long double v48; // [rsp+110h] [rbp-20h]\n\n  v27 = a3 & 3;\n  if ( (a3 & 0x20) != 0 )\n    v5 = 1024;\n  else\n    v5 = 1000;\n  v28 = v5;\n  v25 = -1;\n  src = \".\";\n  v37 = 1LL;\n  v38 = (const char *)&unk_40AECB;\n  v43 = localeconv();\n  v44 = strlen(v43->decimal_point);\n  if ( v44 && v44 <= 0x10 )\n  {\n    src = v43->decimal_point;\n    v37 = v44;\n  }\n  v42 = (unsigned __int8 *)v43->grouping;\n  if ( strlen(v43->thousands_sep) <= 0x10 )\n    v38 = v43->thousands_sep;\n  v34 = a2 + 648;\n  dest = a2 + 648;\n  if ( a5 > a4 )\n  {\n    if ( a4 && !(a5 % a4) )\n    {\n      v45 = 2 * (10 * (a1 % (a5 / a4)) % (a5 / a4));\n      v31 = a1 / (a5 / a4);\n      v24 = 10 * (a1 % (a5 / a4)) / (a5 / a4);\n      if ( v45 >= a5 / a4 )\n      {\n        if ( a5 / a4 >= v45 )\n          v6 = 2;\n        else\n          v6 = 3;\n      }\n      else\n      {\n        v6 = v45 != 0;\n      }\n      v26 = v6;\nLABEL_32:\n      if ( (a3 & 0x10) != 0 )\n      {\n        v25 = 0;\n        if ( v28 <= v31 )\n        {\n          do\n          {\n            v29 = 10 * (v31 % v28) + v24;\n            v30 = 2 * (v29 % v28) + (v26 >> 1);\n            v31 /= v28;\n            v24 = v29 / v28;\n            if ( v30 >= v28 )\n            {\n              if ( v26 + v30 <= v28 )\n                v10 = 2;\n              else\n                v10 = 3;\n            }\n            else\n            {\n              v10 = v26 + v30 != 0;\n            }\n            v26 = v10;\n            ++v25;\n          }\n          while ( v28 <= v31 && v25 < 8 );\n          if ( v31 <= 9 )\n          {\n            if ( v27 == 1 )\n            {\n              v11 = (int)(((v29 / v28) & 1) + v10) > 2;\n            }\n            else\n            {\n              v12 = !v27 && v10 > 0;\n              v11 = v12;\n            }\n            if ( v11 )\n            {\n              ++v24;\n              v26 = 0;\n              if ( v24 == 10 )\n              {\n                ++v31;\n                v24 = 0;\n              }\n            }\n            if ( v31 <= 9 && (v24 || (a3 & 8) == 0) )\n            {\n              a2[647] = v24 + 48;\n              dest = &a2[-v37 + 647];\n              memcpy(dest, src, v37);\n              v26 = 0;\n              v24 = 0;\n            }\n          }\n        }\n      }\n      if ( v27 == 1 )\n      {\n        v13 = ((v31 & 1) + v26 != 0) + v24 > 5;\n      }\n      else\n      {\n        v14 = !v27 && v24 + v26 > 0;\n        v13 = v14;\n      }\n      if ( v13 )\n      {\n        ++v31;\n        if ( (a3 & 0x10) != 0 && v28 == v31 && v25 < 8 )\n        {\n          ++v25;\n          if ( (a3 & 8) == 0 )\n          {\n            desta = dest - 1;\n            *desta = 48;\n            dest = &desta[-v37];\n            memcpy(dest, src, v37);\n          }\n          v31 = 1LL;\n        }\n      }\n      v35 = dest;\n      do\n      {\n        *--dest = v31 % 0xA + 48;\n        v31 /= 0xAuLL;\n      }\n      while ( v31 );\n      goto LABEL_72;\n    }\n  }\n  else if ( !(a4 % a5) )\n  {\n    v31 = a4 / a5 * a1;\n    if ( v31 / (a4 / a5) == a1 )\n    {\n      v24 = 0;\n      v26 = 0;\n      goto LABEL_32;\n    }\n  }\n  v47 = (long double)a1 * ((long double)a4 / (long double)a5);\n  if ( (a3 & 0x10) != 0 )\n  {\n    *(_QWORD *)&v46 = 0x8000000000000000LL;\n    DWORD2(v46) = 0x3FFF;\n    v25 = 0;\n    do\n    {\n      v46 = (long double)v28 * v46;\n      ++v25;\n    }\n    while ( v47 >= (long double)v28 * v46 && v25 < 8 );\n    v48 = v47 / v46;\n    *(_QWORD *)&v20 = *(_QWORD *)&v48;\n    DWORD2(v20) = DWORD2(v48);\n    v8 = sub_40424B(v27, v20);\n    sprintf(a2, \"%.1Lf\", v8);\n    n = strlen(a2);\n    v40 = v37 + 1;\n    if ( ((a3 & 0x20) == 0) + v37 + 1 + 1 < n || (a3 & 8) != 0 && a2[n - 1] == 48 )\n    {\n      v9 = sub_40424B(v27, v48 * 10.0);\n      sprintf(a2, \"%.0Lf\", v9 / 10.0);\n      n = strlen(a2);\n      v40 = 0LL;\n    }\n  }\n  else\n  {\n    *(_QWORD *)&v20 = *(_QWORD *)&v47;\n    DWORD2(v20) = DWORD2(v47);\n    v7 = sub_40424B(v27, v20);\n    sprintf(a2, \"%.0Lf\", v7);\n    n = strlen(a2);\n    v40 = 0LL;\n  }\n  dest = &v34[-n];\n  memmove(&v34[-n], a2, n);\n  v35 = &v34[-v40];\nLABEL_72:\n  if ( (a3 & 4) != 0 )\n    dest = sub_404342(dest, v35 - dest, v42, v38);\n  if ( (a3 & 0x80) != 0 )\n  {\n    if ( v25 < 0 )\n    {\n      v25 = 0;\n      for ( i = 1LL; i < a5; i *= v28 )\n      {\n        if ( ++v25 == 8 )\n          break;\n      }\n    }\n    if ( v25 | a3 & 0x100 && (a3 & 0x40) != 0 )\n    {\n      v34 = a2 + 649;\n      a2[648] = 32;\n    }\n    if ( v25 )\n    {\n      v15 = v34++;\n      if ( (a3 & 0x20) == 0 && v25 == 1 )\n        v16 = 107;\n      else\n        v16 = byte_40AEC0[v25];\n      *v15 = v16;\n    }\n    if ( (a3 & 0x100) != 0 )\n    {\n      if ( (a3 & 0x20) != 0 && v25 )\n      {\n        v17 = v34++;\n        *v17 = 105;\n      }\n      v18 = v34++;\n      *v18 = 66;\n    }\n  }\n  *v34 = 0;\n  return dest;\n}\n"], [4214551, "sub_404F17", "__int64 sub_404F17()\n{\n  __int64 result; // rax\n\n  if ( getenv(\"POSIXLY_CORRECT\") )\n    result = 512LL;\n  else\n    result = 1024LL;\n  return result;\n}\n"], [4214584, "sub_404F38", "__int64 __fastcall sub_404F38(char *a1, _QWORD *a2, int *a3)\n{\n  char *v5; // [rsp+18h] [rbp-28h]\n  int v6; // [rsp+2Ch] [rbp-14h]\n  int v7; // [rsp+30h] [rbp-10h]\n  unsigned int v8; // [rsp+34h] [rbp-Ch]\n  char *v9; // [rsp+38h] [rbp-8h] BYREF\n\n  v5 = a1;\n  v6 = 0;\n  if ( a1 || (v5 = getenv(\"BLOCK_SIZE\")) != 0LL || (v5 = getenv(\"BLOCKSIZE\")) != 0LL )\n  {\n    if ( *v5 == 39 )\n    {\n      v6 = 4;\n      ++v5;\n    }\n    v7 = sub_409626(v5, off_40AEF0, dword_40AF08, 4LL);\n    if ( v7 < 0 )\n    {\n      v8 = sub_408D05(v5, &v9, 0LL, a2, \"eEgGkKmMpPtTyYzZ0\");\n      if ( v8 )\n      {\n        *a3 = 0;\n        return v8;\n      }\n      while ( *v5 <= 47 || *v5 > 57 )\n      {\n        if ( v5 == v9 )\n        {\n          v6 |= 0x80u;\n          if ( *(v9 - 1) == 66 )\n            v6 |= 0x100u;\n          if ( *(v9 - 1) != 66 || *(v9 - 2) == 105 )\n            v6 |= 0x20u;\n          break;\n        }\n        ++v5;\n      }\n    }\n    else\n    {\n      v6 |= dword_40AF08[v7];\n      *a2 = 1LL;\n    }\n  }\n  else\n  {\n    *a2 = sub_404F17();\n  }\n  *a3 = v6;\n  return 0LL;\n}\n"], [4214946, "sub_4050A2", "__int64 __fastcall sub_4050A2(char *a1, int *a2, _QWORD *a3)\n{\n  unsigned int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = sub_404F38(a1, a3, a2);\n  if ( !*a3 )\n  {\n    *a3 = sub_404F17();\n    v5 = 4;\n  }\n  return v5;\n}\n"], [4215028, "sub_4050F4", "__int64 __fastcall sub_4050F4(unsigned __int64 a1, __int64 a2)\n{\n  __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v4 = a2 + 20;\n  *(_BYTE *)(a2 + 20) = 0;\n  do\n  {\n    *(_BYTE *)--v4 = a1 % 0xA + 48;\n    a1 /= 0xAuLL;\n  }\n  while ( a1 );\n  return v4;\n}\n"], [4215161, "sub_405179", "char *__fastcall sub_405179(const char *a1)\n{\n  char *v1; // rax\n  char *result; // rax\n  char *s; // [rsp+8h] [rbp-18h]\n  char *v4; // [rsp+10h] [rbp-10h]\n  char *s1; // [rsp+18h] [rbp-8h]\n\n  s = (char *)a1;\n  if ( !a1 )\n  {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\", 1uLL, 0x37uLL, stderr);\n    abort();\n  }\n  v4 = strrchr(a1, 47);\n  if ( v4 )\n    v1 = v4 + 1;\n  else\n    v1 = (char *)a1;\n  s1 = v1;\n  if ( v1 - a1 > 6 && !strncmp(v1 - 7, \"/.libs/\", 7uLL) )\n  {\n    s = s1;\n    if ( !strncmp(s1, \"lt-\", 3uLL) )\n    {\n      s = s1 + 3;\n      program_invocation_short_name = (__int64)(s1 + 3);\n    }\n  }\n  qword_60D358 = (__int64)s;\n  result = s;\n  program_invocation_name = (__int64)s;\n  return result;\n}\n"], [4215392, "sub_405260", "__int64 __fastcall sub_405260(__int64 *a1)\n{\n  __int64 *v1; // rax\n  int v3; // [rsp+14h] [rbp-Ch]\n  __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v3 = *__errno_location();\n  if ( a1 )\n    v1 = a1;\n  else\n    v1 = &qword_60D360;\n  v4 = sub_408BD2(v1, 56LL);\n  *__errno_location() = v3;\n  return v4;\n}\n"], [4215465, "sub_4052A9", "__int64 __fastcall sub_4052A9(__int64 *a1)\n{\n  __int64 *v1; // rax\n\n  if ( a1 )\n    v1 = a1;\n  else\n    v1 = &qword_60D360;\n  return *(unsigned int *)v1;\n}\n"], [4215495, "sub_4052C7", "__int64 *__fastcall sub_4052C7(__int64 *a1, int a2)\n{\n  __int64 *result; // rax\n\n  if ( a1 )\n    result = a1;\n  else\n    result = &qword_60D360;\n  *(_DWORD *)result = a2;\n  return result;\n}\n"], [4215531, "sub_4052EB", "__int64 __fastcall sub_4052EB(__int64 *a1, unsigned __int8 a2, char a3)\n{\n  __int64 *v3; // rax\n  unsigned int v5; // [rsp+24h] [rbp-Ch]\n\n  if ( a1 )\n    v3 = a1;\n  else\n    v3 = &qword_60D360;\n  v5 = (*((_DWORD *)v3 + (a2 >> 5) + 2) >> (a2 & 0x1F)) & 1;\n  *((_DWORD *)v3 + (a2 >> 5) + 2) ^= (v5 ^ a3 & 1) << (a2 & 0x1F);\n  return v5;\n}\n"], [4215667, "sub_405373", "__int64 __fastcall sub_405373(__int64 *a1, int a2)\n{\n  __int64 *v3; // [rsp+4h] [rbp-18h]\n  unsigned int v4; // [rsp+18h] [rbp-4h]\n\n  v3 = a1;\n  if ( !a1 )\n    v3 = &qword_60D360;\n  v4 = *((_DWORD *)v3 + 1);\n  *((_DWORD *)v3 + 1) = a2;\n  return v4;\n}\n"], [4215718, "sub_4053A6", "__int64 *__fastcall sub_4053A6(__int64 *a1, __int64 a2, __int64 a3)\n{\n  __int64 *result; // rax\n  __int64 *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = a1;\n  if ( !a1 )\n    v4 = &qword_60D360;\n  *(_DWORD *)v4 = 8;\n  if ( !a2 || !a3 )\n    abort();\n  v4[5] = a2;\n  result = v4;\n  v4[6] = a3;\n  return result;\n}\n"], [4215808, "sub_405400", "_QWORD *__fastcall sub_405400(_QWORD *a1, int a2)\n{\n  __int64 v3[7]; // [rsp+10h] [rbp-40h] BYREF\n\n  memset(v3, 0, sizeof(v3));\n  if ( a2 == 8 )\n    abort();\n  LODWORD(v3[0]) = a2;\n  *a1 = v3[0];\n  a1[1] = v3[1];\n  a1[2] = v3[2];\n  a1[3] = v3[3];\n  a1[4] = v3[4];\n  a1[5] = v3[5];\n  a1[6] = v3[6];\n  return a1;\n}\n"], [4215928, "sub_405478", "char *__fastcall sub_405478(const char *a1, int a2)\n{\n  char *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = gettext(a1);\n  if ( v3 == a1 && a2 == 7 )\n    v3 = (char *)asc_40B0A0;\n  return v3;\n}\n"], [4215989, "sub_4054B5", "unsigned __int64 __fastcall sub_4054B5(__int64 a1, unsigned __int64 a2, __int64 a3, size_t a4, unsigned int a5, int a6, __int64 a7, char *a8, char *a9)\n{\n  int v9; // eax\n  bool v10; // al\n  int v11; // eax\n  char v20; // [rsp+65h] [rbp-6Bh]\n  bool v21; // [rsp+66h] [rbp-6Ah]\n  unsigned __int8 v22; // [rsp+67h] [rbp-69h]\n  char v23; // [rsp+68h] [rbp-68h]\n  char v24; // [rsp+69h] [rbp-67h]\n  bool v25; // [rsp+6Ah] [rbp-66h]\n  bool v26; // [rsp+6Bh] [rbp-65h]\n  wchar_t pwc; // [rsp+6Ch] [rbp-64h] BYREF\n  __int64 i; // [rsp+70h] [rbp-60h]\n  unsigned __int64 v29; // [rsp+78h] [rbp-58h]\n  char *s; // [rsp+80h] [rbp-50h]\n  size_t n; // [rsp+88h] [rbp-48h]\n  unsigned __int64 v32; // [rsp+90h] [rbp-40h]\n  unsigned __int64 j; // [rsp+98h] [rbp-38h]\n  size_t v34; // [rsp+A0h] [rbp-30h]\n  unsigned __int64 v35; // [rsp+A8h] [rbp-28h]\n  mbstate_t p; // [rsp+B0h] [rbp-20h] BYREF\n  unsigned __int64 v37; // [rsp+B8h] [rbp-18h]\n\n  v37 = __readfsqword(0x28u);\n  v29 = 0LL;\n  s = 0LL;\n  n = 0LL;\n  v20 = 0;\n  v26 = __ctype_get_mb_cur_max() == 1;\n  v21 = (a6 & 2) != 0;\n  if ( a5 == 3 )\n    goto LABEL_11;\n  if ( a5 > 3 )\n  {\n    if ( a5 == 5 )\n    {\n      v20 = 1;\n      v21 = 0;\n      goto LABEL_33;\n    }\n    if ( a5 >= 5 )\n    {\n      if ( a5 > 8 )\n        abort();\n      if ( a5 != 8 )\n      {\n        a8 = sub_405478((const char *)&asc_40B0A0[1], a5);\n        a9 = sub_405478((const char *)&asc_40B0A0[2], a5);\n      }\n      if ( (a6 & 2) == 0 )\n      {\n        for ( s = a8; *s; ++s )\n        {\n          if ( v29 < a2 )\n            *(_BYTE *)(v29 + a1) = *s;\n          ++v29;\n        }\n      }\n      v20 = 1;\n      s = a9;\n      n = strlen(a9);\n      goto LABEL_33;\n    }\n    a5 = 3;\n    v21 = 1;\nLABEL_11:\n    if ( !v21 )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(a1 + v29) = 34;\n      ++v29;\n    }\n    v20 = 1;\n    s = (char *)asc_40B0A0;\n    n = 1LL;\n    goto LABEL_33;\n  }\n  if ( a5 == 1 )\n  {\n    a5 = 2;\n    v21 = 1;\n    goto LABEL_27;\n  }\n  if ( a5 > 1 )\n  {\nLABEL_27:\n    if ( !v21 )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(a1 + v29) = 39;\n      ++v29;\n    }\n    s = (_BYTE *)(asc_40B0A0 + 4);\n    n = 1LL;\n    goto LABEL_33;\n  }\n  v21 = 0;\nLABEL_33:\n  for ( i = 0LL; a4 == -1LL ? *(_BYTE *)(a3 + i) != 0 : i != a4; ++i )\n  {\n    v24 = 0;\n    if ( v20 && n && i + n <= a4 && !memcmp((const void *)(a3 + i), s, n) )\n    {\n      if ( v21 )\n        return sub_4054B5(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n      v24 = 1;\n    }\n    v22 = *(_BYTE *)(a3 + i);\n    if ( v22 > 0x3Au )\n    {\n      if ( v22 == 94 )\n        goto LABEL_144;\n      if ( v22 > 0x5Eu )\n      {\n        if ( v22 <= 0x7Au )\n        {\n          if ( v22 >= 0x61u || v22 == 95 )\n            goto LABEL_206;\n          goto LABEL_144;\n        }\n        if ( v22 != 124 )\n        {\n          if ( v22 < 0x7Cu || v22 == 125 )\n          {\n            if ( a4 == -1LL )\n              v10 = *(_BYTE *)(a3 + 1) != 0;\n            else\n              v10 = a4 != 1;\n            if ( v10 )\n              goto LABEL_206;\n          }\n          else if ( v22 != 126 )\n          {\nLABEL_157:\n            if ( v26 )\n            {\n              v32 = 1LL;\n              v25 = ((*__ctype_b_loc())[v22] & 0x4000) != 0;\n            }\n            else\n            {\n              memset(&p, 0, sizeof(p));\n              v32 = 0LL;\n              v25 = 1;\n              if ( a4 == -1LL )\n                a4 = strlen((const char *)a3);\n              do\n              {\n                v34 = mbrtowc(&pwc, (const char *)(v32 + i + a3), a4 - (v32 + i), &p);\n                if ( !v34 )\n                  break;\n                if ( v34 == -1LL )\n                {\n                  v25 = 0;\n                  break;\n                }\n                if ( v34 == -2LL )\n                {\n                  v25 = 0;\n                  while ( i + v32 < a4 && *(_BYTE *)(v32 + i + a3) )\n                    ++v32;\n                  break;\n                }\n                if ( v21 && a5 == 2 )\n                {\n                  for ( j = 1LL; j < v34; ++j )\n                  {\n                    v11 = *(char *)(j + v32 + i + a3);\n                    if ( v11 == 94 )\n                      return sub_4054B5(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    if ( v11 > 94 )\n                    {\n                      if ( v11 == 96 || v11 == 124 )\n                        return sub_4054B5(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    }\n                    else if ( (unsigned int)(v11 - 91) <= 1 )\n                    {\n                      return sub_4054B5(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    }\n                  }\n                }\n                if ( !iswprint(pwc) )\n                  v25 = 0;\n                v32 += v34;\n              }\n              while ( !mbsinit(&p) );\n            }\n            if ( v32 > 1 || v20 && !v25 )\n            {\n              v35 = i + v32;\n              while ( 1 )\n              {\n                if ( v20 && !v25 )\n                {\n                  if ( v21 )\n                    return sub_4054B5(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                  if ( v29 < a2 )\n                    *(_BYTE *)(a1 + v29) = 92;\n                  if ( ++v29 < a2 )\n                    *(_BYTE *)(v29 + a1) = (v22 >> 6) + 48;\n                  if ( ++v29 < a2 )\n                    *(_BYTE *)(v29 + a1) = ((v22 >> 3) & 7) + 48;\n                  ++v29;\n                  v22 = (v22 & 7) + 48;\n                }\n                else if ( v24 )\n                {\n                  if ( v29 < a2 )\n                    *(_BYTE *)(a1 + v29) = 92;\n                  ++v29;\n                  v24 = 0;\n                }\n                if ( i + 1 >= v35 )\n                  break;\n                if ( v29 < a2 )\n                  *(_BYTE *)(v29 + a1) = v22;\n                ++v29;\n                ++i;\n                v22 = *(_BYTE *)(a3 + i);\n              }\n              goto LABEL_215;\n            }\n            goto LABEL_206;\n          }\n          goto LABEL_143;\n        }\nLABEL_144:\n        if ( a5 == 2 && v21 )\n          return sub_4054B5(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        goto LABEL_206;\n      }\n      if ( v22 > 0x5Au )\n      {\n        if ( v22 == 92 )\n        {\n          v23 = *(_BYTE *)(a3 + i);\n          if ( v20 && v21 && n )\n            goto LABEL_215;\n          goto LABEL_134;\n        }\n        if ( v22 <= 0x5Cu )\n          goto LABEL_144;\n      }\n      else\n      {\n        if ( v22 >= 0x41u )\n          goto LABEL_206;\n        if ( v22 <= 0x3Eu )\n          goto LABEL_144;\n        if ( v22 != 63 )\n          goto LABEL_157;\n        if ( a5 == 2 )\n        {\n          if ( v21 )\n            return sub_4054B5(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        }\n        else if ( a5 == 3 && (a6 & 4) != 0 && i + 2 < a4 && *(_BYTE *)(i + 1 + a3) == 63 )\n        {\n          v9 = *(char *)(i + 2 + a3);\n          if ( v9 != 45 )\n          {\n            if ( v9 > 45 )\n            {\n              if ( v9 != 47 && (v9 < 47 || (unsigned int)(v9 - 60) > 2) )\n                goto LABEL_206;\n            }\n            else if ( v9 != 33 && (v9 < 33 || (unsigned int)(v9 - 39) > 2) )\n            {\n              goto LABEL_206;\n            }\n          }\n          if ( v21 )\n            return sub_4054B5(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          v22 = *(_BYTE *)(i + 2 + a3);\n          i += 2LL;\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 63;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 34;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 34;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 63;\n          ++v29;\n        }\n      }\n    }\n    else\n    {\n      if ( v22 >= 0x2Bu )\n        goto LABEL_206;\n      if ( v22 > 0x22u )\n      {\n        if ( v22 != 38 )\n        {\n          if ( v22 > 0x26u )\n          {\n            if ( v22 == 39 )\n            {\n              if ( a5 == 2 )\n              {\n                if ( v21 )\n                  return sub_4054B5(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                if ( v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 39;\n                if ( ++v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 92;\n                if ( ++v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 39;\n                ++v29;\n              }\n              goto LABEL_206;\n            }\n            goto LABEL_144;\n          }\n          if ( v22 != 36 )\n          {\n            if ( v22 > 0x24u )\n              goto LABEL_206;\nLABEL_143:\n            if ( i )\n              goto LABEL_206;\n          }\n        }\n        goto LABEL_144;\n      }\n      if ( v22 >= 0x20u )\n        goto LABEL_144;\n      if ( v22 == 9 )\n      {\n        v23 = 116;\n        goto LABEL_134;\n      }\n      if ( v22 > 9u )\n      {\n        if ( v22 == 11 )\n        {\n          v23 = 118;\n        }\n        else\n        {\n          if ( v22 < 0xBu )\n          {\n            v23 = 110;\n            goto LABEL_134;\n          }\n          if ( v22 == 12 )\n          {\n            v23 = 102;\n          }\n          else\n          {\n            if ( v22 != 13 )\n              goto LABEL_157;\n            v23 = 114;\nLABEL_134:\n            if ( a5 == 2 && v21 )\n              return sub_4054B5(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          }\n        }\nLABEL_136:\n        if ( v20 )\n        {\n          v22 = v23;\nLABEL_211:\n          if ( v21 )\n            return sub_4054B5(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 92;\n          ++v29;\n          goto LABEL_215;\n        }\n        goto LABEL_206;\n      }\n      if ( v22 == 7 )\n      {\n        v23 = 97;\n        goto LABEL_136;\n      }\n      if ( v22 > 7u )\n      {\n        v23 = 98;\n        goto LABEL_136;\n      }\n      if ( v22 )\n        goto LABEL_157;\n      if ( v20 )\n      {\n        if ( v21 )\n          return sub_4054B5(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        if ( v29 < a2 )\n          *(_BYTE *)(a1 + v29) = 92;\n        ++v29;\n        if ( i + 1 < a4 && *(char *)(i + 1 + a3) > 47 && *(char *)(i + 1 + a3) <= 57 )\n        {\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 48;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 48;\n          ++v29;\n        }\n        v22 = 48;\n      }\n      else if ( (a6 & 1) != 0 )\n      {\n        continue;\n      }\n    }\nLABEL_206:\n    if ( (v20 == 1 || v21) && a7 && (*(_DWORD *)(4LL * (v22 >> 5) + a7) & (1 << (v22 & 0x1F))) != 0 || v24 == 1 )\n      goto LABEL_211;\nLABEL_215:\n    if ( v29 < a2 )\n      *(_BYTE *)(v29 + a1) = v22;\n    ++v29;\n  }\n  if ( !v29 && a5 == 2 && v21 )\n    return sub_4054B5(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n  if ( s && !v21 )\n  {\n    while ( *s )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(v29 + a1) = *s;\n      ++v29;\n      ++s;\n    }\n  }\n  if ( v29 < a2 )\n    *(_BYTE *)(a1 + v29) = 0;\n  return v29;\n}\n"], [4219136, "sub_406100", "unsigned __int64 __fastcall sub_406100(__int64 a1, unsigned __int64 a2, __int64 a3, size_t a4, __int64 *a5)\n{\n  __int64 *v5; // rax\n  int v9; // [rsp+4Ch] [rbp-14h]\n  __int64 *v10; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+58h] [rbp-8h]\n\n  if ( a5 )\n    v5 = a5;\n  else\n    v5 = &qword_60D360;\n  v10 = v5;\n  v9 = *__errno_location();\n  v11 = sub_4054B5(\n          a1,\n          a2,\n          a3,\n          a4,\n          *(_DWORD *)v10,\n          *((_DWORD *)v10 + 1),\n          (__int64)(v10 + 1),\n          (char *)v10[5],\n          (char *)v10[6]);\n  *__errno_location() = v9;\n  return v11;\n}\n"], [4219296, "sub_4061A0", "__int64 __fastcall sub_4061A0(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_4061D2(a1, a2, 0LL, a3);\n}\n"], [4219346, "sub_4061D2", "__int64 __fastcall sub_4061D2(__int64 a1, size_t a2, _QWORD *a3, __int64 *a4)\n{\n  __int64 *v4; // rax\n  int v7; // [rsp+40h] [rbp-20h]\n  int v8; // [rsp+44h] [rbp-1Ch]\n  __int64 *v9; // [rsp+48h] [rbp-18h]\n  unsigned __int64 v10; // [rsp+50h] [rbp-10h]\n  __int64 v11; // [rsp+58h] [rbp-8h]\n\n  if ( a4 )\n    v4 = a4;\n  else\n    v4 = &qword_60D360;\n  v9 = v4;\n  v7 = *__errno_location();\n  v8 = *((_DWORD *)v9 + 1) | (a3 == 0LL);\n  v10 = sub_4054B5(0LL, 0LL, a1, a2, *(_DWORD *)v9, v8, (__int64)(v9 + 1), (char *)v9[5], (char *)v9[6]) + 1;\n  v11 = sub_408A94(v10);\n  sub_4054B5(v11, v10, a1, a2, *(_DWORD *)v9, v8, (__int64)(v9 + 1), (char *)v9[5], (char *)v9[6]);\n  *__errno_location() = v7;\n  if ( a3 )\n    *a3 = v10 - 1;\n  return v11;\n}\n"], [4219646, "sub_4062FE", "void sub_4062FE()\n{\n  unsigned int i; // [rsp+4h] [rbp-Ch]\n  void **ptr; // [rsp+8h] [rbp-8h]\n\n  ptr = (void **)off_60D2C0;\n  for ( i = 1; i < dword_60D2A0; ++i )\n    free(ptr[2 * i + 1]);\n  if ( ptr[1] != &unk_60D3A0 )\n  {\n    free(ptr[1]);\n    qword_60D2B0 = 256LL;\n    off_60D2B8 = &unk_60D3A0;\n  }\n  if ( ptr != (void **)&qword_60D2B0 )\n  {\n    free(ptr);\n    off_60D2C0 = (__int64)&qword_60D2B0;\n  }\n  dword_60D2A0 = 1;\n}\n"], [4219817, "sub_4063A9", "void *__fastcall sub_4063A9(int a1, __int64 a2, size_t a3, __int64 a4)\n{\n  __int64 v4; // rax\n  void *v5; // rdx\n  bool v9; // [rsp+4Bh] [rbp-45h]\n  int v10; // [rsp+4Ch] [rbp-44h]\n  int v11; // [rsp+54h] [rbp-3Ch]\n  _QWORD *v12; // [rsp+58h] [rbp-38h]\n  void *ptr; // [rsp+60h] [rbp-30h]\n  __int64 v14; // [rsp+68h] [rbp-28h]\n  unsigned __int64 v15; // [rsp+70h] [rbp-20h]\n  unsigned __int64 v16; // [rsp+70h] [rbp-20h]\n  unsigned __int64 v17; // [rsp+78h] [rbp-18h]\n\n  v10 = *__errno_location();\n  v12 = (_QWORD *)off_60D2C0;\n  if ( a1 < 0 )\n    abort();\n  if ( dword_60D2A0 <= (unsigned int)a1 )\n  {\n    v14 = (unsigned int)(a1 + 1);\n    v9 = off_60D2C0 == (_QWORD)&qword_60D2B0;\n    if ( (__int64 *)off_60D2C0 == &qword_60D2B0 )\n      v4 = 0LL;\n    else\n      v4 = off_60D2C0;\n    v12 = (_QWORD *)sub_408AE3(v4, 16 * v14);\n    off_60D2C0 = (__int64)v12;\n    if ( v9 )\n    {\n      v5 = off_60D2B8;\n      *v12 = qword_60D2B0;\n      v12[1] = v5;\n    }\n    memset(&v12[2 * (unsigned int)dword_60D2A0], 0, 16 * (v14 - (unsigned int)dword_60D2A0));\n    dword_60D2A0 = a1 + 1;\n  }\n  v15 = v12[2 * a1];\n  ptr = (void *)v12[2 * a1 + 1];\n  v11 = *(_DWORD *)(a4 + 4) | 1;\n  v17 = sub_4054B5((__int64)ptr, v15, a2, a3, *(_DWORD *)a4, v11, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 48));\n  if ( v15 <= v17 )\n  {\n    v16 = v17 + 1;\n    v12[2 * a1] = v17 + 1;\n    if ( ptr != &unk_60D3A0 )\n      free(ptr);\n    ptr = (void *)sub_408A94(v16);\n    v12[2 * a1 + 1] = ptr;\n    sub_4054B5((__int64)ptr, v16, a2, a3, *(_DWORD *)a4, v11, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 48));\n  }\n  *__errno_location() = v10;\n  return ptr;\n}\n"], [4220463, "sub_40662F", "void *__fastcall sub_40662F(int a1, __int64 a2)\n{\n  return sub_4063A9(a1, a2, 0xFFFFFFFFFFFFFFFFLL, (__int64)&qword_60D360);\n}\n"], [4220506, "sub_40665A", "void *__fastcall sub_40665A(int a1, __int64 a2, size_t a3)\n{\n  return sub_4063A9(a1, a2, a3, (__int64)&qword_60D360);\n}\n"], [4220550, "sub_406686", "void *__fastcall sub_406686(__int64 a1)\n{\n  return sub_40662F(0, a1);\n}\n"], [4220581, "sub_4066A5", "void *__fastcall sub_4066A5(__int64 a1, size_t a2)\n{\n  return sub_40665A(0, a1, a2);\n}\n"], [4220620, "sub_4066CC", "void *__fastcall sub_4066CC(int a1, int a2, __int64 a3)\n{\n  _QWORD v5[8]; // [rsp+10h] [rbp-40h] BYREF\n\n  sub_405400(v5, a2);\n  return sub_4063A9(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)v5);\n}\n"], [4220685, "sub_40670D", "void *__fastcall sub_40670D(int a1, int a2, __int64 a3, size_t a4)\n{\n  _QWORD v7[8]; // [rsp+20h] [rbp-40h] BYREF\n\n  sub_405400(v7, a2);\n  return sub_4063A9(a1, a3, a4, (__int64)v7);\n}\n"], [4220748, "sub_40674C", "void *__fastcall sub_40674C(int a1, __int64 a2)\n{\n  return sub_4066CC(0, a1, a2);\n}\n"], [4220784, "sub_406770", "void *__fastcall sub_406770(int a1, __int64 a2, size_t a3)\n{\n  return sub_40670D(0, a1, a2, a3);\n}\n"], [4220828, "sub_40679C", "void *__fastcall sub_40679C(__int64 a1, size_t a2, unsigned __int8 a3)\n{\n  __int64 v4[8]; // [rsp+20h] [rbp-40h] BYREF\n\n  v4[0] = qword_60D360;\n  v4[1] = qword_60D368;\n  v4[2] = qword_60D370;\n  v4[3] = qword_60D378;\n  v4[4] = qword_60D380;\n  v4[5] = qword_60D388;\n  v4[6] = qword_60D390;\n  sub_4052EB(v4, a3, 1);\n  return sub_4063A9(0, a1, a2, (__int64)v4);\n}\n"], [4220976, "sub_406830", "void *__fastcall sub_406830(__int64 a1, unsigned __int8 a2)\n{\n  return sub_40679C(a1, 0xFFFFFFFFFFFFFFFFLL, a2);\n}\n"], [4221018, "sub_40685A", "void *__fastcall sub_40685A(__int64 a1)\n{\n  return sub_406830(a1, 0x3Au);\n}\n"], [4221049, "sub_406879", "void *__fastcall sub_406879(__int64 a1, size_t a2)\n{\n  return sub_40679C(a1, a2, 0x3Au);\n}\n"], [4221091, "sub_4068A3", "__int64 __fastcall sub_4068A3(unsigned int a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  return sub_4068D9(a1, a2, a3, a4, -1LL);\n}\n"], [4221145, "sub_4068D9", "void *__fastcall sub_4068D9(int a1, __int64 a2, __int64 a3, __int64 a4, size_t a5)\n{\n  __int64 v8[8]; // [rsp+30h] [rbp-40h] BYREF\n\n  v8[0] = qword_60D360;\n  v8[1] = qword_60D368;\n  v8[2] = qword_60D370;\n  v8[3] = qword_60D378;\n  v8[4] = qword_60D380;\n  v8[5] = qword_60D388;\n  v8[6] = qword_60D390;\n  sub_4053A6(v8, a2, a3);\n  return sub_4063A9(a1, a4, a5, (__int64)v8);\n}\n"], [4221296, "sub_406970", "__int64 __fastcall sub_406970(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_4068A3(0, a1, a2, a3);\n}\n"], [4221343, "sub_40699F", "void *__fastcall sub_40699F(__int64 a1, __int64 a2, __int64 a3, size_t a4)\n{\n  return sub_4068D9(0, a1, a2, a3, a4);\n}\n"], [4221401, "sub_4069D9", "_QWORD *__fastcall sub_4069D9(__int64 a1)\n{\n  _QWORD *result; // rax\n\n  result = (_QWORD *)sub_408AAE(24LL);\n  *result = a1;\n  result[2] = 0LL;\n  result[1] = result[2];\n  return result;\n}\n"], [4221472, "sub_406A20", "_QWORD *__fastcall sub_406A20(__int64 a1, __int64 a2)\n{\n  _QWORD *result; // rax\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_406FF3(a1, a2);\n  if ( v3 )\n    result = sub_4069D9(v3);\n  else\n    result = 0LL;\n  return result;\n}\n"], [4221539, "sub_406A63", "__int64 __fastcall sub_406A63(__int64 a1)\n{\n  return *(_QWORD *)a1;\n}\n"], [4221556, "sub_406A74", "__int64 __fastcall sub_406A74(__int64 a1)\n{\n  return a1 << 8;\n}\n"], [4221574, "sub_406A86", "unsigned __int64 __fastcall sub_406A86(__int64 *a1, unsigned __int64 a2)\n{\n  unsigned __int64 v3; // [rsp+10h] [rbp-70h]\n  unsigned __int64 v4; // [rsp+18h] [rbp-68h]\n  __int64 v5; // [rsp+20h] [rbp-60h]\n  __int64 v6; // [rsp+20h] [rbp-60h]\n  unsigned __int64 v7; // [rsp+28h] [rbp-58h]\n  __int64 v8; // [rsp+30h] [rbp-50h]\n  unsigned __int64 v9; // [rsp+38h] [rbp-48h]\n  unsigned __int64 v10; // [rsp+48h] [rbp-38h]\n  char v11[8]; // [rsp+60h] [rbp-20h] BYREF\n  unsigned __int64 v12; // [rsp+68h] [rbp-18h]\n\n  v12 = __readfsqword(0x28u);\n  v8 = *a1;\n  v3 = a1[1];\n  v4 = a1[2];\n  v9 = a2 + 1;\n  while ( 1 )\n  {\n    if ( v4 < a2 )\n    {\n      v5 = 0LL;\n      v7 = v4;\n      do\n      {\n        v7 = sub_406A74(v7) + 255;\n        ++v5;\n      }\n      while ( v7 < a2 );\n      sub_4072EC(v8, v11, v5);\n      v6 = 0LL;\n      do\n      {\n        v3 = (unsigned __int8)v11[v6] + sub_406A74(v3);\n        v4 = sub_406A74(v4) + 255;\n        ++v6;\n      }\n      while ( v4 < a2 );\n    }\n    if ( v4 == a2 )\n    {\n      a1[2] = 0LL;\n      a1[1] = a1[2];\n      return v3;\n    }\n    v10 = (v4 - a2) % v9;\n    if ( v3 <= v4 - v10 )\n      break;\n    v3 %= v9;\n    v4 = v10 - 1;\n  }\n  a1[1] = v3 / v9;\n  a1[2] = (v4 - a2) / v9;\n  return v3 % v9;\n}\n"], [4222057, "sub_406C69", "void __fastcall sub_406C69(void *a1)\n{\n  memset(a1, 0, 0x18uLL);\n  free(a1);\n}\n"], [4222105, "sub_406C99", "__int64 __fastcall sub_406C99(_QWORD *a1)\n{\n  unsigned int v2; // [rsp+18h] [rbp-8h]\n  int v3; // [rsp+1Ch] [rbp-4h]\n\n  v2 = sub_407342(*a1);\n  v3 = *__errno_location();\n  sub_406C69(a1);\n  *__errno_location() = v3;\n  return v2;\n}\n"], [4222172, "sub_406CDC", "void __fastcall __noreturn sub_406CDC(__int64 a1)\n{\n  void *v1; // r12\n  const char *v2; // rax\n  char *v3; // rbx\n  int *v4; // rax\n\n  if ( a1 )\n  {\n    v1 = sub_40685A(a1);\n    if ( *__errno_location() )\n      v2 = \"%s: read error\";\n    else\n      v2 = \"%s: end of file\";\n    v3 = gettext(v2);\n    v4 = __errno_location();\n    error(status, *v4, v3, v1);\n  }\n  abort();\n}\n"], [4222279, "sub_406D47", "_QWORD *__fastcall sub_406D47(__int64 a1, __int64 a2)\n{\n  _QWORD *result; // rax\n\n  result = (_QWORD *)sub_408AAE(4152LL);\n  *result = a1;\n  result[1] = sub_406CDC;\n  result[2] = a2;\n  return result;\n}\n"], [4222350, "sub_406D8E", "unsigned __int64 __fastcall sub_406D8E(char *a1, unsigned __int64 a2, size_t a3)\n{\n  size_t v3; // rax\n  __int64 v4; // rax\n  __int64 v5; // rax\n  __int64 v6; // rax\n  __int64 v7; // rax\n  unsigned __int64 result; // rax\n  __int64 v9; // rax\n  int fd; // [rsp+24h] [rbp-4Ch]\n  unsigned __int64 v12; // [rsp+28h] [rbp-48h]\n  size_t n; // [rsp+38h] [rbp-38h]\n  size_t v14; // [rsp+40h] [rbp-30h]\n  size_t v15; // [rsp+48h] [rbp-28h]\n  size_t v16; // [rsp+50h] [rbp-20h]\n  size_t v17; // [rsp+58h] [rbp-18h]\n  struct timeval tv; // [rsp+60h] [rbp-10h] BYREF\n\n  v12 = 0LL;\n  fd = open(\"/dev/urandom\", 0);\n  if ( fd >= 0 )\n  {\n    v3 = a2;\n    if ( a3 <= a2 )\n      v3 = a3;\n    v12 = read(fd, a1, v3);\n    if ( (v12 & 0x8000000000000000LL) != 0LL )\n      v12 = 0LL;\n    close(fd);\n  }\n  if ( v12 < a2 )\n  {\n    v4 = a2 - v12;\n    if ( a2 - v12 > 0x10 )\n      v4 = 16LL;\n    n = v4;\n    gettimeofday(&tv, 0LL);\n    memcpy(&a1[v12], &tv, n);\n    v12 += n;\n  }\n  if ( v12 < a2 )\n  {\n    v5 = a2 - v12;\n    if ( a2 - v12 > 4 )\n      v5 = 4LL;\n    v14 = v5;\n    LODWORD(tv.tv_sec) = getpid();\n    memcpy(&a1[v12], &tv, v14);\n    v12 += v14;\n  }\n  if ( v12 < a2 )\n  {\n    v6 = a2 - v12;\n    if ( a2 - v12 > 4 )\n      v6 = 4LL;\n    v15 = v6;\n    LODWORD(tv.tv_sec) = getppid();\n    memcpy(&a1[v12], &tv, v15);\n    v12 += v15;\n  }\n  if ( v12 < a2 )\n  {\n    v7 = a2 - v12;\n    if ( a2 - v12 > 4 )\n      v7 = 4LL;\n    v16 = v7;\n    LODWORD(tv.tv_sec) = getuid();\n    memcpy(&a1[v12], &tv, v16);\n    v12 += v16;\n  }\n  result = v12;\n  if ( v12 < a2 )\n  {\n    v9 = a2 - v12;\n    if ( a2 - v12 > 4 )\n      v9 = 4LL;\n    v17 = v9;\n    LODWORD(tv.tv_sec) = getgid();\n    memcpy(&a1[v12], &tv, v17);\n    result = v12 + v17;\n  }\n  return result;\n}\n"], [4222963, "sub_406FF3", "char *__fastcall sub_406FF3(__int64 a1, size_t a2)\n{\n  size_t v3; // rax\n  FILE *stream; // [rsp+10h] [rbp-10h]\n  char *v5; // [rsp+18h] [rbp-8h]\n\n  if ( !a2 )\n    return (char *)sub_406D47(0LL, 0LL);\n  stream = 0LL;\n  if ( a1 )\n  {\n    stream = (FILE *)sub_409AAD(a1, \"rb\");\n    if ( !stream )\n      return 0LL;\n  }\n  v5 = (char *)sub_406D47((__int64)stream, a1);\n  if ( stream )\n  {\n    v3 = 4096LL;\n    if ( a2 <= 0x1000 )\n      v3 = a2;\n    setvbuf(stream, v5 + 24, 0, v3);\n  }\n  else\n  {\n    *((_QWORD *)v5 + 3) = 0LL;\n    sub_406D8E(v5 + 32, 0x800uLL, a2);\n    sub_407B40(v5 + 32);\n  }\n  return v5;\n}\n"], [4223202, "sub_4070E2", "__int64 __fastcall sub_4070E2(__int64 a1, __int64 a2)\n{\n  __int64 result; // rax\n\n  result = a1;\n  *(_QWORD *)(a1 + 8) = a2;\n  return result;\n}\n"], [4223228, "sub_4070FC", "__int64 __fastcall sub_4070FC(__int64 a1, __int64 a2)\n{\n  __int64 result; // rax\n\n  result = a1;\n  *(_QWORD *)(a1 + 16) = a2;\n  return result;\n}\n"], [4223254, "sub_407116", "size_t __fastcall sub_407116(__int64 a1, char *a2, size_t a3)\n{\n  size_t result; // rax\n  int *v4; // rbx\n  int v5; // eax\n  int v8; // [rsp+24h] [rbp-1Ch]\n  size_t v9; // [rsp+28h] [rbp-18h]\n\n  while ( 1 )\n  {\n    v9 = fread_unlocked(a2, 1uLL, a3, *(FILE **)a1);\n    v8 = *__errno_location();\n    a2 += v9;\n    result = v9;\n    a3 -= v9;\n    if ( !a3 )\n      break;\n    v4 = __errno_location();\n    if ( ferror_unlocked(*(FILE **)a1) )\n      v5 = v8;\n    else\n      v5 = 0;\n    *v4 = v5;\n    (*(void (__fastcall **)(_QWORD))(a1 + 8))(*(_QWORD *)(a1 + 16));\n  }\n  return result;\n}\n"], [4223414, "sub_4071B6", "size_t *__fastcall sub_4071B6(size_t *a1, char *a2, size_t a3)\n{\n  size_t *result; // rax\n  size_t i; // [rsp+20h] [rbp-10h]\n  char *v7; // [rsp+28h] [rbp-8h]\n\n  for ( i = *a1; a3 > i; i = 2048LL )\n  {\n    memcpy(a2, (char *)a1 + 2048 - i + 2080, i);\n    a2 += i;\n    a3 -= i;\n    if ( ((unsigned __int8)a2 & 7) == 0 )\n    {\n      v7 = a2;\n      while ( a3 > 0x7FF )\n      {\n        sub_4073D8(a1 + 1, v7);\n        v7 += 2048;\n        a3 -= 2048LL;\n        if ( !a3 )\n        {\n          result = a1;\n          *a1 = 0LL;\n          return result;\n        }\n      }\n      a2 = v7;\n    }\n    sub_4073D8(a1 + 1, a1 + 260);\n  }\n  memcpy(a2, (char *)a1 + 2048 - i + 2080, a3);\n  result = a1;\n  *a1 = i - a3;\n  return result;\n}\n"], [4223724, "sub_4072EC", "size_t __fastcall sub_4072EC(_QWORD *a1, char *a2, size_t a3)\n{\n  size_t result; // rax\n\n  if ( *a1 )\n    result = sub_407116((__int64)a1, a2, a3);\n  else\n    result = (size_t)sub_4071B6(a1 + 3, a2, a3);\n  return result;\n}\n"], [4223810, "sub_407342", "__int64 __fastcall sub_407342(__int64 *a1)\n{\n  __int64 result; // rax\n  __int64 v2; // [rsp+18h] [rbp-8h]\n\n  v2 = *a1;\n  memset(a1, 0, 0x1038uLL);\n  free(a1);\n  if ( v2 )\n    result = sub_409171(v2);\n  else\n    result = 0LL;\n  return result;\n}\n"], [4223895, "sub_407397", "__int64 __fastcall sub_407397(__int64 a1)\n{\n  return a1;\n}\n"], [4223924, "sub_4073B4", "__int64 __fastcall sub_4073B4(__int64 a1, __int16 a2)\n{\n  return *(_QWORD *)((a2 & 0x7F8) + a1);\n}\n"], [4223960, "sub_4073D8", "__int64 *__fastcall sub_4073D8(__int64 *a1, __int64 *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rax\n  __int64 v4; // rax\n  __int64 v5; // rax\n  __int64 v6; // rax\n  __int64 v7; // rax\n  __int64 v8; // rax\n  __int64 v9; // rax\n  __int64 v10; // rax\n  __int64 v11; // rax\n  __int64 v12; // rax\n  __int64 v13; // rax\n  __int64 v14; // rax\n  __int64 v15; // rax\n  __int64 v16; // rax\n  __int64 *result; // rax\n  unsigned __int64 v18; // [rsp+10h] [rbp-A8h]\n  __int64 v19; // [rsp+10h] [rbp-A8h]\n  unsigned __int64 v20; // [rsp+10h] [rbp-A8h]\n  __int64 v21; // [rsp+10h] [rbp-A8h]\n  __int64 v22; // [rsp+10h] [rbp-A8h]\n  unsigned __int64 v23; // [rsp+10h] [rbp-A8h]\n  __int64 v24; // [rsp+10h] [rbp-A8h]\n  __int64 v25; // [rsp+18h] [rbp-A0h]\n  __int64 v26; // [rsp+18h] [rbp-A0h]\n  __int64 v27; // [rsp+18h] [rbp-A0h]\n  __int64 v28; // [rsp+18h] [rbp-A0h]\n  __int64 v29; // [rsp+18h] [rbp-A0h]\n  __int64 v30; // [rsp+18h] [rbp-A0h]\n  __int64 v31; // [rsp+18h] [rbp-A0h]\n  __int64 *v32; // [rsp+20h] [rbp-98h]\n  __int64 v34; // [rsp+30h] [rbp-88h]\n  __int64 v35; // [rsp+38h] [rbp-80h]\n  __int64 v36; // [rsp+40h] [rbp-78h]\n  __int64 v37; // [rsp+50h] [rbp-68h]\n  __int64 v38; // [rsp+60h] [rbp-58h]\n  __int64 v39; // [rsp+70h] [rbp-48h]\n  __int64 v40; // [rsp+78h] [rbp-40h]\n  __int64 v41; // [rsp+80h] [rbp-38h]\n  __int64 v42; // [rsp+90h] [rbp-28h]\n  __int64 v43; // [rsp+A0h] [rbp-18h]\n\n  v18 = a1[256];\n  v2 = a1[257];\n  ++a1[258];\n  v25 = v2 + a1[258];\n  v32 = a1;\n  do\n  {\n    v19 = v32[128] - (v18 ^ (v18 << 21)) - 1;\n    v34 = *v32;\n    v35 = sub_4073B4((__int64)a1, *v32) + v19 + v25;\n    *v32 = v35;\n    v3 = sub_4073B4((__int64)a1, (unsigned int)v35 >> 8);\n    v26 = sub_407397(v34 + v3);\n    *a2 = v26;\n    v20 = (v19 ^ ((unsigned __int64)sub_407397(v19) >> 5)) + v32[129];\n    v36 = v32[1];\n    v4 = sub_4073B4((__int64)a1, v36);\n    v32[1] = v4 + v20 + v26;\n    v5 = sub_4073B4((__int64)a1, (unsigned int)(v4 + v20 + v26) >> 8);\n    v27 = sub_407397(v36 + v5);\n    a2[1] = v27;\n    v21 = (v20 ^ (v20 << 12)) + v32[130];\n    v37 = v32[2];\n    v6 = sub_4073B4((__int64)a1, v37);\n    v32[2] = v6 + v21 + v27;\n    v7 = sub_4073B4((__int64)a1, (unsigned int)(v6 + v21 + v27) >> 8);\n    v28 = sub_407397(v37 + v7);\n    a2[2] = v28;\n    v18 = (v21 ^ ((unsigned __int64)sub_407397(v21) >> 33)) + v32[131];\n    v38 = v32[3];\n    v8 = sub_4073B4((__int64)a1, v38);\n    v32[3] = v8 + v18 + v28;\n    v9 = sub_4073B4((__int64)a1, (unsigned int)(v8 + v18 + v28) >> 8);\n    v25 = sub_407397(v38 + v9);\n    a2[3] = v25;\n    a2 += 4;\n    v32 += 4;\n  }\n  while ( v32 < a1 + 128 );\n  do\n  {\n    v22 = *(v32 - 128) - (v18 ^ (v18 << 21)) - 1;\n    v39 = *v32;\n    v40 = sub_4073B4((__int64)a1, *v32) + v22 + v25;\n    *v32 = v40;\n    v10 = sub_4073B4((__int64)a1, (unsigned int)v40 >> 8);\n    v29 = sub_407397(v39 + v10);\n    *a2 = v29;\n    v23 = (v22 ^ ((unsigned __int64)sub_407397(v22) >> 5)) + *(v32 - 127);\n    v41 = v32[1];\n    v11 = sub_4073B4((__int64)a1, v41);\n    v32[1] = v11 + v23 + v29;\n    v12 = sub_4073B4((__int64)a1, (unsigned int)(v11 + v23 + v29) >> 8);\n    v30 = sub_407397(v41 + v12);\n    a2[1] = v30;\n    v24 = (v23 ^ (v23 << 12)) + *(v32 - 126);\n    v42 = v32[2];\n    v13 = sub_4073B4((__int64)a1, v42);\n    v32[2] = v13 + v24 + v30;\n    v14 = sub_4073B4((__int64)a1, (unsigned int)(v13 + v24 + v30) >> 8);\n    v31 = sub_407397(v42 + v14);\n    a2[2] = v31;\n    v18 = (v24 ^ ((unsigned __int64)sub_407397(v24) >> 33)) + *(v32 - 125);\n    v43 = v32[3];\n    v15 = sub_4073B4((__int64)a1, v43);\n    v32[3] = v15 + v18 + v31;\n    v16 = sub_4073B4((__int64)a1, (unsigned int)(v15 + v18 + v31) >> 8);\n    v25 = sub_407397(v43 + v16);\n    a2[3] = v25;\n    a2 += 4;\n    v32 += 4;\n  }\n  while ( v32 < a1 + 256 );\n  a1[256] = v18;\n  result = a1;\n  a1[257] = v25;\n  return result;\n}\n"], [4225856, "sub_407B40", "_QWORD *__fastcall sub_407B40(_QWORD *a1)\n{\n  _QWORD *result; // rax\n  int i; // [rsp+10h] [rbp-48h]\n  int j; // [rsp+14h] [rbp-44h]\n  __int64 v4; // [rsp+18h] [rbp-40h]\n  unsigned __int64 v5; // [rsp+18h] [rbp-40h]\n  unsigned __int64 v6; // [rsp+18h] [rbp-40h]\n  unsigned __int64 v7; // [rsp+18h] [rbp-40h]\n  unsigned __int64 v8; // [rsp+18h] [rbp-40h]\n  unsigned __int64 v9; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v10; // [rsp+20h] [rbp-38h]\n  __int64 v11; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v12; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v13; // [rsp+20h] [rbp-38h]\n  __int64 v14; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v15; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v16; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v17; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v18; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v19; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v20; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v21; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v22; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v23; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v24; // [rsp+30h] [rbp-28h]\n  __int64 v25; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v26; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v27; // [rsp+30h] [rbp-28h]\n  __int64 v28; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v29; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v30; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v31; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v32; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v33; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v34; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v35; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v36; // [rsp+38h] [rbp-20h]\n  __int64 v37; // [rsp+40h] [rbp-18h]\n  __int64 v38; // [rsp+40h] [rbp-18h]\n  unsigned __int64 v39; // [rsp+40h] [rbp-18h]\n  __int64 v40; // [rsp+40h] [rbp-18h]\n  __int64 v41; // [rsp+40h] [rbp-18h]\n  unsigned __int64 v42; // [rsp+40h] [rbp-18h]\n  __int64 v43; // [rsp+40h] [rbp-18h]\n  unsigned __int64 v44; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v45; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v46; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v47; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v48; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v49; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v50; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v51; // [rsp+50h] [rbp-8h]\n  __int64 v52; // [rsp+50h] [rbp-8h]\n  unsigned __int64 v53; // [rsp+50h] [rbp-8h]\n  unsigned __int64 v54; // [rsp+50h] [rbp-8h]\n  __int64 v55; // [rsp+50h] [rbp-8h]\n  unsigned __int64 v56; // [rsp+50h] [rbp-8h]\n  unsigned __int64 v57; // [rsp+50h] [rbp-8h]\n\n  v4 = 0x647C4677A2884B7CLL;\n  v9 = 0xB9F8B322C73AC862LL;\n  v16 = 0x8C0EA5053D4712A0LL;\n  v23 = 0xB29B2E824A595524LL;\n  v30 = 0x82F053DB8355E0CELL;\n  v37 = 0x48FE4A0FA5A09315LL;\n  v44 = 0xAE985BF2CBFC89EDLL;\n  v51 = 0x98F5704F6C44C0ABLL;\n  for ( i = 0; i <= 255; i += 8 )\n  {\n    v10 = a1[i + 1] + v9;\n    v17 = a1[i + 2] + v16;\n    v24 = a1[i + 3] + v23;\n    v31 = a1[i + 4] + v30;\n    v38 = a1[i + 5] + v37;\n    v45 = a1[i + 6] + v44;\n    v52 = a1[i + 7] + v51;\n    v5 = a1[i] + v4 - v31;\n    v39 = ((unsigned __int64)sub_407397(v52) >> 9) ^ v38;\n    v53 = v5 + v52;\n    v11 = v10 - v39;\n    v46 = (v5 << 9) ^ v45;\n    v6 = v11 + v5;\n    v18 = v17 - v46;\n    v54 = ((unsigned __int64)sub_407397(v11) >> 23) ^ v53;\n    v12 = v18 + v11;\n    v25 = v24 - v54;\n    v4 = (v18 << 15) ^ v6;\n    v19 = v25 + v18;\n    v32 = v31 - v4;\n    v9 = ((unsigned __int64)sub_407397(v25) >> 14) ^ v12;\n    v26 = v32 + v25;\n    v40 = v39 - v9;\n    v16 = (v32 << 20) ^ v19;\n    v33 = v40 + v32;\n    v47 = v46 - v16;\n    v23 = ((unsigned __int64)sub_407397(v40) >> 17) ^ v26;\n    v37 = v47 + v40;\n    v51 = v54 - v23;\n    v30 = (v47 << 14) ^ v33;\n    v44 = v51 + v47;\n    a1[i] = v4;\n    a1[i + 1] = v9;\n    a1[i + 2] = v16;\n    a1[i + 3] = v23;\n    a1[i + 4] = v30;\n    a1[i + 5] = v37;\n    a1[i + 6] = v44;\n    a1[i + 7] = v51;\n  }\n  for ( j = 0; j <= 255; j += 8 )\n  {\n    v13 = a1[j + 1] + v9;\n    v20 = a1[j + 2] + v16;\n    v27 = a1[j + 3] + v23;\n    v34 = a1[j + 4] + v30;\n    v41 = a1[j + 5] + v37;\n    v48 = a1[j + 6] + v44;\n    v55 = a1[j + 7] + v51;\n    v7 = a1[j] + v4 - v34;\n    v42 = ((unsigned __int64)sub_407397(v55) >> 9) ^ v41;\n    v56 = v7 + v55;\n    v14 = v13 - v42;\n    v49 = (v7 << 9) ^ v48;\n    v8 = v14 + v7;\n    v21 = v20 - v49;\n    v57 = ((unsigned __int64)sub_407397(v14) >> 23) ^ v56;\n    v15 = v21 + v14;\n    v28 = v27 - v57;\n    v4 = (v21 << 15) ^ v8;\n    v22 = v28 + v21;\n    v35 = v34 - v4;\n    v9 = ((unsigned __int64)sub_407397(v28) >> 14) ^ v15;\n    v29 = v35 + v28;\n    v43 = v42 - v9;\n    v16 = (v35 << 20) ^ v22;\n    v36 = v43 + v35;\n    v50 = v49 - v16;\n    v23 = ((unsigned __int64)sub_407397(v43) >> 17) ^ v29;\n    v37 = v50 + v43;\n    v51 = v57 - v23;\n    v30 = (v50 << 14) ^ v36;\n    v44 = v51 + v50;\n    a1[j] = v4;\n    a1[j + 1] = v9;\n    a1[j + 2] = v16;\n    a1[j + 3] = v23;\n    a1[j + 4] = v30;\n    a1[j + 5] = v37;\n    a1[j + 6] = v44;\n    a1[j + 7] = v51;\n  }\n  a1[258] = 0LL;\n  a1[257] = a1[258];\n  result = a1;\n  a1[256] = a1[257];\n  return result;\n}\n"], [4227271, "sub_4080C7", "__int64 __fastcall sub_4080C7(int a1)\n{\n  unsigned int fd; // [rsp+Ch] [rbp-14h]\n  unsigned int v3; // [rsp+18h] [rbp-8h]\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  fd = a1;\n  if ( a1 >= 0 && a1 <= 2 )\n  {\n    v3 = sub_409BD6((unsigned int)a1);\n    v4 = *__errno_location();\n    close(a1);\n    *__errno_location() = v4;\n    fd = v3;\n  }\n  return fd;\n}\n"], [4227348, "sub_408114", "int __fastcall sub_408114(FILE *a1, const char *a2, const char *a3, const char *a4, __int64 *a5, unsigned __int64 a6)\n{\n  char *v6; // rax\n  char *v7; // rax\n  __int64 v8; // rbx\n  char *v9; // rax\n  __int64 v10; // r12\n  __int64 v11; // rbx\n  char *v12; // rax\n  __int64 v13; // r13\n  __int64 v14; // r12\n  __int64 v15; // rbx\n  char *v16; // rax\n  int result; // eax\n  __int64 v18; // r14\n  __int64 v19; // r13\n  __int64 v20; // r12\n  __int64 v21; // rbx\n  char *v22; // rax\n  __int64 v23; // r13\n  __int64 v24; // r15\n  __int64 v25; // r14\n  __int64 v26; // r12\n  __int64 v27; // rbx\n  char *v28; // rax\n  __int64 v29; // r14\n  __int64 v30; // r13\n  __int64 v31; // r15\n  __int64 v32; // r12\n  __int64 v33; // rbx\n  char *v34; // rax\n  __int64 v35; // r15\n  __int64 v36; // r14\n  __int64 v37; // r13\n  __int64 v38; // r12\n  __int64 v39; // rbx\n  char *v40; // rax\n  __int64 v41; // r15\n  __int64 v42; // r14\n  __int64 v43; // r13\n  __int64 v44; // r12\n  __int64 v45; // rbx\n  char *v46; // rax\n  __int64 v47; // r15\n  __int64 v48; // r14\n  __int64 v49; // r13\n  __int64 v50; // r12\n  __int64 v51; // rbx\n  char *v52; // rax\n  __int64 v53; // [rsp+30h] [rbp-80h]\n  __int64 v54; // [rsp+38h] [rbp-78h]\n  __int64 v55; // [rsp+38h] [rbp-78h]\n  __int64 v56; // [rsp+40h] [rbp-70h]\n  __int64 v57; // [rsp+40h] [rbp-70h]\n  __int64 v58; // [rsp+40h] [rbp-70h]\n  __int64 v59; // [rsp+48h] [rbp-68h]\n  __int64 v60; // [rsp+48h] [rbp-68h]\n  __int64 v61; // [rsp+48h] [rbp-68h]\n  __int64 v62; // [rsp+48h] [rbp-68h]\n\n  if ( a2 )\n    fprintf(a1, \"%s (%s) %s\\n\", a2, a3, a4);\n  else\n    fprintf(a1, \"%s %s\\n\", a3, a4);\n  v6 = gettext(\"(C)\");\n  fprintf(a1, \"Copyright %s %d Free Software Foundation, Inc.\", v6, 2011LL);\n  v7 = gettext(\n         \"\\n\"\n         \"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n         \"\\n\");\n  fputs_unlocked(v7, a1);\n  if ( a6 == 4 )\n  {\n    v18 = a5[3];\n    v19 = a5[2];\n    v20 = a5[1];\n    v21 = *a5;\n    v22 = gettext(\"Written by %s, %s, %s,\\nand %s.\\n\");\n    result = fprintf(a1, v22, v21, v20, v19, v18);\n  }\n  else if ( a6 > 4 )\n  {\n    if ( a6 == 7 )\n    {\n      v35 = a5[6];\n      v36 = a5[5];\n      v37 = a5[4];\n      v60 = a5[3];\n      v56 = a5[2];\n      v38 = a5[1];\n      v39 = *a5;\n      v40 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\");\n      result = fprintf(a1, v40, v39, v38, v56, v60, v37, v36, v35);\n    }\n    else if ( a6 > 7 )\n    {\n      if ( a6 == 8 )\n      {\n        v61 = a5[7];\n        v41 = a5[6];\n        v42 = a5[5];\n        v43 = a5[4];\n        v57 = a5[3];\n        v54 = a5[2];\n        v44 = a5[1];\n        v45 = *a5;\n        v46 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\");\n        result = fprintf(a1, v46, v45, v44, v54, v57, v43, v42, v41, v61);\n      }\n      else\n      {\n        v62 = a5[8];\n        v58 = a5[7];\n        v47 = a5[6];\n        v48 = a5[5];\n        v49 = a5[4];\n        v55 = a5[3];\n        v53 = a5[2];\n        v50 = a5[1];\n        v51 = *a5;\n        if ( a6 == 9 )\n          v52 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\");\n        else\n          v52 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\");\n        result = fprintf(a1, v52, v51, v50, v53, v55, v49, v48, v47, v58, v62);\n      }\n    }\n    else if ( a6 == 5 )\n    {\n      v23 = a5[4];\n      v24 = a5[3];\n      v25 = a5[2];\n      v26 = a5[1];\n      v27 = *a5;\n      v28 = gettext(\"Written by %s, %s, %s,\\n%s, and %s.\\n\");\n      result = fprintf(a1, v28, v27, v26, v25, v24, v23);\n    }\n    else\n    {\n      v29 = a5[5];\n      v30 = a5[4];\n      v59 = a5[3];\n      v31 = a5[2];\n      v32 = a5[1];\n      v33 = *a5;\n      v34 = gettext(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\");\n      result = fprintf(a1, v34, v33, v32, v31, v59, v30, v29);\n    }\n  }\n  else\n  {\n    switch ( a6 )\n    {\n      case 1uLL:\n        v8 = *a5;\n        v9 = gettext(\"Written by %s.\\n\");\n        result = fprintf(a1, v9, v8);\n        break;\n      case 0uLL:\n        abort();\n      case 2uLL:\n        v10 = a5[1];\n        v11 = *a5;\n        v12 = gettext(\"Written by %s and %s.\\n\");\n        result = fprintf(a1, v12, v11, v10);\n        break;\n      default:\n        v13 = a5[2];\n        v14 = a5[1];\n        v15 = *a5;\n        v16 = gettext(\"Written by %s, %s, and %s.\\n\");\n        result = fprintf(a1, v16, v15, v14, v13);\n        break;\n    }\n  }\n  return result;\n}\n"], [4228863, "sub_4086FF", "int __fastcall sub_4086FF(FILE *a1, const char *a2, const char *a3, const char *a4, __int64 *a5)\n{\n  unsigned __int64 i; // [rsp+38h] [rbp-8h]\n\n  for ( i = 0LL; a5[i]; ++i )\n    ;\n  return sub_408114(a1, a2, a3, a4, a5, i);\n}\n"], [4228973, "sub_40876D", "int __fastcall sub_40876D(FILE *a1, const char *a2, const char *a3, const char *a4, unsigned int *a5)\n{\n  __int64 *v5; // rax\n  unsigned __int64 i; // [rsp+38h] [rbp-58h]\n  __int64 v8[10]; // [rsp+40h] [rbp-50h] BYREF\n\n  for ( i = 0LL; i <= 9; ++i )\n  {\n    if ( *a5 >= 0x30 )\n    {\n      v5 = (__int64 *)*((_QWORD *)a5 + 1);\n      *((_QWORD *)a5 + 1) = v5 + 1;\n    }\n    else\n    {\n      v5 = (__int64 *)(*((_QWORD *)a5 + 2) + *a5);\n      *a5 += 8;\n    }\n    v8[i] = *v5;\n    if ( !v8[i] )\n      break;\n  }\n  return sub_408114(a1, a2, a3, a4, v8, i);\n}\n"], [4229190, "sub_408846", "int sub_408846(FILE *a1, const char *a2, const char *a3, const char *a4, ...)\n{\n  gcc_va_list va; // [rsp+28h] [rbp-C8h] BYREF\n\n  va_start(va, a4);\n  return sub_40876D(a1, a2, a3, a4, (unsigned int *)va);\n}\n"], [4229372, "sub_4088FC", "int sub_4088FC()\n{\n  char *v0; // rax\n  char *v1; // rax\n  FILE *v2; // rbx\n  char *v3; // rax\n\n  v0 = gettext(\"\\nReport bugs to: %s\\n\");\n  printf(v0, \"bug-coreutils@gnu.org\");\n  v1 = gettext(\"%s home page: <%s>\\n\");\n  printf(v1, \"GNU coreutils\", \"http://www.gnu.org/software/coreutils/\");\n  v2 = stdout;\n  v3 = gettext(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\");\n  return fputs_unlocked(v3, v2);\n}\n"], [4229477, "sub_408965", "__int64 __fastcall sub_408965(unsigned __int64 a1, unsigned __int64 a2)\n{\n  if ( 0xFFFFFFFFFFFFFFFFLL / a2 < a1 )\n    sub_408C30(a1, a2, 0xFFFFFFFFFFFFFFFFLL % a2);\n  return sub_408AAE(a2 * a1);\n}\n"], [4229539, "sub_4089A3", "__int64 __fastcall sub_4089A3(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)\n{\n  unsigned __int64 v3; // rax\n  unsigned __int64 v4; // rdx\n\n  v3 = 0xFFFFFFFFFFFFFFFFLL / a3;\n  v4 = 0xFFFFFFFFFFFFFFFFLL % a3;\n  if ( v3 < a2 )\n    sub_408C30(a1, a2, v4);\n  return sub_408AE3(a1, a3 * a2);\n}\n"], [4229615, "sub_4089EF", "__int64 __fastcall sub_4089EF(__int64 a1, unsigned __int64 *a2, unsigned __int64 a3)\n{\n  unsigned __int64 v3; // rdx\n  unsigned __int64 v6; // [rsp+28h] [rbp-8h]\n\n  v6 = *a2;\n  if ( a1 )\n  {\n    v3 = 0xAAAAAAAAAAAAAAAALL % a3;\n    if ( 0xAAAAAAAAAAAAAAAALL / a3 <= v6 )\n      sub_408C30(a1, a2, v3);\n    v6 += (v6 + 1) >> 1;\n  }\n  else if ( !v6 )\n  {\n    v6 = (0x80 / a3 == 0) + 0x80 / a3;\n  }\n  *a2 = v6;\n  return sub_408AE3(a1, a3 * v6);\n}\n"], [4229780, "sub_408A94", "__int64 __fastcall sub_408A94(__int64 a1)\n{\n  return sub_408AAE(a1);\n}\n"], [4229806, "sub_408AAE", "void *__fastcall sub_408AAE(size_t a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  void *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = malloc(a1);\n  if ( !v4 && a1 )\n    sub_408C30(a1, a2, v2);\n  return v4;\n}\n"], [4229859, "sub_408AE3", "void *__fastcall sub_408AE3(void *a1, size_t a2)\n{\n  void *result; // rax\n  __int64 v3; // rdx\n  void *ptr; // [rsp+8h] [rbp-8h]\n\n  if ( a2 || !a1 )\n  {\n    ptr = realloc(a1, a2);\n    if ( !ptr )\n    {\n      if ( a2 )\n        sub_408C30(a1, a2, v3);\n    }\n    result = ptr;\n  }\n  else\n  {\n    free(a1);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4229956, "sub_408B44", "__int64 __fastcall sub_408B44(__int64 a1, unsigned __int64 *a2)\n{\n  return sub_4089EF(a1, a2, 1uLL);\n}\n"], [4229998, "sub_408B6E", "void *__fastcall sub_408B6E(size_t a1, __int64 a2)\n{\n  void *v2; // rax\n\n  v2 = sub_408AAE(a1, a2);\n  return memset(v2, 0, a1);\n}\n"], [4230041, "sub_408B99", "void *__fastcall sub_408B99(size_t a1, size_t a2)\n{\n  __int64 v2; // rdx\n  void *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = calloc(a1, a2);\n  if ( !v4 )\n    sub_408C30(a1, a2, v2);\n  return v4;\n}\n"], [4230098, "sub_408BD2", "void *__fastcall sub_408BD2(const void *a1, size_t a2)\n{\n  void *v2; // rax\n\n  v2 = sub_408AAE(a2, a2);\n  return memcpy(v2, a1, a2);\n}\n"], [4230147, "sub_408C03", "void *__fastcall sub_408C03(const char *a1)\n{\n  size_t v1; // rax\n\n  v1 = strlen(a1);\n  return sub_408BD2(a1, v1 + 1);\n}\n"], [4230192, "sub_408C30", "void __noreturn sub_408C30()\n{\n  char *v0; // rax\n\n  v0 = gettext(\"memory exhausted\");\n  error(status, 0, \"%s\", v0);\n  abort();\n}\n"], [4230245, "sub_408C65", "__int64 __fastcall sub_408C65(unsigned __int64 *a1, int a2)\n{\n  __int64 result; // rax\n\n  if ( 0xFFFFFFFFFFFFFFFFLL / a2 >= *a1 )\n  {\n    *a1 *= a2;\n    result = 0LL;\n  }\n  else\n  {\n    *a1 = -1LL;\n    result = 1LL;\n  }\n  return result;\n}\n"], [4230340, "sub_408CC4", "__int64 __fastcall sub_408CC4(unsigned __int64 *a1, int a2, int a3)\n{\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; a3--; i |= sub_408C65(a1, a2) )\n    ;\n  return i;\n}\n"], [4230405, "sub_408D05", "__int64 __fastcall sub_408D05(const char *a1, char **a2, int a3, uintmax_t *a4, const char *a5)\n{\n  char **v5; // rax\n  int v7; // eax\n  int v8; // eax\n  unsigned __int8 i; // [rsp+3Fh] [rbp-31h]\n  unsigned int v13; // [rsp+40h] [rbp-30h]\n  int v14; // [rsp+44h] [rbp-2Ch]\n  int v15; // [rsp+48h] [rbp-28h]\n  int v16; // [rsp+4Ch] [rbp-24h]\n  char v17; // [rsp+50h] [rbp-20h] BYREF\n  uintmax_t v18; // [rsp+58h] [rbp-18h] BYREF\n  unsigned __int8 *v19; // [rsp+60h] [rbp-10h]\n  char **endptr; // [rsp+68h] [rbp-8h]\n\n  v13 = 0;\n  if ( a3 < 0 || a3 > 36 )\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\", \"../../src/lib/xstrtol.c\", 0x53u, \"xstrtoumax\");\n  if ( a2 )\n    v5 = a2;\n  else\n    v5 = (char **)&v17;\n  endptr = v5;\n  v19 = (unsigned __int8 *)a1;\n  for ( i = *a1; ((*__ctype_b_loc())[i] & 0x2000) != 0; i = *v19 )\n    ++v19;\n  if ( i == 45 )\n    return 4LL;\n  *__errno_location() = 0;\n  v18 = strtoumax(a1, endptr, a3);\n  if ( *endptr == a1 )\n  {\n    if ( !a5 || !**endptr || !strchr(a5, **endptr) )\n      return 4LL;\n    v18 = 1LL;\n  }\n  else if ( *__errno_location() )\n  {\n    if ( *__errno_location() != 34 )\n      return 4LL;\n    v13 = 1;\n  }\n  if ( !a5 )\n  {\n    *a4 = v18;\n    return v13;\n  }\n  if ( !**endptr )\n    goto LABEL_76;\n  v14 = 1024;\n  v15 = 1;\n  if ( !strchr(a5, **endptr) )\n  {\n    *a4 = v18;\n    return v13 | 2;\n  }\n  if ( strchr(a5, 48) )\n  {\n    v7 = (*endptr)[1];\n    if ( v7 == 68 )\n      goto LABEL_35;\n    if ( v7 != 105 )\n    {\n      if ( v7 != 66 )\n        goto LABEL_36;\nLABEL_35:\n      v14 = 1000;\n      v15 = 2;\n      goto LABEL_36;\n    }\n    if ( (*endptr)[2] == 66 )\n      v15 = 3;\n  }\nLABEL_36:\n  v8 = **endptr;\n  if ( v8 != 89 )\n  {\n    if ( v8 > 89 )\n    {\n      if ( v8 == 103 )\n      {\nLABEL_65:\n        v16 = sub_408CC4(&v18, v14, 3);\n        goto LABEL_74;\n      }\n      if ( v8 <= 103 )\n      {\n        switch ( v8 )\n        {\n          case 'b':\n            v16 = sub_408C65(&v18, 512);\n            break;\n          case 'c':\n            v16 = 0;\n            break;\n          case 'Z':\n            v16 = sub_408CC4(&v18, v14, 7);\n            break;\n          default:\n            goto LABEL_73;\n        }\n        goto LABEL_74;\n      }\n      if ( v8 == 109 )\n        goto LABEL_67;\n      if ( v8 > 109 )\n      {\n        if ( v8 != 116 )\n        {\n          if ( v8 != 119 )\n            goto LABEL_73;\n          v16 = sub_408C65(&v18, 2);\n          goto LABEL_74;\n        }\nLABEL_69:\n        v16 = sub_408CC4(&v18, v14, 4);\n        goto LABEL_74;\n      }\n      if ( v8 != 107 )\n        goto LABEL_73;\n    }\n    else if ( v8 != 75 )\n    {\n      if ( v8 <= 75 )\n      {\n        if ( v8 == 69 )\n        {\n          v16 = sub_408CC4(&v18, v14, 6);\n          goto LABEL_74;\n        }\n        if ( v8 != 71 )\n        {\n          if ( v8 != 66 )\n          {\nLABEL_73:\n            *a4 = v18;\n            return v13 | 2;\n          }\n          v16 = sub_408C65(&v18, 1024);\n          goto LABEL_74;\n        }\n        goto LABEL_65;\n      }\n      if ( v8 == 80 )\n      {\n        v16 = sub_408CC4(&v18, v14, 5);\n        goto LABEL_74;\n      }\n      if ( v8 != 84 )\n      {\n        if ( v8 != 77 )\n          goto LABEL_73;\nLABEL_67:\n        v16 = sub_408CC4(&v18, v14, 2);\n        goto LABEL_74;\n      }\n      goto LABEL_69;\n    }\n    v16 = sub_408CC4(&v18, v14, 1);\n    goto LABEL_74;\n  }\n  v16 = sub_408CC4(&v18, v14, 8);\nLABEL_74:\n  v13 |= v16;\n  *endptr += v15;\n  if ( **endptr )\n    v13 |= 2u;\nLABEL_76:\n  *a4 = v18;\n  return v13;\n}\n"], [4231537, "sub_409171", "int __fastcall sub_409171(FILE *a1)\n{\n  int v2; // eax\n  int v3; // [rsp+14h] [rbp-Ch]\n  int v4; // [rsp+18h] [rbp-8h]\n\n  v3 = 0;\n  if ( fileno(a1) < 0 )\n    return fclose(a1);\n  if ( !__freading(a1) || (v2 = fileno(a1), lseek(v2, 0LL, 1) != -1) )\n  {\n    if ( (unsigned int)sub_409513(a1) )\n      v3 = *__errno_location();\n  }\n  v4 = fclose(a1);\n  if ( v3 )\n  {\n    *__errno_location() = v3;\n    v4 = -1;\n  }\n  return v4;\n}\n"], [4231718, "sub_409226", "__int64 __fastcall sub_409226(int a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __m128 a7, __m128 a8, __m128 a9, __m128 a10, __m128 a11, __m128 a12, __m128 a13, __m128 a14)\n{\n  int v14; // ecx\n  int v15; // er8\n  int v16; // er9\n  int v18; // [rsp+10h] [rbp-E0h]\n  int v19; // [rsp+14h] [rbp-DCh]\n  int v20; // [rsp+18h] [rbp-D8h]\n  int v21; // [rsp+1Ch] [rbp-D4h]\n  __int64 v22; // [rsp+50h] [rbp-A0h]\n  __int64 v23; // [rsp+58h] [rbp-98h]\n  __int64 v24; // [rsp+60h] [rbp-90h]\n  __int64 v25; // [rsp+68h] [rbp-88h]\n  __m128 v26; // [rsp+70h] [rbp-80h]\n  __m128 v27; // [rsp+80h] [rbp-70h]\n  __m128 v28; // [rsp+90h] [rbp-60h]\n  __m128 v29; // [rsp+A0h] [rbp-50h]\n  __m128 v30; // [rsp+B0h] [rbp-40h]\n  __m128 v31; // [rsp+C0h] [rbp-30h]\n  __m128 v32; // [rsp+D0h] [rbp-20h]\n  __m128 v33; // [rsp+E0h] [rbp-10h]\n\n  v22 = a3;\n  v23 = a4;\n  v24 = a5;\n  v25 = a6;\n  v26 = a7;\n  v27 = a8;\n  v28 = a9;\n  v29 = a10;\n  v30 = a11;\n  v31 = a12;\n  v32 = a13;\n  v33 = a14;\n  if ( a2 != 1030 )\n    return (unsigned int)fcntl(a1, a2, v22);\n  v19 = v22;\n  if ( dword_60D4A0 < 0 )\n  {\n    v18 = sub_409226(a1, 0, v22, a4, a5, a6);\n  }\n  else\n  {\n    v18 = fcntl(a1, 1030, (unsigned int)v22);\n    if ( v18 < 0 && *__errno_location() == 22 )\n    {\n      v18 = sub_409226(a1, 0, v19, v14, v15, v16);\n      if ( v18 < 0 )\n        return (unsigned int)v18;\n      dword_60D4A0 = -1;\n    }\n    else\n    {\n      dword_60D4A0 = 1;\n    }\n  }\n  if ( v18 >= 0 && dword_60D4A0 == -1 )\n  {\n    v20 = fcntl(v18, 1);\n    if ( v20 < 0 || fcntl(v18, 2, v20 | 1u) == -1 )\n    {\n      v21 = *__errno_location();\n      close(v18);\n      *__errno_location() = v21;\n      v18 = -1;\n    }\n  }\n  return (unsigned int)v18;\n}\n"], [4232416, "sub_4094E0", "__int64 __fastcall sub_4094E0(_DWORD *a1)\n{\n  __int64 result; // rax\n\n  result = *a1 & 0x100;\n  if ( (_DWORD)result )\n    result = sub_40955E(a1, 0LL, 1LL);\n  return result;\n}\n"], [4232467, "sub_409513", "int __fastcall sub_409513(FILE *a1)\n{\n  if ( !a1 || !__freading(a1) )\n    return fflush(a1);\n  sub_4094E0(a1);\n  return fflush(a1);\n}\n"], [4232542, "sub_40955E", "int __fastcall sub_40955E(FILE *a1, __off_t a2, int a3)\n{\n  int v3; // eax\n  __off_t v6; // [rsp+28h] [rbp-8h]\n\n  if ( a1->_IO_read_end != a1->_IO_read_ptr || a1->_IO_write_ptr != a1->_IO_write_base || a1->_IO_save_base )\n    return fseeko(a1, a2, a3);\n  v3 = fileno(a1);\n  v6 = lseek(v3, a2, a3);\n  if ( v6 == -1 )\n    return -1;\n  a1->_flags &= 0xFFFFFFEF;\n  a1->_offset = v6;\n  return 0;\n}\n"], [4232726, "sub_409616", "void __noreturn sub_409616()\n{\n  sub_401DD0(1);\n}\n"], [4232742, "sub_409626", "__int64 __fastcall sub_409626(const char *a1, __int64 a2, __int64 a3, size_t a4)\n{\n  __int64 result; // rax\n  char v7; // [rsp+27h] [rbp-19h]\n  __int64 i; // [rsp+28h] [rbp-18h]\n  __int64 v9; // [rsp+30h] [rbp-10h]\n  size_t n; // [rsp+38h] [rbp-8h]\n\n  v9 = -1LL;\n  v7 = 0;\n  n = strlen(a1);\n  for ( i = 0LL; *(_QWORD *)(8 * i + a2); ++i )\n  {\n    if ( !strncmp(*(const char **)(8 * i + a2), a1, n) )\n    {\n      if ( strlen(*(const char **)(8 * i + a2)) == n )\n        return i;\n      if ( v9 == -1 )\n      {\n        v9 = i;\n      }\n      else if ( !a3 || memcmp((const void *)(a4 * v9 + a3), (const void *)(i * a4 + a3), a4) )\n      {\n        v7 = 1;\n      }\n    }\n  }\n  if ( v7 )\n    result = -2LL;\n  else\n    result = v9;\n  return result;\n}\n"], [4233045, "sub_409755", "void __fastcall sub_409755(__int64 a1, __int64 a2, __int64 a3)\n{\n  char *v3; // rax\n  __int64 v4; // rbx\n  void *v5; // rax\n  char *format; // [rsp+28h] [rbp-18h]\n\n  if ( a3 == -1 )\n    v3 = gettext(\"invalid argument %s for %s\");\n  else\n    v3 = gettext(\"ambiguous argument %s for %s\");\n  format = v3;\n  v4 = sub_409B93(1LL, a1);\n  v5 = sub_4066CC(0, 6, a2);\n  error(0, 0, format, v5, v4);\n}\n"], [4233184, "sub_4097E0", "int __fastcall sub_4097E0(__int64 a1, __int64 a2, size_t a3)\n{\n  char *v3; // rax\n  __int64 i; // [rsp+20h] [rbp-10h]\n  void *s1; // [rsp+28h] [rbp-8h]\n\n  s1 = 0LL;\n  v3 = gettext(\"Valid arguments are:\");\n  fprintf(stderr, v3);\n  for ( i = 0LL; *(_QWORD *)(8 * i + a1); ++i )\n  {\n    if ( i && !memcmp(s1, (const void *)(i * a3 + a2), a3) )\n    {\n      fprintf(stderr, \", `%s'\", *(const char **)(8 * i + a1));\n    }\n    else\n    {\n      fprintf(stderr, \"\\n  - `%s'\", *(const char **)(8 * i + a1));\n      s1 = (void *)(i * a3 + a2);\n    }\n  }\n  return putc_unlocked(10, stderr);\n}\n"], [4233488, "sub_409910", "__int64 __fastcall sub_409910(__int64 a1, const char *a2, __int64 a3, __int64 a4, size_t a5, void (*a6)(void))\n{\n  __int64 v11; // [rsp+38h] [rbp-8h]\n\n  v11 = sub_409626(a2, a3, a4, a5);\n  if ( v11 >= 0 )\n    return v11;\n  sub_409755(a1, (__int64)a2, v11);\n  sub_4097E0(a3, a4, a5);\n  a6();\n  return -1LL;\n}\n"], [4233622, "sub_409996", "__int64 __fastcall sub_409996(const void *a1, __int64 a2, __int64 a3, size_t a4)\n{\n  __int64 i; // [rsp+28h] [rbp-8h]\n\n  for ( i = 0LL; *(_QWORD *)(8 * i + a2); ++i )\n  {\n    if ( !memcmp(a1, (const void *)(i * a4 + a3), a4) )\n      return *(_QWORD *)(8 * i + a2);\n  }\n  return 0LL;\n}\n"], [4233762, "sub_409A22", "__int64 __fastcall sub_409A22(FILE *a1)\n{\n  bool v2; // [rsp+1Dh] [rbp-3h]\n  bool v3; // [rsp+1Eh] [rbp-2h]\n  bool v4; // [rsp+1Fh] [rbp-1h]\n\n  v2 = __fpending(a1) != 0;\n  v3 = ferror_unlocked(a1) != 0;\n  v4 = sub_409171(a1) != 0;\n  if ( !v3 && (!v4 || !v2 && *__errno_location() == 9) )\n    return 0LL;\n  if ( !v4 )\n    *__errno_location() = 0;\n  return 0xFFFFFFFFLL;\n}\n"], [4233901, "sub_409AAD", "FILE *__fastcall sub_409AAD(const char *a1, const char *a2)\n{\n  int v3; // [rsp+18h] [rbp-18h]\n  int fd; // [rsp+1Ch] [rbp-14h]\n  int v5; // [rsp+20h] [rbp-10h]\n  int v6; // [rsp+24h] [rbp-Ch]\n  FILE *stream; // [rsp+28h] [rbp-8h]\n\n  stream = fopen(a1, a2);\n  if ( !stream )\n    return stream;\n  v3 = fileno(stream);\n  if ( v3 < 0 || v3 > 2 )\n    return stream;\n  fd = sub_409BD6((unsigned int)v3);\n  if ( fd < 0 )\n  {\n    v5 = *__errno_location();\n    sub_409171(stream);\n    *__errno_location() = v5;\n    return 0LL;\n  }\n  if ( !sub_409171(stream) )\n  {\n    stream = fdopen(fd, a2);\n    if ( stream )\n      return stream;\n  }\n  v6 = *__errno_location();\n  close(fd);\n  *__errno_location() = v6;\n  return 0LL;\n}\n"], [4234131, "sub_409B93", "void *__fastcall sub_409B93(int a1, __int64 a2)\n{\n  return sub_4066CC(a1, 6, a2);\n}\n"], [4234167, "sub_409BB7", "void *__fastcall sub_409BB7(__int64 a1)\n{\n  return sub_409B93(0, a1);\n}\n"], [4234198, "sub_409BD6", "__int64 __fastcall sub_409BD6(int a1, __m128 a2, __m128 a3, __m128 a4, __m128 a5, __m128 a6, __m128 a7, __m128 a8, __m128 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14)\n{\n  return sub_409226(a1, 0, 3LL, a12, a13, a14, a2, a3, a4, a5, a6, a7, a8, a9);\n}\n"], [4234240, "init", "void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)\n{\n  __int64 v4; // rbx\n  signed __int64 v5; // rbp\n\n  v4 = 0LL;\n  v5 = &off_60CE18 - off_60CE10;\n  init_proc();\n  if ( v5 )\n  {\n    do\n      ((void (__fastcall *)(_QWORD, __int64, __int64))off_60CE10[v4++])(a1, a2, a3);\n    while ( v4 != v5 );\n  }\n}\n"], [4234352, "fini", "void fini(void)\n{\n  ;\n}\n"], [4234368, "sub_409C80", "int __fastcall sub_409C80(void (__fastcall *a1)(void *))\n{\n  void *v1; // rdx\n\n  if ( &qword_60D288 )\n    v1 = (void *)qword_60D288;\n  else\n    v1 = 0LL;\n  return __cxa_atexit(a1, 0LL, v1);\n}\n"], [4234400, "sub_409CA0", "int __fastcall sub_409CA0(int fildes, struct stat *stat_buf)\n{\n  return __fxstat(1, fildes, stat_buf);\n}\n"], [4234416, "sub_409CB0", "int __fastcall sub_409CB0(char *filename, struct stat *stat_buf)\n{\n  return __lxstat(1, filename, stat_buf);\n}\n"], [4234432, ".term_proc", "void term_proc()\n{\n  ;\n}\n"]]