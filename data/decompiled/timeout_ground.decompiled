[[4200632, ".init_proc", "void *init_proc()\n{\n  void *result; // rax\n\n  result = &_gmon_start__;\n  if ( &_gmon_start__ )\n    result = (void *)__gmon_start__();\n  return result;\n}\n"], [4200672, "sub_4018E0", "__int64 sub_4018E0()\n{\n  return qword_60C010();\n}\n"], [4200688, ".getenv", "// attributes: thunk\nchar *getenv(const char *name)\n{\n  return getenv(name);\n}\n"], [4200704, ".free", "// attributes: thunk\nvoid free(void *ptr)\n{\n  free(ptr);\n}\n"], [4200720, ".abort", "// attributes: thunk\nvoid __noreturn abort(void)\n{\n  abort();\n}\n"], [4200736, ".__errno_location", "// attributes: thunk\nint *__errno_location(void)\n{\n  return _errno_location();\n}\n"], [4200752, ".strncmp", "// attributes: thunk\nint strncmp(const char *s1, const char *s2, size_t n)\n{\n  return strncmp(s1, s2, n);\n}\n"], [4200768, "._exit", "// attributes: thunk\nvoid __noreturn _exit(int status)\n{\n  exit(status);\n}\n"], [4200784, ".strcpy", "// attributes: thunk\nchar *strcpy(char *dest, const char *src)\n{\n  return strcpy(dest, src);\n}\n"], [4200800, ".__fpending", "// attributes: thunk\nsize_t __fpending(FILE *fp)\n{\n  return _fpending(fp);\n}\n"], [4200816, ".iconv", "// attributes: thunk\nsize_t iconv(iconv_t cd, char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft)\n{\n  return iconv(cd, inbuf, inbytesleft, outbuf, outbytesleft);\n}\n"], [4200832, ".getc_unlocked", "// attributes: thunk\nint getc_unlocked(FILE *stream)\n{\n  return getc_unlocked(stream);\n}\n"], [4200848, ".sigaction", "// attributes: thunk\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oact)\n{\n  return sigaction(sig, act, oact);\n}\n"], [4200864, ".textdomain", "// attributes: thunk\nchar *textdomain(const char *domainname)\n{\n  return textdomain(domainname);\n}\n"], [4200880, ".strtod_l", "// attributes: thunk\ndouble strtod_l(const char *nptr, char **endptr, __locale_t loc)\n{\n  return strtod_l(nptr, endptr, loc);\n}\n"], [4200896, ".fclose", "// attributes: thunk\nint fclose(FILE *stream)\n{\n  return fclose(stream);\n}\n"], [4200912, ".bindtextdomain", "// attributes: thunk\nchar *bindtextdomain(const char *domainname, const char *dirname)\n{\n  return bindtextdomain(domainname, dirname);\n}\n"], [4200928, ".__ctype_get_mb_cur_max", "// attributes: thunk\nsize_t __ctype_get_mb_cur_max(void)\n{\n  return _ctype_get_mb_cur_max();\n}\n"], [4200944, ".strlen", "// attributes: thunk\nsize_t strlen(const char *s)\n{\n  return strlen(s);\n}\n"], [4200960, ".__stack_chk_fail", "// attributes: thunk\nvoid __noreturn __stack_chk_fail()\n{\n  _stack_chk_fail();\n}\n"], [4200976, ".getopt_long", "// attributes: thunk\nint getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind)\n{\n  return getopt_long(argc, argv, shortopts, longopts, longind);\n}\n"], [4200992, ".mbrtowc", "// attributes: thunk\nsize_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p)\n{\n  return mbrtowc(pwc, s, n, p);\n}\n"], [4201008, ".gettext", "// attributes: thunk\nchar *gettext(const char *msgid)\n{\n  return gettext(msgid);\n}\n"], [4201024, ".strchr", "// attributes: thunk\nchar *strchr(const char *s, int c)\n{\n  return strchr(s, c);\n}\n"], [4201040, ".printf", "// attributes: thunk\nint printf(const char *format, ...)\n{\n  return printf(format);\n}\n"], [4201056, ".newlocale", "// attributes: thunk\n__locale_t newlocale(int category_mask, const char *locale, __locale_t base)\n{\n  return newlocale(category_mask, locale, base);\n}\n"], [4201072, ".strrchr", "// attributes: thunk\nchar *strrchr(const char *s, int c)\n{\n  return strrchr(s, c);\n}\n"], [4201088, ".lseek", "// attributes: thunk\n__off_t lseek(int fd, __off_t offset, int whence)\n{\n  return lseek(fd, offset, whence);\n}\n"], [4201104, ".__assert_fail", "// attributes: thunk\nvoid __noreturn __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function)\n{\n  _assert_fail(assertion, file, line, function);\n}\n"], [4201120, ".memset", "// attributes: thunk\nvoid *memset(void *s, int c, size_t n)\n{\n  return memset(s, c, n);\n}\n"], [4201136, ".fscanf", "// attributes: thunk\nint fscanf(FILE *stream, const char *format, ...)\n{\n  return fscanf(stream, format);\n}\n"], [4201152, ".strnlen", "// attributes: thunk\nsize_t strnlen(const char *string, size_t maxlen)\n{\n  return strnlen(string, maxlen);\n}\n"], [4201168, ".alarm", "// attributes: thunk\nunsigned int alarm(unsigned int seconds)\n{\n  return alarm(seconds);\n}\n"], [4201184, ".close", "// attributes: thunk\nint close(int fd)\n{\n  return close(fd);\n}\n"], [4201200, ".memchr", "// attributes: thunk\nvoid *memchr(const void *s, int c, size_t n)\n{\n  return memchr(s, c, n);\n}\n"], [4201216, ".__libc_start_main", "// attributes: thunk\nint __fastcall __libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end)\n{\n  return _libc_start_main(main, argc, ubp_av, init, fini, rtld_fini, stack_end);\n}\n"], [4201232, ".memcmp", "// attributes: thunk\nint memcmp(const void *s1, const void *s2, size_t n)\n{\n  return memcmp(s1, s2, n);\n}\n"], [4201248, ".fputs_unlocked", "// attributes: thunk\nint fputs_unlocked(const char *s, FILE *stream)\n{\n  return fputs_unlocked(s, stream);\n}\n"], [4201264, ".ferror_unlocked", "// attributes: thunk\nint ferror_unlocked(FILE *stream)\n{\n  return ferror_unlocked(stream);\n}\n"], [4201280, ".calloc", "// attributes: thunk\nvoid *calloc(size_t nmemb, size_t size)\n{\n  return calloc(nmemb, size);\n}\n"], [4201296, ".strcmp", "// attributes: thunk\nint strcmp(const char *s1, const char *s2)\n{\n  return strcmp(s1, s2);\n}\n"], [4201312, ".signal", "// attributes: thunk\n__sighandler_t signal(int sig, __sighandler_t handler)\n{\n  return signal(sig, handler);\n}\n"], [4201328, ".fprintf", "// attributes: thunk\nint fprintf(FILE *stream, const char *format, ...)\n{\n  return fprintf(stream, format);\n}\n"], [4201344, ".sigemptyset", "// attributes: thunk\nint sigemptyset(sigset_t *set)\n{\n  return sigemptyset(set);\n}\n"], [4201360, ".__gmon_start__", "// attributes: thunk\n__int64 __gmon_start__(void)\n{\n  return _gmon_start__();\n}\n"], [4201376, ".strtol", "// attributes: thunk\n__int64 strtol(const char *nptr, char **endptr, int base)\n{\n  return strtol(nptr, endptr, base);\n}\n"], [4201392, ".memcpy", "// attributes: thunk\nvoid *memcpy(void *dest, const void *src, size_t n)\n{\n  return memcpy(dest, src, n);\n}\n"], [4201408, ".kill", "// attributes: thunk\nint kill(__pid_t pid, int sig)\n{\n  return kill(pid, sig);\n}\n"], [4201424, ".fileno", "// attributes: thunk\nint fileno(FILE *stream)\n{\n  return fileno(stream);\n}\n"], [4201440, ".iswalnum", "// attributes: thunk\nint iswalnum(wint_t wc)\n{\n  return iswalnum(wc);\n}\n"], [4201456, ".malloc", "// attributes: thunk\nvoid *malloc(size_t size)\n{\n  return malloc(size);\n}\n"], [4201472, ".fflush", "// attributes: thunk\nint fflush(FILE *stream)\n{\n  return fflush(stream);\n}\n"], [4201488, ".nl_langinfo", "// attributes: thunk\nchar *nl_langinfo(nl_item item)\n{\n  return nl_langinfo(item);\n}\n"], [4201504, ".ungetc", "// attributes: thunk\nint ungetc(int c, FILE *stream)\n{\n  return ungetc(c, stream);\n}\n"], [4201520, ".__freading", "// attributes: thunk\nint __freading(FILE *fp)\n{\n  return _freading(fp);\n}\n"], [4201536, ".realloc", "// attributes: thunk\nvoid *realloc(void *ptr, size_t size)\n{\n  return realloc(ptr, size);\n}\n"], [4201552, ".fdopen", "// attributes: thunk\nFILE *fdopen(int fd, const char *modes)\n{\n  return fdopen(fd, modes);\n}\n"], [4201568, ".setlocale", "// attributes: thunk\nchar *setlocale(int category, const char *locale)\n{\n  return setlocale(category, locale);\n}\n"], [4201584, ".iconv_close", "// attributes: thunk\nint iconv_close(iconv_t cd)\n{\n  return iconv_close(cd);\n}\n"], [4201600, ".iswspace", "// attributes: thunk\nint iswspace(wint_t wc)\n{\n  return iswspace(wc);\n}\n"], [4201616, ".memmove", "// attributes: thunk\nvoid *memmove(void *dest, const void *src, size_t n)\n{\n  return memmove(dest, src, n);\n}\n"], [4201632, ".error", "// attributes: thunk\nvoid error(int status, int errnum, const char *format, ...)\n{\n  error(status, errnum, format);\n}\n"], [4201648, ".waitpid", "// attributes: thunk\n__pid_t waitpid(__pid_t pid, int *stat_loc, int options)\n{\n  return waitpid(pid, stat_loc, options);\n}\n"], [4201664, ".open", "// attributes: thunk\nint open(const char *file, int oflag, ...)\n{\n  return open(file, oflag);\n}\n"], [4201680, ".fseeko", "// attributes: thunk\nint fseeko(FILE *stream, __off_t off, int whence)\n{\n  return fseeko(stream, off, whence);\n}\n"], [4201696, ".timer_settime", "// attributes: thunk\nint timer_settime(timer_t timerid, int flags, const struct itimerspec *value, struct itimerspec *ovalue)\n{\n  return timer_settime(timerid, flags, value, ovalue);\n}\n"], [4201712, ".timer_create", "// attributes: thunk\nint timer_create(clockid_t clock_id, struct sigevent *evp, timer_t *timerid)\n{\n  return timer_create(clock_id, evp, timerid);\n}\n"], [4201728, ".execvp", "// attributes: thunk\nint execvp(const char *file, char *const argv[])\n{\n  return execvp(file, argv);\n}\n"], [4201744, ".__cxa_atexit", "// attributes: thunk\nint __fastcall __cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle)\n{\n  return _cxa_atexit(lpfunc, obj, lpdso_handle);\n}\n"], [4201760, ".setpgid", "// attributes: thunk\nint setpgid(__pid_t pid, __pid_t pgid)\n{\n  return setpgid(pid, pgid);\n}\n"], [4201776, ".__libc_current_sigrtmin", "// attributes: thunk\nint __libc_current_sigrtmin(void)\n{\n  return _libc_current_sigrtmin();\n}\n"], [4201792, ".sprintf", "// attributes: thunk\nint sprintf(char *s, const char *format, ...)\n{\n  return sprintf(s, format);\n}\n"], [4201808, ".exit", "// attributes: thunk\nvoid __noreturn exit(int status)\n{\n  exit(status);\n}\n"], [4201824, ".fwrite", "// attributes: thunk\nsize_t fwrite(const void *ptr, size_t size, size_t n, FILE *s)\n{\n  return fwrite(ptr, size, n, s);\n}\n"], [4201840, ".timer_delete", "// attributes: thunk\nint timer_delete(timer_t timerid)\n{\n  return timer_delete(timerid);\n}\n"], [4201856, ".__libc_current_sigrtmax", "// attributes: thunk\nint __libc_current_sigrtmax(void)\n{\n  return _libc_current_sigrtmax();\n}\n"], [4201872, ".strdup", "// attributes: thunk\nchar *strdup(const char *s)\n{\n  return strdup(s);\n}\n"], [4201888, ".mbsinit", "// attributes: thunk\nint mbsinit(const mbstate_t *ps)\n{\n  return mbsinit(ps);\n}\n"], [4201904, ".iswprint", "// attributes: thunk\nint iswprint(wint_t wc)\n{\n  return iswprint(wc);\n}\n"], [4201920, ".fork", "// attributes: thunk\n__pid_t fork(void)\n{\n  return fork();\n}\n"], [4201936, ".__ctype_b_loc", "// attributes: thunk\nconst unsigned __int16 **__ctype_b_loc(void)\n{\n  return _ctype_b_loc();\n}\n"], [4201952, ".iconv_open", "// attributes: thunk\niconv_t iconv_open(const char *tocode, const char *fromcode)\n{\n  return iconv_open(tocode, fromcode);\n}\n"], [4201968, "start", "// positive sp value has been detected, the output may be wrong!\nvoid __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))\n{\n  __int64 v3; // rax\n  int v4; // esi\n  __int64 v5; // [rsp-8h] [rbp-8h] BYREF\n  char *retaddr; // [rsp+0h] [rbp+0h] BYREF\n\n  v4 = v5;\n  v5 = v3;\n  __libc_start_main(main, v4, &retaddr, init, fini, a3, &v5);\n  __halt();\n}\n"], [4202016, "sub_401E20", "signed __int64 sub_401E20()\n{\n  signed __int64 result; // rax\n\n  result = &unk_60C4AF - &unk_60C4A8;\n  if ( (unsigned __int64)(&unk_60C4AF - &unk_60C4A8) > 0xE )\n    result = 0LL;\n  return result;\n}\n"], [4202064, "sub_401E50", "__int64 sub_401E50()\n{\n  return 0LL;\n}\n"], [4202128, "sub_401E90", "signed __int64 sub_401E90()\n{\n  signed __int64 result; // rax\n\n  if ( !byte_60C518 )\n  {\n    result = sub_401E20();\n    byte_60C518 = 1;\n  }\n  return result;\n}\n"], [4202160, "sub_401EB0", "__int64 sub_401EB0()\n{\n  return sub_401E50();\n}\n"], [4202205, "sub_401EDD", "__int64 __fastcall sub_401EDD(unsigned int a1)\n{\n  __int64 result; // rax\n\n  if ( a1 != 1 )\n  {\n    result = a1;\n    status = a1;\n  }\n  return result;\n}\n"], [4202229, "sub_401EF5", "int sub_401EF5()\n{\n  __int64 v0; // rbx\n  char *v1; // rax\n  char *v2; // rax\n  FILE *v3; // rbx\n  char *v4; // rax\n  __int64 v5; // rbx\n  char *v6; // rax\n  __int64 v7; // rbx\n  char *v8; // rax\n  const char *s1; // [rsp+8h] [rbp-18h]\n\n  v0 = sub_402E07(qword_60C670);\n  v1 = gettext(\"\\nReport %s bugs to %s\\n\");\n  printf(v1, v0, \"bug-coreutils@gnu.org\");\n  v2 = gettext(\"%s home page: <%s>\\n\");\n  printf(v2, \"GNU coreutils\", \"http://www.gnu.org/software/coreutils/\");\n  v3 = stdout;\n  v4 = gettext(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\");\n  fputs_unlocked(v4, v3);\n  s1 = setlocale(5, 0LL);\n  if ( s1 && strncmp(s1, \"en_\", 3uLL) )\n  {\n    v5 = sub_402E07(qword_60C670);\n    v6 = gettext(\"Report %s translation bugs to <http://translationproject.org/team/>\\n\");\n    printf(v6, v5);\n  }\n  v7 = sub_402E07(qword_60C670);\n  v8 = gettext(\"For complete documentation, run: info coreutils '%s invocation'\\n\");\n  return printf(v8, v7);\n}\n"], [4202495, "sub_401FFF", "unsigned int __fastcall sub_401FFF(double a1)\n{\n  __syscall_slong_t v1; // rdx\n  unsigned int result; // eax\n  char *v3; // rbx\n  int *v4; // rax\n  char *v5; // rbx\n  int *v6; // rax\n  timer_t timerid; // [rsp+18h] [rbp-48h] BYREF\n  __time_t v8; // [rsp+20h] [rbp-40h]\n  __syscall_slong_t v9; // [rsp+28h] [rbp-38h]\n  struct itimerspec value; // [rsp+30h] [rbp-30h] BYREF\n\n  v8 = sub_402EBE(a1);\n  v9 = v1;\n  value.it_interval.tv_sec = 0LL;\n  value.it_interval.tv_nsec = 0LL;\n  value.it_value.tv_sec = v8;\n  value.it_value.tv_nsec = v1;\n  if ( timer_create(0, 0LL, &timerid) )\n  {\n    if ( *__errno_location() != 38 )\n    {\n      v5 = gettext(\"warning: timer_create\");\n      v6 = __errno_location();\n      error(0, *v6, v5);\n    }\n  }\n  else\n  {\n    result = timer_settime(timerid, 0, &value, 0LL);\n    if ( !result )\n      return result;\n    v3 = gettext(\"warning: timer_settime\");\n    v4 = __errno_location();\n    error(0, *v4, v3);\n    timer_delete(timerid);\n  }\n  if ( a1 < 4294967295.0 )\n    result = alarm((a1 > (double)(int)a1) + (int)a1);\n  else\n    result = alarm(0xFFFFFFFF);\n  return result;\n}\n"], [4202846, "sub_40215E", "int __fastcall sub_40215E(__pid_t a1, int a2)\n{\n  dword_60C540[a2] = 1;\n  return kill(a1, a2);\n}\n"], [4202893, "sub_40218D", "int __fastcall sub_40218D(int a1)\n{\n  int result; // eax\n  int v2; // [rsp+Ch] [rbp-4h]\n\n  v2 = a1;\n  if ( a1 == 14 )\n  {\n    dword_60C520 = 1;\n    v2 = dword_60C2B0;\n  }\n  if ( !pid )\n    _exit(v2 + 128);\n  if ( dword_60C540[v2] )\n  {\n    result = v2;\n    dword_60C540[v2] = 0;\n  }\n  else\n  {\n    if ( *(double *)&qword_60C648 != 0.0 )\n    {\n      dword_60C2B0 = 9;\n      sub_401FFF(*(double *)&qword_60C648);\n      qword_60C648 = 0LL;\n    }\n    sub_40215E(pid, v2);\n    result = (unsigned __int8)byte_60C650 ^ 1;\n    if ( byte_60C650 != 1 )\n      result = sub_40215E(0, v2);\n    if ( v2 != 9 && v2 != 18 )\n    {\n      sub_40215E(pid, 18);\n      result = (unsigned __int8)byte_60C650 ^ 1;\n      if ( byte_60C650 != 1 )\n        result = sub_40215E(0, 18);\n    }\n  }\n  return result;\n}\n"], [4203174, "sub_4022A6", "void __fastcall __noreturn sub_4022A6(int a1)\n{\n  __int64 v1; // rbx\n  char *v2; // rax\n  __int64 v3; // r12\n  __int64 v4; // rbx\n  char *v5; // rax\n  FILE *v6; // rbx\n  char *v7; // rax\n  FILE *v8; // rbx\n  char *v9; // rax\n  FILE *v10; // rbx\n  char *v11; // rax\n  FILE *v12; // rbx\n  char *v13; // rax\n  FILE *v14; // rbx\n  char *v15; // rax\n  FILE *v16; // rbx\n  char *v17; // rax\n\n  if ( a1 )\n  {\n    v1 = qword_60C670;\n    v2 = gettext(\"Try `%s --help' for more information.\\n\");\n    fprintf(stderr, v2, v1);\n  }\n  else\n  {\n    v3 = qword_60C670;\n    v4 = qword_60C670;\n    v5 = gettext(\"Usage: %s [OPTION] DURATION COMMAND [ARG]...\\n  or:  %s [OPTION]\\n\");\n    printf(v5, v4, v3);\n    v6 = stdout;\n    v7 = gettext(\n           \"Start COMMAND, and kill it if still running after DURATION.\\n\"\n           \"\\n\"\n           \"Mandatory arguments to long options are mandatory for short options too.\\n\");\n    fputs_unlocked(v7, v6);\n    v8 = stdout;\n    v9 = gettext(\n           \"      --foreground\\n\"\n           \"                 When not running timeout directly from a shell prompt,\\n\"\n           \"                 allow COMMAND to read from the TTY and receive TTY signals.\\n\"\n           \"                 In this mode, children of COMMAND will not be timed out.\\n\"\n           \"  -k, --kill-after=DURATION\\n\"\n           \"                 also send a KILL signal if COMMAND is still running\\n\"\n           \"                 this long after the initial signal was sent.\\n\"\n           \"  -s, --signal=SIGNAL\\n\"\n           \"                 specify the signal to be sent on timeout.\\n\"\n           \"                 SIGNAL may be a name like `HUP' or a number.\\n\"\n           \"                 See `kill -l` for a list of signals\\n\");\n    fputs_unlocked(v9, v8);\n    v10 = stdout;\n    v11 = gettext(\"      --help     display this help and exit\\n\");\n    fputs_unlocked(v11, v10);\n    v12 = stdout;\n    v13 = gettext(\"      --version  output version information and exit\\n\");\n    fputs_unlocked(v13, v12);\n    v14 = stdout;\n    v15 = gettext(\n            \"\\n\"\n            \"DURATION is a floating point number with an optional suffix:\\n\"\n            \"`s' for seconds (the default), `m' for minutes, `h' for hours or `d' for days.\\n\");\n    fputs_unlocked(v15, v14);\n    v16 = stdout;\n    v17 = gettext(\n            \"\\n\"\n            \"If the command times out, then exit with status 124.  Otherwise, exit\\n\"\n            \"with the status of COMMAND.  If no signal is specified, send the TERM\\n\"\n            \"signal upon timeout.  The TERM signal kills any process that does not\\n\"\n            \"block or catch that signal.  For other processes, it may be necessary to\\n\"\n            \"use the KILL (9) signal, since this signal cannot be caught.\\n\");\n    fputs_unlocked(v17, v16);\n    sub_401EF5();\n  }\n  exit(a1);\n}\n"], [4203471, "sub_4023CF", "__int64 __fastcall sub_4023CF(double *a1, char a2)\n{\n  int v3; // [rsp+18h] [rbp-4h]\n\n  if ( a2 == 104 )\n  {\n    v3 = 3600;\n    goto LABEL_13;\n  }\n  if ( a2 > 104 )\n  {\n    if ( a2 == 109 )\n    {\n      v3 = 60;\n      goto LABEL_13;\n    }\n    if ( a2 != 115 )\n      return 0LL;\n    goto LABEL_8;\n  }\n  if ( !a2 )\n  {\nLABEL_8:\n    v3 = 1;\n    goto LABEL_13;\n  }\n  if ( a2 != 100 )\n    return 0LL;\n  v3 = 86400;\nLABEL_13:\n  *a1 = (double)v3 * *a1;\n  return 1LL;\n}\n"], [4203594, "sub_40244A", "double __fastcall sub_40244A(__int64 a1)\n{\n  __int64 v1; // rbx\n  char *v2; // rax\n  double v4; // [rsp+10h] [rbp-20h] BYREF\n  char *v5; // [rsp+18h] [rbp-18h] BYREF\n\n  if ( (unsigned __int8)sub_406519(a1, &v5, &v4, sub_402C86) != 1\n    || v4 < 0.0\n    || *v5 && v5[1]\n    || (unsigned __int8)sub_4023CF(&v4, *v5) != 1 )\n  {\n    v1 = sub_403B83(a1);\n    v2 = gettext(\"invalid time interval %s\");\n    error(0, 0, v2, v1);\n    sub_4022A6(125);\n  }\n  return v4;\n}\n"], [4203800, "sub_402518", "int __fastcall sub_402518(int a1)\n{\n  struct sigaction v2; // [rsp+10h] [rbp-A0h] BYREF\n\n  sigemptyset(&v2.sa_mask);\n  v2.sa_handler = (__sighandler_t)sub_40218D;\n  v2.sa_flags = 0x10000000;\n  sigaction(14, &v2, 0LL);\n  sigaction(2, &v2, 0LL);\n  sigaction(3, &v2, 0LL);\n  sigaction(1, &v2, 0LL);\n  sigaction(15, &v2, 0LL);\n  return sigaction(a1, &v2, 0LL);\n}\n"], [4204009, "main", "__int64 __fastcall main(int a1, char **a2, char **a3)\n{\n  int v3; // eax\n  int v4; // eax\n  char *v5; // rbx\n  int *v6; // rax\n  __int64 result; // rax\n  unsigned int v8; // eax\n  __int64 v9; // r12\n  char *v10; // rbx\n  int *v11; // rax\n  char *v12; // rbx\n  int *v13; // rax\n  unsigned int v14; // ebx\n  char *v15; // rax\n  char **argv; // [rsp+10h] [rbp-90h]\n  int stat_loc; // [rsp+54h] [rbp-4Ch] BYREF\n  int v18; // [rsp+58h] [rbp-48h]\n  unsigned int v19; // [rsp+5Ch] [rbp-44h]\n  __pid_t v20; // [rsp+60h] [rbp-40h]\n  int v21; // [rsp+64h] [rbp-3Ch]\n  double v22; // [rsp+68h] [rbp-38h]\n  char v23[24]; // [rsp+70h] [rbp-30h] BYREF\n  unsigned __int64 v24; // [rsp+88h] [rbp-18h]\n\n  v24 = __readfsqword(0x28u);\n  sub_403027(*a2, a2, a3);\n  setlocale(6, locale);\n  bindtextdomain(\"coreutils\", \"/root/Product/coreutils/exe/share/locale\");\n  textdomain(\"coreutils\");\n  sub_401EDD(0x7Du);\n  sub_409540(sub_402D1C);\n  while ( 1 )\n  {\n    v18 = getopt_long(a1, a2, \"+k:s:\", &longopts, 0LL);\n    if ( v18 == -1 )\n      break;\n    if ( v18 == 107 )\n    {\n      qword_60C648 = sub_40244A(optarg);\n    }\n    else\n    {\n      if ( v18 <= 107 )\n      {\n        if ( v18 == -131 )\n        {\n          v3 = sub_403893(\"Padraig Brady\", &unk_409E03);\n          sub_40600E((_DWORD)stdout, (unsigned int)\"timeout\", (unsigned int)\"GNU coreutils\", (_DWORD)off_60C2B8, v3, 0);\n          exit(0);\n        }\n        if ( v18 == -130 )\n          sub_4022A6(0);\nLABEL_17:\n        sub_4022A6(125);\n      }\n      if ( v18 == 115 )\n      {\n        dword_60C2B0 = sub_402A89(optarg, v23);\n        if ( dword_60C2B0 == -1 )\n          sub_4022A6(125);\n      }\n      else\n      {\n        if ( v18 != 128 )\n          goto LABEL_17;\n        byte_60C650 = 1;\n      }\n    }\n  }\n  if ( a1 - optind <= 1 )\n    sub_4022A6(125);\n  v4 = optind++;\n  v22 = sub_40244A((__int64)a2[v4]);\n  argv = &a2[optind];\n  if ( byte_60C650 != 1 )\n    setpgid(0, 0);\n  sub_402518(dword_60C2B0);\n  signal(21, (__sighandler_t)1);\n  signal(22, (__sighandler_t)1);\n  signal(17, 0LL);\n  pid = fork();\n  if ( pid == -1 )\n  {\n    v5 = gettext(\"fork system call failed\");\n    v6 = __errno_location();\n    error(0, *v6, v5);\n    result = 125LL;\n  }\n  else if ( pid )\n  {\n    sub_401FFF(v22);\n    do\n      v20 = waitpid(pid, &stat_loc, 0);\n    while ( v20 < 0 && *__errno_location() == 4 );\n    if ( v20 >= 0 )\n    {\n      if ( (stat_loc & 0x7F) != 0 )\n      {\n        if ( (char)((stat_loc & 0x7F) + 1) >> 1 <= 0 )\n        {\n          v14 = stat_loc;\n          v15 = gettext(\"unknown status from command (0x%X)\");\n          error(0, 0, v15, v14);\n          stat_loc = 1;\n        }\n        else\n        {\n          v21 = stat_loc & 0x7F;\n          stat_loc = v21 + 128;\n        }\n      }\n      else\n      {\n        stat_loc = (stat_loc & 0xFF00) >> 8;\n      }\n    }\n    else\n    {\n      v12 = gettext(\"error waiting for command\");\n      v13 = __errno_location();\n      error(0, *v13, v12);\n      stat_loc = 125;\n    }\n    if ( dword_60C520 )\n      result = 124LL;\n    else\n      result = (unsigned int)stat_loc;\n  }\n  else\n  {\n    signal(21, 0LL);\n    signal(22, 0LL);\n    execvp(*argv, argv);\n    if ( *__errno_location() == 2 )\n      v8 = 127;\n    else\n      v8 = 126;\n    v19 = v8;\n    v9 = sub_403B83(*argv);\n    v10 = gettext(\"failed to run command %s\");\n    v11 = __errno_location();\n    error(0, *v11, v10, v9);\n    result = v19;\n  }\n  return result;\n}\n"], [4205193, "sub_402A89", "__int64 __fastcall sub_402A89(const char *a1, __int64 a2)\n{\n  int v2; // eax\n  char *v3; // rax\n  unsigned int v5; // [rsp+28h] [rbp-28h] BYREF\n  int v6; // [rsp+2Ch] [rbp-24h]\n  char *endptr; // [rsp+30h] [rbp-20h] BYREF\n  _BYTE *i; // [rsp+38h] [rbp-18h]\n  __int64 v9; // [rsp+40h] [rbp-10h]\n  void *ptr; // [rsp+48h] [rbp-8h]\n\n  if ( (unsigned int)(*a1 - 48) > 9 )\n  {\n    ptr = (void *)sub_4063CB(a1);\n    for ( i = ptr; *i; ++i )\n    {\n      if ( strchr(\"abcdefghijklmnopqrstuvwxyz\", (char)*i) )\n        *i -= 32;\n    }\n    if ( (unsigned int)sub_40677E(ptr, &v5)\n      && (*(_BYTE *)ptr != 83\n       || *((_BYTE *)ptr + 1) != 73\n       || *((_BYTE *)ptr + 2) != 71\n       || (unsigned int)sub_40677E((char *)ptr + 3, &v5)) )\n    {\n      v5 = -1;\n    }\n    free(ptr);\n  }\n  else\n  {\n    *__errno_location() = 0;\n    v9 = strtol(a1, &endptr, 10);\n    v6 = v9;\n    if ( a1 == endptr || *endptr || *__errno_location() || v6 != v9 )\n    {\n      v2 = -1;\n    }\n    else if ( (char)((v6 & 0x7F) + 1) >> 1 <= 0 )\n    {\n      v2 = v6;\n    }\n    else\n    {\n      v2 = v6 & 0x7F;\n    }\n    v5 = v2;\n  }\n  if ( (v5 & 0x80000000) == 0 && !(unsigned int)sub_4067B8(v5, a2) )\n    return v5;\n  v3 = gettext(\"%s: invalid signal\");\n  error(0, 0, v3, a1);\n  return 0xFFFFFFFFLL;\n}\n"], [4205650, "sub_402C52", "__int64 sub_402C52()\n{\n  if ( !qword_60C658 )\n    qword_60C658 = (__int64)newlocale(8127, \"C\", 0LL);\n  return qword_60C658;\n}\n"], [4205702, "sub_402C86", "double __fastcall sub_402C86(const char *a1, char **a2)\n{\n  struct __locale_struct *loc; // [rsp+20h] [rbp-10h]\n\n  loc = (struct __locale_struct *)sub_402C52();\n  if ( loc )\n    return strtod_l(a1, a2, loc);\n  if ( a2 )\n    *a2 = (char *)a1;\n  return 0.0;\n}\n"], [4205810, "sub_402CF2", "__int64 __fastcall sub_402CF2(__int64 a1)\n{\n  __int64 result; // rax\n\n  result = a1;\n  qword_60C660 = a1;\n  return result;\n}\n"], [4205831, "sub_402D07", "__int64 __fastcall sub_402D07(unsigned __int8 a1)\n{\n  __int64 result; // rax\n\n  result = a1;\n  byte_60C668 = a1;\n  return result;\n}\n"], [4205852, "sub_402D1C", "__int64 sub_402D1C()\n{\n  const char *v0; // rbx\n  int *v1; // rax\n  int *v2; // rax\n  __int64 result; // rax\n  char *v4; // [rsp+8h] [rbp-18h]\n\n  if ( (unsigned int)sub_40695F(stdout) && (byte_60C668 != 1 || *__errno_location() != 32) )\n  {\n    v4 = gettext(\"write error\");\n    if ( qword_60C660 )\n    {\n      v0 = (const char *)sub_40519C(qword_60C660);\n      v1 = __errno_location();\n      error(0, *v1, \"%s: %s\", v0, v4);\n    }\n    else\n    {\n      v2 = __errno_location();\n      error(0, *v2, \"%s\", v4);\n    }\n    _exit(status);\n  }\n  result = sub_40695F(stderr);\n  if ( (_DWORD)result )\n    _exit(status);\n  return result;\n}\n"], [4206087, "sub_402E07", "_BYTE *__fastcall sub_402E07(_BYTE *a1)\n{\n  char v2; // [rsp+17h] [rbp-11h]\n  _BYTE *i; // [rsp+20h] [rbp-8h]\n\n  v2 = 0;\n  while ( *a1 == 47 )\n    ++a1;\n  for ( i = a1; *i; ++i )\n  {\n    if ( *i == 47 )\n    {\n      v2 = 1;\n    }\n    else if ( v2 )\n    {\n      a1 = i;\n      v2 = 0;\n    }\n  }\n  return a1;\n}\n"], [4206192, "sub_402E70", "size_t __fastcall sub_402E70(const char *a1)\n{\n  size_t i; // [rsp+10h] [rbp-10h]\n\n  for ( i = strlen(a1); i > 1 && a1[i - 1] == 47; --i )\n    ;\n  return i;\n}\n"], [4206270, "sub_402EBE", "__int64 __fastcall sub_402EBE(double a1)\n{\n  __int64 v2; // [rsp+10h] [rbp-38h]\n  signed __int64 v3; // [rsp+18h] [rbp-30h]\n\n  if ( a1 <= -9.223372036854776e18 )\n    return 0x8000000000000000LL;\n  if ( a1 >= 9.223372036854776e18 )\n    return 0x7FFFFFFFFFFFFFFFLL;\n  v3 = ((a1 - (double)(int)a1) * 1000000000.0 > (double)(int)((a1 - (double)(int)a1) * 1000000000.0))\n     + (unsigned __int64)(unsigned int)(int)((a1 - (double)(int)a1) * 1000000000.0);\n  v2 = v3 / 1000000000 + (unsigned int)(int)a1;\n  if ( v3 % 1000000000 < 0 )\n    --v2;\n  return v2;\n}\n"], [4206631, "sub_403027", "char *__fastcall sub_403027(const char *a1)\n{\n  char *v1; // rax\n  char *result; // rax\n  char *s; // [rsp+8h] [rbp-18h]\n  char *v4; // [rsp+10h] [rbp-10h]\n  char *s1; // [rsp+18h] [rbp-8h]\n\n  s = (char *)a1;\n  if ( !a1 )\n  {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\", 1uLL, 0x37uLL, stderr);\n    abort();\n  }\n  v4 = strrchr(a1, 47);\n  if ( v4 )\n    v1 = v4 + 1;\n  else\n    v1 = (char *)a1;\n  s1 = v1;\n  if ( v1 - a1 > 6 && !strncmp(v1 - 7, \"/.libs/\", 7uLL) )\n  {\n    s = s1;\n    if ( !strncmp(s1, \"lt-\", 3uLL) )\n    {\n      s = s1 + 3;\n      program_invocation_short_name = (__int64)(s1 + 3);\n    }\n  }\n  qword_60C670 = (__int64)s;\n  result = s;\n  program_invocation_name = (__int64)s;\n  return result;\n}\n"], [4206862, "sub_40310E", "bool __fastcall sub_40310E(unsigned __int8 a1)\n{\n  return (((unsigned int)dword_40A540[a1 >> 5] >> (a1 & 0x1F)) & 1) != 0;\n}\n"], [4206916, "sub_403144", "__int64 __fastcall sub_403144(__int64 a1)\n{\n  __int64 result; // rax\n  size_t v2; // rax\n  size_t v3; // rax\n\n  result = *(unsigned __int8 *)(a1 + 12);\n  if ( !(_BYTE)result )\n  {\n    if ( !*(_BYTE *)a1 )\n    {\n      if ( sub_40310E(**(_BYTE **)(a1 + 16)) )\n      {\n        *(_QWORD *)(a1 + 24) = 1LL;\n        *(_DWORD *)(a1 + 36) = **(char **)(a1 + 16);\n        *(_BYTE *)(a1 + 32) = 1;\nLABEL_19:\n        result = a1;\n        *(_BYTE *)(a1 + 12) = 1;\n        return result;\n      }\n      if ( !mbsinit((const mbstate_t *)(a1 + 4)) )\n        __assert_fail(\"mbsinit (&iter->state)\", \"../../src/lib/mbuiter.h\", 0x8Eu, \"mbuiter_multi_next\");\n      *(_BYTE *)a1 = 1;\n    }\n    v2 = __ctype_get_mb_cur_max();\n    v3 = sub_40531B(*(_QWORD *)(a1 + 16), v2);\n    *(_QWORD *)(a1 + 24) = mbrtowc((wchar_t *)(a1 + 36), *(const char **)(a1 + 16), v3, (mbstate_t *)(a1 + 4));\n    if ( *(_QWORD *)(a1 + 24) == -1LL )\n    {\n      *(_QWORD *)(a1 + 24) = 1LL;\n      *(_BYTE *)(a1 + 32) = 0;\n    }\n    else if ( *(_QWORD *)(a1 + 24) == -2LL )\n    {\n      *(_QWORD *)(a1 + 24) = strlen(*(const char **)(a1 + 16));\n      *(_BYTE *)(a1 + 32) = 0;\n    }\n    else\n    {\n      if ( !*(_QWORD *)(a1 + 24) )\n      {\n        *(_QWORD *)(a1 + 24) = 1LL;\n        if ( **(_BYTE **)(a1 + 16) )\n          __assert_fail(\"*iter->cur.ptr == '\\\\0'\", \"../../src/lib/mbuiter.h\", 0xAAu, \"mbuiter_multi_next\");\n        if ( *(_DWORD *)(a1 + 36) )\n          __assert_fail(\"iter->cur.wc == 0\", \"../../src/lib/mbuiter.h\", 0xABu, \"mbuiter_multi_next\");\n      }\n      *(_BYTE *)(a1 + 32) = 1;\n      if ( mbsinit((const mbstate_t *)(a1 + 4)) )\n        *(_BYTE *)a1 = 0;\n    }\n    goto LABEL_19;\n  }\n  return result;\n}\n"], [4207396, "sub_403324", "__int64 __fastcall sub_403324(_BYTE *a1, __int64 a2)\n{\n  size_t v7; // rax\n  unsigned __int8 v10; // [rsp+13h] [rbp-ADh]\n  char v11; // [rsp+14h] [rbp-ACh]\n  char v12; // [rsp+15h] [rbp-ABh]\n  char v13; // [rsp+16h] [rbp-AAh]\n  char v14; // [rsp+17h] [rbp-A9h]\n  char *s; // [rsp+18h] [rbp-A8h]\n  _BYTE *v16; // [rsp+20h] [rbp-A0h]\n  char v17[4]; // [rsp+30h] [rbp-90h] BYREF\n  int v18; // [rsp+34h] [rbp-8Ch] BYREF\n  char v19; // [rsp+3Ch] [rbp-84h]\n  unsigned __int64 v20; // [rsp+40h] [rbp-80h]\n  __int64 v21; // [rsp+48h] [rbp-78h]\n  __int64 v22; // [rsp+50h] [rbp-70h]\n  __int64 v23; // [rsp+58h] [rbp-68h]\n  __int64 v24; // [rsp+60h] [rbp-60h]\n  __int64 v25; // [rsp+68h] [rbp-58h]\n  unsigned __int64 v26; // [rsp+70h] [rbp-50h] BYREF\n  __int64 v27; // [rsp+78h] [rbp-48h]\n  wint_t wc[2]; // [rsp+80h] [rbp-40h]\n  __int64 v29; // [rsp+88h] [rbp-38h]\n  __int64 v30; // [rsp+90h] [rbp-30h]\n  __int64 v31; // [rsp+98h] [rbp-28h]\n  unsigned __int64 v32; // [rsp+B8h] [rbp-8h]\n\n  v32 = __readfsqword(0x28u);\n  s = (char *)sub_40557D(a2, 2LL);\n  v10 = 0;\n  while ( *a1 )\n  {\n    v16 = (_BYTE *)sub_407BE6(a1, s);\n    if ( !v16 )\n      break;\n    if ( __ctype_get_mb_cur_max() <= 1 )\n    {\n      v13 = 1;\n      if ( a1 < v16 && ((*__ctype_b_loc())[(unsigned __int8)*(v16 - 1)] & 8) != 0 )\n        v13 = 0;\n      v7 = strlen(s);\n      v14 = 1;\n      if ( v16[v7] && ((*__ctype_b_loc())[(unsigned __int8)v16[v7]] & 8) != 0 )\n        v14 = 0;\n      if ( v13 && v14 )\n      {\n        v10 = 1;\n        break;\n      }\n      if ( !*v16 )\n        break;\n      a1 = v16 + 1;\n    }\n    else\n    {\n      v20 = (unsigned __int64)a1;\n      v17[0] = 0;\n      memset(&v18, 0, 8uLL);\n      v19 = 0;\n      v11 = 1;\n      if ( v20 < (unsigned __int64)v16 )\n      {\n        do\n        {\n          sub_403144((__int64)v17);\n          if ( (unsigned __int8)v22 == 1 && !HIDWORD(v22) )\n            abort();\n          v26 = v20;\n          v27 = v21;\n          *(_QWORD *)wc = v22;\n          v29 = v23;\n          v30 = v24;\n          v31 = v25;\n          v20 += v21;\n          v19 = 0;\n        }\n        while ( v20 < (unsigned __int64)v16 );\n        if ( LOBYTE(wc[0]) && iswalnum(wc[1]) )\n          v11 = 0;\n      }\n      v20 = (unsigned __int64)v16;\n      v17[0] = 0;\n      memset(&v18, 0, 8uLL);\n      v19 = 0;\n      *(_QWORD *)wc = s;\n      LOBYTE(v26) = 0;\n      memset((char *)&v26 + 4, 0, sizeof(unsigned __int64));\n      for ( BYTE4(v27) = 0; ; BYTE4(v27) = 0 )\n      {\n        sub_403144((__int64)&v26);\n        if ( (unsigned __int8)v30 == 1 && !HIDWORD(v30) )\n          break;\n        sub_403144((__int64)v17);\n        if ( (unsigned __int8)v22 == 1 && !HIDWORD(v22) )\n          abort();\n        v20 += v21;\n        v19 = 0;\n        *(_QWORD *)wc += v29;\n      }\n      v12 = 1;\n      sub_403144((__int64)v17);\n      if ( (unsigned __int8)v22 != 1 || HIDWORD(v22) )\n      {\n        v26 = v20;\n        v27 = v21;\n        *(_QWORD *)wc = v22;\n        v29 = v23;\n        v30 = v24;\n        v31 = v25;\n        if ( (_BYTE)v22 )\n        {\n          if ( iswalnum(wc[1]) )\n            v12 = 0;\n        }\n      }\n      if ( v11 && v12 )\n      {\n        v10 = 1;\n        break;\n      }\n      v20 = (unsigned __int64)v16;\n      v17[0] = 0;\n      memset(&v18, 0, 8uLL);\n      v19 = 0;\n      sub_403144((__int64)v17);\n      if ( (unsigned __int8)v22 == 1 && !HIDWORD(v22) )\n        break;\n      a1 = &v16[v21];\n    }\n  }\n  free(s);\n  return v10;\n}\n"], [4208626, "sub_4037F2", "const char *__fastcall sub_4037F2(const char *a1)\n{\n  size_t v2; // rbx\n  size_t v3; // rax\n  char *s; // [rsp+10h] [rbp-20h]\n  char *v5; // [rsp+18h] [rbp-18h]\n\n  s = gettext(a1);\n  if ( s == a1 )\n    return a1;\n  if ( (unsigned __int8)sub_403324(s, (__int64)a1) )\n    return s;\n  v2 = strlen(s);\n  v3 = strlen(a1);\n  v5 = (char *)sub_406276(v2 + v3 + 4);\n  sprintf(v5, \"%s (%s)\", s, a1);\n  return v5;\n}\n"], [4208787, "sub_403893", "char *__fastcall sub_403893(const char *a1, __int64 a2)\n{\n  char *v2; // rax\n  char *result; // rax\n  size_t v4; // rbx\n  size_t v5; // rax\n  char *ptr; // [rsp+18h] [rbp-68h]\n  char *v7; // [rsp+20h] [rbp-60h]\n  __int64 v8; // [rsp+28h] [rbp-58h]\n  __int64 v9; // [rsp+30h] [rbp-50h]\n  char *s1; // [rsp+38h] [rbp-48h]\n  char *s; // [rsp+40h] [rbp-40h]\n  size_t n; // [rsp+48h] [rbp-38h]\n  char *dest; // [rsp+50h] [rbp-30h]\n  char *v14; // [rsp+58h] [rbp-28h]\n  char *v15; // [rsp+60h] [rbp-20h]\n  char *v16; // [rsp+68h] [rbp-18h]\n\n  s1 = gettext(a1);\n  s = (char *)sub_406ED0();\n  ptr = 0LL;\n  v7 = 0LL;\n  v9 = 0LL;\n  if ( (unsigned int)sub_4068E8(s, \"UTF-8\") )\n  {\n    ptr = (char *)sub_4064CC(a2, \"UTF-8\", s);\n    v8 = (__int64)ptr;\n    n = strlen(s);\n    dest = (char *)sub_406276(n + 11);\n    memcpy(dest, s, n);\n    memcpy(&dest[n], \"//TRANSLIT\", 0xBuLL);\n    v14 = (char *)sub_4064CC(a2, \"UTF-8\", dest);\n    free(dest);\n    if ( v14 )\n    {\n      if ( strchr(v14, 63) )\n      {\n        free(v14);\n      }\n      else\n      {\n        v7 = v14;\n        v9 = (__int64)v14;\n      }\n    }\n  }\n  else\n  {\n    v8 = a2;\n    v9 = a2;\n  }\n  if ( v8 )\n  {\n    v2 = (char *)v8;\n  }\n  else if ( v9 )\n  {\n    v2 = (char *)v9;\n  }\n  else\n  {\n    v2 = (char *)a1;\n  }\n  v15 = v2;\n  if ( !strcmp(s1, a1) )\n  {\n    if ( ptr && ptr != v15 )\n      free(ptr);\n    if ( v7 && v7 != v15 )\n      free(v7);\n    result = v15;\n  }\n  else if ( (unsigned __int8)sub_403324(s1, (__int64)a1)\n         || v8 && (unsigned __int8)sub_403324(s1, v8)\n         || v9 && (unsigned __int8)sub_403324(s1, v9) )\n  {\n    if ( ptr )\n      free(ptr);\n    if ( v7 )\n      free(v7);\n    result = s1;\n  }\n  else\n  {\n    v4 = strlen(s1);\n    v5 = strlen(v15);\n    v16 = (char *)sub_406276(v4 + v5 + 4);\n    sprintf(v16, \"%s (%s)\", s1, v15);\n    if ( ptr )\n      free(ptr);\n    if ( v7 )\n      free(v7);\n    result = v16;\n  }\n  return result;\n}\n"], [4209503, "sub_403B5F", "__int64 __fastcall sub_403B5F(unsigned int a1, __int64 a2)\n{\n  return sub_40500E(a1, 6LL, a2);\n}\n"], [4209539, "sub_403B83", "__int64 __fastcall sub_403B83(__int64 a1)\n{\n  return sub_403B5F(0, a1);\n}\n"], [4209570, "sub_403BA2", "__int64 __fastcall sub_403BA2(__int64 *a1)\n{\n  __int64 *v1; // rax\n  int v3; // [rsp+14h] [rbp-Ch]\n  __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v3 = *__errno_location();\n  if ( a1 )\n    v1 = a1;\n  else\n    v1 = &qword_60C680;\n  v4 = sub_40639A(v1, 56LL);\n  *__errno_location() = v3;\n  return v4;\n}\n"], [4209643, "sub_403BEB", "__int64 __fastcall sub_403BEB(__int64 *a1)\n{\n  __int64 *v1; // rax\n\n  if ( a1 )\n    v1 = a1;\n  else\n    v1 = &qword_60C680;\n  return *(unsigned int *)v1;\n}\n"], [4209673, "sub_403C09", "__int64 *__fastcall sub_403C09(__int64 *a1, int a2)\n{\n  __int64 *result; // rax\n\n  if ( a1 )\n    result = a1;\n  else\n    result = &qword_60C680;\n  *(_DWORD *)result = a2;\n  return result;\n}\n"], [4209709, "sub_403C2D", "__int64 __fastcall sub_403C2D(__int64 *a1, unsigned __int8 a2, char a3)\n{\n  __int64 *v3; // rax\n  unsigned int v5; // [rsp+24h] [rbp-Ch]\n\n  if ( a1 )\n    v3 = a1;\n  else\n    v3 = &qword_60C680;\n  v5 = (*((_DWORD *)v3 + (a2 >> 5) + 2) >> (a2 & 0x1F)) & 1;\n  *((_DWORD *)v3 + (a2 >> 5) + 2) ^= (v5 ^ a3 & 1) << (a2 & 0x1F);\n  return v5;\n}\n"], [4209845, "sub_403CB5", "__int64 __fastcall sub_403CB5(__int64 *a1, int a2)\n{\n  __int64 *v3; // [rsp+4h] [rbp-18h]\n  unsigned int v4; // [rsp+18h] [rbp-4h]\n\n  v3 = a1;\n  if ( !a1 )\n    v3 = &qword_60C680;\n  v4 = *((_DWORD *)v3 + 1);\n  *((_DWORD *)v3 + 1) = a2;\n  return v4;\n}\n"], [4209896, "sub_403CE8", "__int64 *__fastcall sub_403CE8(__int64 *a1, __int64 a2, __int64 a3)\n{\n  __int64 *result; // rax\n  __int64 *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = a1;\n  if ( !a1 )\n    v4 = &qword_60C680;\n  *(_DWORD *)v4 = 8;\n  if ( !a2 || !a3 )\n    abort();\n  v4[5] = a2;\n  result = v4;\n  v4[6] = a3;\n  return result;\n}\n"], [4209986, "sub_403D42", "_QWORD *__fastcall sub_403D42(_QWORD *a1, int a2)\n{\n  __int64 v3[7]; // [rsp+10h] [rbp-40h] BYREF\n\n  memset(v3, 0, sizeof(v3));\n  if ( a2 == 8 )\n    abort();\n  LODWORD(v3[0]) = a2;\n  *a1 = v3[0];\n  a1[1] = v3[1];\n  a1[2] = v3[2];\n  a1[3] = v3[3];\n  a1[4] = v3[4];\n  a1[5] = v3[5];\n  a1[6] = v3[6];\n  return a1;\n}\n"], [4210106, "sub_403DBA", "char *__fastcall sub_403DBA(const char *a1, int a2)\n{\n  char *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = gettext(a1);\n  if ( v3 == a1 && a2 == 7 )\n    v3 = (char *)L\"\\\"`'\";\n  return v3;\n}\n"], [4210167, "sub_403DF7", "unsigned __int64 __fastcall sub_403DF7(__int64 a1, unsigned __int64 a2, __int64 a3, size_t a4, unsigned int a5, int a6, __int64 a7, char *a8, char *a9)\n{\n  int v9; // eax\n  bool v10; // al\n  int v11; // eax\n  char v20; // [rsp+65h] [rbp-6Bh]\n  bool v21; // [rsp+66h] [rbp-6Ah]\n  unsigned __int8 v22; // [rsp+67h] [rbp-69h]\n  char v23; // [rsp+68h] [rbp-68h]\n  char v24; // [rsp+69h] [rbp-67h]\n  bool v25; // [rsp+6Ah] [rbp-66h]\n  bool v26; // [rsp+6Bh] [rbp-65h]\n  wchar_t pwc; // [rsp+6Ch] [rbp-64h] BYREF\n  __int64 i; // [rsp+70h] [rbp-60h]\n  unsigned __int64 v29; // [rsp+78h] [rbp-58h]\n  char *s; // [rsp+80h] [rbp-50h]\n  size_t n; // [rsp+88h] [rbp-48h]\n  unsigned __int64 v32; // [rsp+90h] [rbp-40h]\n  unsigned __int64 j; // [rsp+98h] [rbp-38h]\n  size_t v34; // [rsp+A0h] [rbp-30h]\n  unsigned __int64 v35; // [rsp+A8h] [rbp-28h]\n  mbstate_t p; // [rsp+B0h] [rbp-20h] BYREF\n  unsigned __int64 v37; // [rsp+B8h] [rbp-18h]\n\n  v37 = __readfsqword(0x28u);\n  v29 = 0LL;\n  s = 0LL;\n  n = 0LL;\n  v20 = 0;\n  v26 = __ctype_get_mb_cur_max() == 1;\n  v21 = (a6 & 2) != 0;\n  if ( a5 == 3 )\n    goto LABEL_11;\n  if ( a5 > 3 )\n  {\n    if ( a5 == 5 )\n    {\n      v20 = 1;\n      v21 = 0;\n      goto LABEL_33;\n    }\n    if ( a5 >= 5 )\n    {\n      if ( a5 > 8 )\n        abort();\n      if ( a5 != 8 )\n      {\n        a8 = sub_403DBA((const char *)L\"`'\", a5);\n        a9 = sub_403DBA((const char *)L\"'\", a5);\n      }\n      if ( (a6 & 2) == 0 )\n      {\n        for ( s = a8; *s; ++s )\n        {\n          if ( v29 < a2 )\n            *(_BYTE *)(v29 + a1) = *s;\n          ++v29;\n        }\n      }\n      v20 = 1;\n      s = a9;\n      n = strlen(a9);\n      goto LABEL_33;\n    }\n    a5 = 3;\n    v21 = 1;\nLABEL_11:\n    if ( !v21 )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(a1 + v29) = 34;\n      ++v29;\n    }\n    v20 = 1;\n    s = (char *)L\"\\\"`'\";\n    n = 1LL;\n    goto LABEL_33;\n  }\n  if ( a5 == 1 )\n  {\n    a5 = 2;\n    v21 = 1;\n    goto LABEL_27;\n  }\n  if ( a5 > 1 )\n  {\nLABEL_27:\n    if ( !v21 )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(a1 + v29) = 39;\n      ++v29;\n    }\n    s = (_BYTE *)(L\"\\\"`'\" + 4);\n    n = 1LL;\n    goto LABEL_33;\n  }\n  v21 = 0;\nLABEL_33:\n  for ( i = 0LL; a4 == -1LL ? *(_BYTE *)(a3 + i) != 0 : i != a4; ++i )\n  {\n    v24 = 0;\n    if ( v20 && n && i + n <= a4 && !memcmp((const void *)(a3 + i), s, n) )\n    {\n      if ( v21 )\n        return sub_403DF7(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n      v24 = 1;\n    }\n    v22 = *(_BYTE *)(a3 + i);\n    if ( v22 > 0x3Au )\n    {\n      if ( v22 == 94 )\n        goto LABEL_144;\n      if ( v22 > 0x5Eu )\n      {\n        if ( v22 <= 0x7Au )\n        {\n          if ( v22 >= 0x61u || v22 == 95 )\n            goto LABEL_206;\n          goto LABEL_144;\n        }\n        if ( v22 != 124 )\n        {\n          if ( v22 < 0x7Cu || v22 == 125 )\n          {\n            if ( a4 == -1LL )\n              v10 = *(_BYTE *)(a3 + 1) != 0;\n            else\n              v10 = a4 != 1;\n            if ( v10 )\n              goto LABEL_206;\n          }\n          else if ( v22 != 126 )\n          {\nLABEL_157:\n            if ( v26 )\n            {\n              v32 = 1LL;\n              v25 = ((*__ctype_b_loc())[v22] & 0x4000) != 0;\n            }\n            else\n            {\n              memset(&p, 0, sizeof(p));\n              v32 = 0LL;\n              v25 = 1;\n              if ( a4 == -1LL )\n                a4 = strlen((const char *)a3);\n              do\n              {\n                v34 = mbrtowc(&pwc, (const char *)(v32 + i + a3), a4 - (v32 + i), &p);\n                if ( !v34 )\n                  break;\n                if ( v34 == -1LL )\n                {\n                  v25 = 0;\n                  break;\n                }\n                if ( v34 == -2LL )\n                {\n                  v25 = 0;\n                  while ( i + v32 < a4 && *(_BYTE *)(v32 + i + a3) )\n                    ++v32;\n                  break;\n                }\n                if ( v21 && a5 == 2 )\n                {\n                  for ( j = 1LL; j < v34; ++j )\n                  {\n                    v11 = *(char *)(j + v32 + i + a3);\n                    if ( v11 == 94 )\n                      return sub_403DF7(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    if ( v11 > 94 )\n                    {\n                      if ( v11 == 96 || v11 == 124 )\n                        return sub_403DF7(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    }\n                    else if ( (unsigned int)(v11 - 91) <= 1 )\n                    {\n                      return sub_403DF7(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    }\n                  }\n                }\n                if ( !iswprint(pwc) )\n                  v25 = 0;\n                v32 += v34;\n              }\n              while ( !mbsinit(&p) );\n            }\n            if ( v32 > 1 || v20 && !v25 )\n            {\n              v35 = i + v32;\n              while ( 1 )\n              {\n                if ( v20 && !v25 )\n                {\n                  if ( v21 )\n                    return sub_403DF7(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                  if ( v29 < a2 )\n                    *(_BYTE *)(a1 + v29) = 92;\n                  if ( ++v29 < a2 )\n                    *(_BYTE *)(v29 + a1) = (v22 >> 6) + 48;\n                  if ( ++v29 < a2 )\n                    *(_BYTE *)(v29 + a1) = ((v22 >> 3) & 7) + 48;\n                  ++v29;\n                  v22 = (v22 & 7) + 48;\n                }\n                else if ( v24 )\n                {\n                  if ( v29 < a2 )\n                    *(_BYTE *)(a1 + v29) = 92;\n                  ++v29;\n                  v24 = 0;\n                }\n                if ( i + 1 >= v35 )\n                  break;\n                if ( v29 < a2 )\n                  *(_BYTE *)(v29 + a1) = v22;\n                ++v29;\n                ++i;\n                v22 = *(_BYTE *)(a3 + i);\n              }\n              goto LABEL_215;\n            }\n            goto LABEL_206;\n          }\n          goto LABEL_143;\n        }\nLABEL_144:\n        if ( a5 == 2 && v21 )\n          return sub_403DF7(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        goto LABEL_206;\n      }\n      if ( v22 > 0x5Au )\n      {\n        if ( v22 == 92 )\n        {\n          v23 = *(_BYTE *)(a3 + i);\n          if ( v20 && v21 && n )\n            goto LABEL_215;\n          goto LABEL_134;\n        }\n        if ( v22 <= 0x5Cu )\n          goto LABEL_144;\n      }\n      else\n      {\n        if ( v22 >= 0x41u )\n          goto LABEL_206;\n        if ( v22 <= 0x3Eu )\n          goto LABEL_144;\n        if ( v22 != 63 )\n          goto LABEL_157;\n        if ( a5 == 2 )\n        {\n          if ( v21 )\n            return sub_403DF7(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        }\n        else if ( a5 == 3 && (a6 & 4) != 0 && i + 2 < a4 && *(_BYTE *)(i + 1 + a3) == 63 )\n        {\n          v9 = *(char *)(i + 2 + a3);\n          if ( v9 != 45 )\n          {\n            if ( v9 > 45 )\n            {\n              if ( v9 != 47 && (v9 < 47 || (unsigned int)(v9 - 60) > 2) )\n                goto LABEL_206;\n            }\n            else if ( v9 != 33 && (v9 < 33 || (unsigned int)(v9 - 39) > 2) )\n            {\n              goto LABEL_206;\n            }\n          }\n          if ( v21 )\n            return sub_403DF7(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          v22 = *(_BYTE *)(i + 2 + a3);\n          i += 2LL;\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 63;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 34;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 34;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 63;\n          ++v29;\n        }\n      }\n    }\n    else\n    {\n      if ( v22 >= 0x2Bu )\n        goto LABEL_206;\n      if ( v22 > 0x22u )\n      {\n        if ( v22 != 38 )\n        {\n          if ( v22 > 0x26u )\n          {\n            if ( v22 == 39 )\n            {\n              if ( a5 == 2 )\n              {\n                if ( v21 )\n                  return sub_403DF7(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                if ( v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 39;\n                if ( ++v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 92;\n                if ( ++v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 39;\n                ++v29;\n              }\n              goto LABEL_206;\n            }\n            goto LABEL_144;\n          }\n          if ( v22 != 36 )\n          {\n            if ( v22 > 0x24u )\n              goto LABEL_206;\nLABEL_143:\n            if ( i )\n              goto LABEL_206;\n          }\n        }\n        goto LABEL_144;\n      }\n      if ( v22 >= 0x20u )\n        goto LABEL_144;\n      if ( v22 == 9 )\n      {\n        v23 = 116;\n        goto LABEL_134;\n      }\n      if ( v22 > 9u )\n      {\n        if ( v22 == 11 )\n        {\n          v23 = 118;\n        }\n        else\n        {\n          if ( v22 < 0xBu )\n          {\n            v23 = 110;\n            goto LABEL_134;\n          }\n          if ( v22 == 12 )\n          {\n            v23 = 102;\n          }\n          else\n          {\n            if ( v22 != 13 )\n              goto LABEL_157;\n            v23 = 114;\nLABEL_134:\n            if ( a5 == 2 && v21 )\n              return sub_403DF7(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          }\n        }\nLABEL_136:\n        if ( v20 )\n        {\n          v22 = v23;\nLABEL_211:\n          if ( v21 )\n            return sub_403DF7(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 92;\n          ++v29;\n          goto LABEL_215;\n        }\n        goto LABEL_206;\n      }\n      if ( v22 == 7 )\n      {\n        v23 = 97;\n        goto LABEL_136;\n      }\n      if ( v22 > 7u )\n      {\n        v23 = 98;\n        goto LABEL_136;\n      }\n      if ( v22 )\n        goto LABEL_157;\n      if ( v20 )\n      {\n        if ( v21 )\n          return sub_403DF7(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        if ( v29 < a2 )\n          *(_BYTE *)(a1 + v29) = 92;\n        ++v29;\n        if ( i + 1 < a4 && *(char *)(i + 1 + a3) > 47 && *(char *)(i + 1 + a3) <= 57 )\n        {\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 48;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 48;\n          ++v29;\n        }\n        v22 = 48;\n      }\n      else if ( (a6 & 1) != 0 )\n      {\n        continue;\n      }\n    }\nLABEL_206:\n    if ( (v20 == 1 || v21) && a7 && (*(_DWORD *)(4LL * (v22 >> 5) + a7) & (1 << (v22 & 0x1F))) != 0 || v24 == 1 )\n      goto LABEL_211;\nLABEL_215:\n    if ( v29 < a2 )\n      *(_BYTE *)(v29 + a1) = v22;\n    ++v29;\n  }\n  if ( !v29 && a5 == 2 && v21 )\n    return sub_403DF7(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n  if ( s && !v21 )\n  {\n    while ( *s )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(v29 + a1) = *s;\n      ++v29;\n      ++s;\n    }\n  }\n  if ( v29 < a2 )\n    *(_BYTE *)(a1 + v29) = 0;\n  return v29;\n}\n"], [4213314, "sub_404A42", "unsigned __int64 __fastcall sub_404A42(__int64 a1, unsigned __int64 a2, __int64 a3, size_t a4, __int64 *a5)\n{\n  __int64 *v5; // rax\n  int v9; // [rsp+4Ch] [rbp-14h]\n  __int64 *v10; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+58h] [rbp-8h]\n\n  if ( a5 )\n    v5 = a5;\n  else\n    v5 = &qword_60C680;\n  v10 = v5;\n  v9 = *__errno_location();\n  v11 = sub_403DF7(\n          a1,\n          a2,\n          a3,\n          a4,\n          *(_DWORD *)v10,\n          *((_DWORD *)v10 + 1),\n          (__int64)(v10 + 1),\n          (char *)v10[5],\n          (char *)v10[6]);\n  *__errno_location() = v9;\n  return v11;\n}\n"], [4213474, "sub_404AE2", "__int64 __fastcall sub_404AE2(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_404B14(a1, a2, 0LL, a3);\n}\n"], [4213524, "sub_404B14", "__int64 __fastcall sub_404B14(__int64 a1, size_t a2, _QWORD *a3, __int64 *a4)\n{\n  __int64 *v4; // rax\n  int v7; // [rsp+40h] [rbp-20h]\n  int v8; // [rsp+44h] [rbp-1Ch]\n  __int64 *v9; // [rsp+48h] [rbp-18h]\n  unsigned __int64 v10; // [rsp+50h] [rbp-10h]\n  __int64 v11; // [rsp+58h] [rbp-8h]\n\n  if ( a4 )\n    v4 = a4;\n  else\n    v4 = &qword_60C680;\n  v9 = v4;\n  v7 = *__errno_location();\n  v8 = *((_DWORD *)v9 + 1) | (a3 == 0LL);\n  v10 = sub_403DF7(0LL, 0LL, a1, a2, *(_DWORD *)v9, v8, (__int64)(v9 + 1), (char *)v9[5], (char *)v9[6]) + 1;\n  v11 = sub_40625C(v10);\n  sub_403DF7(v11, v10, a1, a2, *(_DWORD *)v9, v8, (__int64)(v9 + 1), (char *)v9[5], (char *)v9[6]);\n  *__errno_location() = v7;\n  if ( a3 )\n    *a3 = v10 - 1;\n  return v11;\n}\n"], [4213824, "sub_404C40", "void sub_404C40()\n{\n  unsigned int i; // [rsp+4h] [rbp-Ch]\n  void **ptr; // [rsp+8h] [rbp-8h]\n\n  ptr = (void **)off_60C2F0;\n  for ( i = 1; i < dword_60C2D0; ++i )\n    free(ptr[2 * i + 1]);\n  if ( ptr[1] != &unk_60C6C0 )\n  {\n    free(ptr[1]);\n    qword_60C2E0 = 256LL;\n    off_60C2E8 = &unk_60C6C0;\n  }\n  if ( ptr != (void **)&qword_60C2E0 )\n  {\n    free(ptr);\n    off_60C2F0 = &qword_60C2E0;\n  }\n  dword_60C2D0 = 1;\n}\n"], [4213995, "sub_404CEB", "void *__fastcall sub_404CEB(int a1, __int64 a2, size_t a3, __int64 a4)\n{\n  __int64 *v4; // rax\n  void *v5; // rdx\n  bool v9; // [rsp+4Bh] [rbp-45h]\n  int v10; // [rsp+4Ch] [rbp-44h]\n  int v11; // [rsp+54h] [rbp-3Ch]\n  __int64 *v12; // [rsp+58h] [rbp-38h]\n  void *ptr; // [rsp+60h] [rbp-30h]\n  __int64 v14; // [rsp+68h] [rbp-28h]\n  unsigned __int64 v15; // [rsp+70h] [rbp-20h]\n  unsigned __int64 v16; // [rsp+70h] [rbp-20h]\n  unsigned __int64 v17; // [rsp+78h] [rbp-18h]\n\n  v10 = *__errno_location();\n  v12 = off_60C2F0;\n  if ( a1 < 0 )\n    abort();\n  if ( dword_60C2D0 <= (unsigned int)a1 )\n  {\n    v14 = (unsigned int)(a1 + 1);\n    v9 = off_60C2F0 == &qword_60C2E0;\n    if ( off_60C2F0 == &qword_60C2E0 )\n      v4 = 0LL;\n    else\n      v4 = off_60C2F0;\n    v12 = (__int64 *)sub_4062AB(v4, 16 * v14);\n    off_60C2F0 = v12;\n    if ( v9 )\n    {\n      v5 = off_60C2E8;\n      *v12 = qword_60C2E0;\n      v12[1] = (__int64)v5;\n    }\n    memset(&v12[2 * (unsigned int)dword_60C2D0], 0, 16 * (v14 - (unsigned int)dword_60C2D0));\n    dword_60C2D0 = a1 + 1;\n  }\n  v15 = v12[2 * a1];\n  ptr = (void *)v12[2 * a1 + 1];\n  v11 = *(_DWORD *)(a4 + 4) | 1;\n  v17 = sub_403DF7((__int64)ptr, v15, a2, a3, *(_DWORD *)a4, v11, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 48));\n  if ( v15 <= v17 )\n  {\n    v16 = v17 + 1;\n    v12[2 * a1] = v17 + 1;\n    if ( ptr != &unk_60C6C0 )\n      free(ptr);\n    ptr = (void *)sub_40625C(v16);\n    v12[2 * a1 + 1] = (__int64)ptr;\n    sub_403DF7((__int64)ptr, v16, a2, a3, *(_DWORD *)a4, v11, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 48));\n  }\n  *__errno_location() = v10;\n  return ptr;\n}\n"], [4214641, "sub_404F71", "void *__fastcall sub_404F71(int a1, __int64 a2)\n{\n  return sub_404CEB(a1, a2, 0xFFFFFFFFFFFFFFFFLL, (__int64)&qword_60C680);\n}\n"], [4214684, "sub_404F9C", "void *__fastcall sub_404F9C(int a1, __int64 a2, size_t a3)\n{\n  return sub_404CEB(a1, a2, a3, (__int64)&qword_60C680);\n}\n"], [4214728, "sub_404FC8", "void *__fastcall sub_404FC8(__int64 a1)\n{\n  return sub_404F71(0, a1);\n}\n"], [4214759, "sub_404FE7", "void *__fastcall sub_404FE7(__int64 a1, size_t a2)\n{\n  return sub_404F9C(0, a1, a2);\n}\n"], [4214798, "sub_40500E", "void *__fastcall sub_40500E(int a1, int a2, __int64 a3)\n{\n  _QWORD v5[8]; // [rsp+10h] [rbp-40h] BYREF\n\n  sub_403D42(v5, a2);\n  return sub_404CEB(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)v5);\n}\n"], [4214863, "sub_40504F", "void *__fastcall sub_40504F(int a1, int a2, __int64 a3, size_t a4)\n{\n  _QWORD v7[8]; // [rsp+20h] [rbp-40h] BYREF\n\n  sub_403D42(v7, a2);\n  return sub_404CEB(a1, a3, a4, (__int64)v7);\n}\n"], [4214926, "sub_40508E", "void *__fastcall sub_40508E(int a1, __int64 a2)\n{\n  return sub_40500E(0, a1, a2);\n}\n"], [4214962, "sub_4050B2", "void *__fastcall sub_4050B2(int a1, __int64 a2, size_t a3)\n{\n  return sub_40504F(0, a1, a2, a3);\n}\n"], [4215006, "sub_4050DE", "void *__fastcall sub_4050DE(__int64 a1, size_t a2, unsigned __int8 a3)\n{\n  __int64 v4[8]; // [rsp+20h] [rbp-40h] BYREF\n\n  v4[0] = qword_60C680;\n  v4[1] = qword_60C688;\n  v4[2] = qword_60C690;\n  v4[3] = qword_60C698;\n  v4[4] = qword_60C6A0;\n  v4[5] = qword_60C6A8;\n  v4[6] = qword_60C6B0;\n  sub_403C2D(v4, a3, 1);\n  return sub_404CEB(0, a1, a2, (__int64)v4);\n}\n"], [4215154, "sub_405172", "void *__fastcall sub_405172(__int64 a1, unsigned __int8 a2)\n{\n  return sub_4050DE(a1, 0xFFFFFFFFFFFFFFFFLL, a2);\n}\n"], [4215196, "sub_40519C", "void *__fastcall sub_40519C(__int64 a1)\n{\n  return sub_405172(a1, 0x3Au);\n}\n"], [4215227, "sub_4051BB", "void *__fastcall sub_4051BB(__int64 a1, size_t a2)\n{\n  return sub_4050DE(a1, a2, 0x3Au);\n}\n"], [4215269, "sub_4051E5", "__int64 __fastcall sub_4051E5(unsigned int a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  return sub_40521B(a1, a2, a3, a4, -1LL);\n}\n"], [4215323, "sub_40521B", "void *__fastcall sub_40521B(int a1, __int64 a2, __int64 a3, __int64 a4, size_t a5)\n{\n  __int64 v8[8]; // [rsp+30h] [rbp-40h] BYREF\n\n  v8[0] = qword_60C680;\n  v8[1] = qword_60C688;\n  v8[2] = qword_60C690;\n  v8[3] = qword_60C698;\n  v8[4] = qword_60C6A0;\n  v8[5] = qword_60C6A8;\n  v8[6] = qword_60C6B0;\n  sub_403CE8(v8, a2, a3);\n  return sub_404CEB(a1, a4, a5, (__int64)v8);\n}\n"], [4215474, "sub_4052B2", "__int64 __fastcall sub_4052B2(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_4051E5(0, a1, a2, a3);\n}\n"], [4215521, "sub_4052E1", "void *__fastcall sub_4052E1(__int64 a1, __int64 a2, __int64 a3, size_t a4)\n{\n  return sub_40521B(0, a1, a2, a3, a4);\n}\n"], [4215579, "sub_40531B", "__int64 __fastcall sub_40531B(const void *a1, size_t a2)\n{\n  __int64 result; // rax\n  _BYTE *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = memchr(a1, 0, a2);\n  if ( v3 )\n    result = v3 - (_BYTE *)a1 + 1;\n  else\n    result = a2;\n  return result;\n}\n"], [4215653, "sub_405365", "bool __fastcall sub_405365(unsigned __int8 a1)\n{\n  return (((unsigned int)dword_40A540[a1 >> 5] >> (a1 & 0x1F)) & 1) != 0;\n}\n"], [4215707, "sub_40539B", "__int64 __fastcall sub_40539B(__int64 a1)\n{\n  __int64 result; // rax\n\n  result = *(unsigned __int8 *)(a1 + 20);\n  if ( !(_BYTE)result )\n  {\n    if ( !*(_BYTE *)(a1 + 8) )\n    {\n      if ( sub_405365(**(_BYTE **)(a1 + 24)) )\n      {\n        *(_QWORD *)(a1 + 32) = 1LL;\n        *(_DWORD *)(a1 + 44) = **(char **)(a1 + 24);\n        *(_BYTE *)(a1 + 40) = 1;\nLABEL_19:\n        result = a1;\n        *(_BYTE *)(a1 + 20) = 1;\n        return result;\n      }\n      if ( !mbsinit((const mbstate_t *)(a1 + 12)) )\n        __assert_fail(\"mbsinit (&iter->state)\", \"../../src/lib/mbiter.h\", 0x86u, \"mbiter_multi_next\");\n      *(_BYTE *)(a1 + 8) = 1;\n    }\n    *(_QWORD *)(a1 + 32) = mbrtowc(\n                             (wchar_t *)(a1 + 44),\n                             *(const char **)(a1 + 24),\n                             *(_QWORD *)a1 - *(_QWORD *)(a1 + 24),\n                             (mbstate_t *)(a1 + 12));\n    if ( *(_QWORD *)(a1 + 32) == -1LL )\n    {\n      *(_QWORD *)(a1 + 32) = 1LL;\n      *(_BYTE *)(a1 + 40) = 0;\n    }\n    else if ( *(_QWORD *)(a1 + 32) == -2LL )\n    {\n      *(_QWORD *)(a1 + 32) = *(_QWORD *)a1 - *(_QWORD *)(a1 + 24);\n      *(_BYTE *)(a1 + 40) = 0;\n    }\n    else\n    {\n      if ( !*(_QWORD *)(a1 + 32) )\n      {\n        *(_QWORD *)(a1 + 32) = 1LL;\n        if ( **(_BYTE **)(a1 + 24) )\n          __assert_fail(\"*iter->cur.ptr == '\\\\0'\", \"../../src/lib/mbiter.h\", 0xA1u, \"mbiter_multi_next\");\n        if ( *(_DWORD *)(a1 + 44) )\n          __assert_fail(\"iter->cur.wc == 0\", \"../../src/lib/mbiter.h\", 0xA2u, \"mbiter_multi_next\");\n      }\n      *(_BYTE *)(a1 + 40) = 1;\n      if ( mbsinit((const mbstate_t *)(a1 + 12)) )\n        *(_BYTE *)(a1 + 8) = 0;\n    }\n    goto LABEL_19;\n  }\n  return result;\n}\n"], [4216189, "sub_40557D", "char *__fastcall sub_40557D(const char *a1, int a2)\n{\n  size_t v2; // rax\n  size_t v3; // rax\n  int v5; // [rsp+14h] [rbp-7Ch]\n  char *v6; // [rsp+18h] [rbp-78h]\n  char *i; // [rsp+20h] [rbp-70h]\n  char *j; // [rsp+20h] [rbp-70h]\n  char *v9; // [rsp+28h] [rbp-68h]\n  unsigned __int64 v10; // [rsp+30h] [rbp-60h] BYREF\n  char v11; // [rsp+38h] [rbp-58h]\n  int v12; // [rsp+3Ch] [rbp-54h] BYREF\n  char k; // [rsp+44h] [rbp-4Ch]\n  char *v14; // [rsp+48h] [rbp-48h]\n  __int64 v15; // [rsp+50h] [rbp-40h]\n  char v16; // [rsp+58h] [rbp-38h]\n  wint_t wc; // [rsp+5Ch] [rbp-34h]\n  unsigned __int64 v18; // [rsp+78h] [rbp-18h]\n\n  v18 = __readfsqword(0x28u);\n  v9 = strdup(a1);\n  if ( !v9 )\n    sub_4063F8();\n  if ( __ctype_get_mb_cur_max() <= 1 )\n  {\n    if ( a2 )\n    {\n      for ( i = v9; *i && ((*__ctype_b_loc())[(unsigned __int8)*i] & 0x2000) != 0; ++i )\n        ;\n      v3 = strlen(i);\n      memmove(v9, i, v3 + 1);\n    }\n    if ( a2 != 1 )\n    {\n      for ( j = &v9[strlen(v9) - 1]; j >= v9 && ((*__ctype_b_loc())[(unsigned __int8)*j] & 0x2000) != 0; --j )\n        *j = 0;\n    }\n  }\n  else\n  {\n    if ( a2 )\n    {\n      v14 = v9;\n      v10 = (unsigned __int64)&v9[strlen(v9)];\n      v11 = 0;\n      memset(&v12, 0, 8uLL);\n      for ( k = 0; (unsigned __int64)v14 < v10; k = 0 )\n      {\n        sub_40539B((__int64)&v10);\n        if ( !v16 || !iswspace(wc) )\n          break;\n        v14 += v15;\n      }\n      v2 = strlen(v14);\n      memmove(v9, v14, v2 + 1);\n    }\n    if ( a2 != 1 )\n    {\n      v5 = 0;\n      v14 = v9;\n      v10 = (unsigned __int64)&v9[strlen(v9)];\n      v11 = 0;\n      memset(&v12, 0, 8uLL);\n      k = 0;\n      while ( (unsigned __int64)v14 < v10 )\n      {\n        sub_40539B((__int64)&v10);\n        if ( v5 || !v16 || !iswspace(wc) )\n        {\n          if ( v5 || v16 == 1 && iswspace(wc) )\n          {\n            if ( v5 != 1 || v16 == 1 && iswspace(wc) )\n            {\n              if ( v5 == 1 && v16 && iswspace(wc) )\n              {\n                v5 = 2;\n                v6 = v14;\n              }\n              else if ( v5 != 2 || !v16 || !iswspace(wc) )\n              {\n                v5 = 1;\n              }\n            }\n          }\n          else\n          {\n            v5 = 1;\n          }\n        }\n        v14 += v15;\n        k = 0;\n      }\n      if ( v5 == 2 )\n        *v6 = 0;\n    }\n  }\n  return v9;\n}\n"], [4217052, "sub_4058DC", "int __fastcall sub_4058DC(FILE *a1, const char *a2, const char *a3, const char *a4, __int64 *a5, unsigned __int64 a6)\n{\n  char *v6; // rax\n  char *v7; // rax\n  __int64 v8; // rbx\n  char *v9; // rax\n  __int64 v10; // r12\n  __int64 v11; // rbx\n  char *v12; // rax\n  __int64 v13; // r13\n  __int64 v14; // r12\n  __int64 v15; // rbx\n  char *v16; // rax\n  int result; // eax\n  __int64 v18; // r14\n  __int64 v19; // r13\n  __int64 v20; // r12\n  __int64 v21; // rbx\n  char *v22; // rax\n  __int64 v23; // r13\n  __int64 v24; // r15\n  __int64 v25; // r14\n  __int64 v26; // r12\n  __int64 v27; // rbx\n  char *v28; // rax\n  __int64 v29; // r14\n  __int64 v30; // r13\n  __int64 v31; // r15\n  __int64 v32; // r12\n  __int64 v33; // rbx\n  char *v34; // rax\n  __int64 v35; // r15\n  __int64 v36; // r14\n  __int64 v37; // r13\n  __int64 v38; // r12\n  __int64 v39; // rbx\n  char *v40; // rax\n  __int64 v41; // r15\n  __int64 v42; // r14\n  __int64 v43; // r13\n  __int64 v44; // r12\n  __int64 v45; // rbx\n  char *v46; // rax\n  __int64 v47; // r15\n  __int64 v48; // r14\n  __int64 v49; // r13\n  __int64 v50; // r12\n  __int64 v51; // rbx\n  char *v52; // rax\n  __int64 v53; // [rsp+30h] [rbp-80h]\n  __int64 v54; // [rsp+38h] [rbp-78h]\n  __int64 v55; // [rsp+38h] [rbp-78h]\n  __int64 v56; // [rsp+40h] [rbp-70h]\n  __int64 v57; // [rsp+40h] [rbp-70h]\n  __int64 v58; // [rsp+40h] [rbp-70h]\n  __int64 v59; // [rsp+48h] [rbp-68h]\n  __int64 v60; // [rsp+48h] [rbp-68h]\n  __int64 v61; // [rsp+48h] [rbp-68h]\n  __int64 v62; // [rsp+48h] [rbp-68h]\n\n  if ( a2 )\n    fprintf(a1, \"%s (%s) %s\\n\", a2, a3, a4);\n  else\n    fprintf(a1, \"%s %s\\n\", a3, a4);\n  v6 = gettext(\"(C)\");\n  fprintf(a1, \"Copyright %s %d Free Software Foundation, Inc.\", v6, 2011LL);\n  v7 = gettext(\n         \"\\n\"\n         \"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n         \"\\n\");\n  fputs_unlocked(v7, a1);\n  if ( a6 == 4 )\n  {\n    v18 = a5[3];\n    v19 = a5[2];\n    v20 = a5[1];\n    v21 = *a5;\n    v22 = gettext(\"Written by %s, %s, %s,\\nand %s.\\n\");\n    result = fprintf(a1, v22, v21, v20, v19, v18);\n  }\n  else if ( a6 > 4 )\n  {\n    if ( a6 == 7 )\n    {\n      v35 = a5[6];\n      v36 = a5[5];\n      v37 = a5[4];\n      v60 = a5[3];\n      v56 = a5[2];\n      v38 = a5[1];\n      v39 = *a5;\n      v40 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\");\n      result = fprintf(a1, v40, v39, v38, v56, v60, v37, v36, v35);\n    }\n    else if ( a6 > 7 )\n    {\n      if ( a6 == 8 )\n      {\n        v61 = a5[7];\n        v41 = a5[6];\n        v42 = a5[5];\n        v43 = a5[4];\n        v57 = a5[3];\n        v54 = a5[2];\n        v44 = a5[1];\n        v45 = *a5;\n        v46 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\");\n        result = fprintf(a1, v46, v45, v44, v54, v57, v43, v42, v41, v61);\n      }\n      else\n      {\n        v62 = a5[8];\n        v58 = a5[7];\n        v47 = a5[6];\n        v48 = a5[5];\n        v49 = a5[4];\n        v55 = a5[3];\n        v53 = a5[2];\n        v50 = a5[1];\n        v51 = *a5;\n        if ( a6 == 9 )\n          v52 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\");\n        else\n          v52 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\");\n        result = fprintf(a1, v52, v51, v50, v53, v55, v49, v48, v47, v58, v62);\n      }\n    }\n    else if ( a6 == 5 )\n    {\n      v23 = a5[4];\n      v24 = a5[3];\n      v25 = a5[2];\n      v26 = a5[1];\n      v27 = *a5;\n      v28 = gettext(\"Written by %s, %s, %s,\\n%s, and %s.\\n\");\n      result = fprintf(a1, v28, v27, v26, v25, v24, v23);\n    }\n    else\n    {\n      v29 = a5[5];\n      v30 = a5[4];\n      v59 = a5[3];\n      v31 = a5[2];\n      v32 = a5[1];\n      v33 = *a5;\n      v34 = gettext(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\");\n      result = fprintf(a1, v34, v33, v32, v31, v59, v30, v29);\n    }\n  }\n  else\n  {\n    switch ( a6 )\n    {\n      case 1uLL:\n        v8 = *a5;\n        v9 = gettext(\"Written by %s.\\n\");\n        result = fprintf(a1, v9, v8);\n        break;\n      case 0uLL:\n        abort();\n      case 2uLL:\n        v10 = a5[1];\n        v11 = *a5;\n        v12 = gettext(\"Written by %s and %s.\\n\");\n        result = fprintf(a1, v12, v11, v10);\n        break;\n      default:\n        v13 = a5[2];\n        v14 = a5[1];\n        v15 = *a5;\n        v16 = gettext(\"Written by %s, %s, and %s.\\n\");\n        result = fprintf(a1, v16, v15, v14, v13);\n        break;\n    }\n  }\n  return result;\n}\n"], [4218567, "sub_405EC7", "int __fastcall sub_405EC7(FILE *a1, const char *a2, const char *a3, const char *a4, __int64 *a5)\n{\n  unsigned __int64 i; // [rsp+38h] [rbp-8h]\n\n  for ( i = 0LL; a5[i]; ++i )\n    ;\n  return sub_4058DC(a1, a2, a3, a4, a5, i);\n}\n"], [4218677, "sub_405F35", "int __fastcall sub_405F35(FILE *a1, const char *a2, const char *a3, const char *a4, unsigned int *a5)\n{\n  __int64 *v5; // rax\n  unsigned __int64 i; // [rsp+38h] [rbp-58h]\n  __int64 v8[10]; // [rsp+40h] [rbp-50h] BYREF\n\n  for ( i = 0LL; i <= 9; ++i )\n  {\n    if ( *a5 >= 0x30 )\n    {\n      v5 = (__int64 *)*((_QWORD *)a5 + 1);\n      *((_QWORD *)a5 + 1) = v5 + 1;\n    }\n    else\n    {\n      v5 = (__int64 *)(*((_QWORD *)a5 + 2) + *a5);\n      *a5 += 8;\n    }\n    v8[i] = *v5;\n    if ( !v8[i] )\n      break;\n  }\n  return sub_4058DC(a1, a2, a3, a4, v8, i);\n}\n"], [4218894, "sub_40600E", "int sub_40600E(FILE *a1, const char *a2, const char *a3, const char *a4, ...)\n{\n  gcc_va_list va; // [rsp+28h] [rbp-C8h] BYREF\n\n  va_start(va, a4);\n  return sub_405F35(a1, a2, a3, a4, (unsigned int *)va);\n}\n"], [4219076, "sub_4060C4", "int sub_4060C4()\n{\n  char *v0; // rax\n  char *v1; // rax\n  FILE *v2; // rbx\n  char *v3; // rax\n\n  v0 = gettext(\"\\nReport bugs to: %s\\n\");\n  printf(v0, \"bug-coreutils@gnu.org\");\n  v1 = gettext(\"%s home page: <%s>\\n\");\n  printf(v1, \"GNU coreutils\", \"http://www.gnu.org/software/coreutils/\");\n  v2 = stdout;\n  v3 = gettext(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\");\n  return fputs_unlocked(v3, v2);\n}\n"], [4219181, "sub_40612D", "__int64 __fastcall sub_40612D(unsigned __int64 a1, unsigned __int64 a2)\n{\n  if ( 0xFFFFFFFFFFFFFFFFLL / a2 < a1 )\n    sub_4063F8(a1, a2, 0xFFFFFFFFFFFFFFFFLL % a2);\n  return sub_406276(a2 * a1);\n}\n"], [4219243, "sub_40616B", "__int64 __fastcall sub_40616B(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)\n{\n  unsigned __int64 v3; // rax\n  unsigned __int64 v4; // rdx\n\n  v3 = 0xFFFFFFFFFFFFFFFFLL / a3;\n  v4 = 0xFFFFFFFFFFFFFFFFLL % a3;\n  if ( v3 < a2 )\n    sub_4063F8(a1, a2, v4);\n  return sub_4062AB(a1, a3 * a2);\n}\n"], [4219319, "sub_4061B7", "__int64 __fastcall sub_4061B7(__int64 a1, unsigned __int64 *a2, unsigned __int64 a3)\n{\n  unsigned __int64 v3; // rdx\n  unsigned __int64 v6; // [rsp+28h] [rbp-8h]\n\n  v6 = *a2;\n  if ( a1 )\n  {\n    v3 = 0xAAAAAAAAAAAAAAAALL % a3;\n    if ( 0xAAAAAAAAAAAAAAAALL / a3 <= v6 )\n      sub_4063F8(a1, a2, v3);\n    v6 += (v6 + 1) >> 1;\n  }\n  else if ( !v6 )\n  {\n    v6 = (0x80 / a3 == 0) + 0x80 / a3;\n  }\n  *a2 = v6;\n  return sub_4062AB(a1, a3 * v6);\n}\n"], [4219484, "sub_40625C", "__int64 __fastcall sub_40625C(__int64 a1)\n{\n  return sub_406276(a1);\n}\n"], [4219510, "sub_406276", "void *__fastcall sub_406276(size_t a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  void *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = malloc(a1);\n  if ( !v4 && a1 )\n    sub_4063F8(a1, a2, v2);\n  return v4;\n}\n"], [4219563, "sub_4062AB", "void *__fastcall sub_4062AB(void *a1, size_t a2)\n{\n  void *result; // rax\n  __int64 v3; // rdx\n  void *ptr; // [rsp+8h] [rbp-8h]\n\n  if ( a2 || !a1 )\n  {\n    ptr = realloc(a1, a2);\n    if ( !ptr )\n    {\n      if ( a2 )\n        sub_4063F8(a1, a2, v3);\n    }\n    result = ptr;\n  }\n  else\n  {\n    free(a1);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4219660, "sub_40630C", "__int64 __fastcall sub_40630C(__int64 a1, unsigned __int64 *a2)\n{\n  return sub_4061B7(a1, a2, 1uLL);\n}\n"], [4219702, "sub_406336", "void *__fastcall sub_406336(size_t a1, __int64 a2)\n{\n  void *v2; // rax\n\n  v2 = sub_406276(a1, a2);\n  return memset(v2, 0, a1);\n}\n"], [4219745, "sub_406361", "void *__fastcall sub_406361(size_t a1, size_t a2)\n{\n  __int64 v2; // rdx\n  void *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = calloc(a1, a2);\n  if ( !v4 )\n    sub_4063F8(a1, a2, v2);\n  return v4;\n}\n"], [4219802, "sub_40639A", "void *__fastcall sub_40639A(const void *a1, size_t a2)\n{\n  void *v2; // rax\n\n  v2 = sub_406276(a2, a2);\n  return memcpy(v2, a1, a2);\n}\n"], [4219851, "sub_4063CB", "void *__fastcall sub_4063CB(const char *a1)\n{\n  size_t v1; // rax\n\n  v1 = strlen(a1);\n  return sub_40639A(a1, v1 + 1);\n}\n"], [4219896, "sub_4063F8", "void __noreturn sub_4063F8()\n{\n  char *v0; // rax\n\n  v0 = gettext(\"memory exhausted\");\n  error(status, 0, \"%s\", v0);\n  abort();\n}\n"], [4220039, "sub_406487", "__int64 __fastcall sub_406487(__int64 a1, __int64 a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_4087AA(a1, a2);\n  if ( !v3 && *__errno_location() == 12 )\n    sub_4063F8();\n  return v3;\n}\n"], [4220108, "sub_4064CC", "__int64 __fastcall sub_4064CC(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v4; // [rsp+28h] [rbp-8h]\n\n  v4 = sub_408ADF(a1, a2, a3);\n  if ( !v4 && *__errno_location() == 12 )\n    sub_4063F8();\n  return v4;\n}\n"], [4220185, "sub_406519", "__int64 __fastcall sub_406519(_BYTE *a1, _QWORD *a2, double *a3, double (__fastcall *a4)(_BYTE *, _BYTE **))\n{\n  unsigned __int8 v7; // [rsp+3Fh] [rbp-11h]\n  _BYTE *v8; // [rsp+40h] [rbp-10h] BYREF\n  double v9; // [rsp+48h] [rbp-8h]\n\n  v7 = 1;\n  *__errno_location() = 0;\n  v9 = a4(a1, &v8);\n  if ( v8 == a1 || !a2 && *v8 )\n  {\n    v7 = 0;\n  }\n  else if ( v9 != 0.0 && *__errno_location() == 34 )\n  {\n    v7 = 0;\n  }\n  if ( a2 )\n    *a2 = v8;\n  *a3 = v9;\n  return v7;\n}\n"], [4220364, "sub_4065CC", "__int64 __fastcall sub_4065CC(const char *a1)\n{\n  unsigned int i; // [rsp+14h] [rbp-2Ch]\n  int v3; // [rsp+18h] [rbp-28h]\n  int v4; // [rsp+1Ch] [rbp-24h]\n  char *endptr; // [rsp+20h] [rbp-20h] BYREF\n  __int64 v6; // [rsp+28h] [rbp-18h]\n  __int64 v7; // [rsp+30h] [rbp-10h]\n  __int64 v8; // [rsp+38h] [rbp-8h]\n\n  if ( (unsigned int)(*a1 - 48) > 9 )\n  {\n    for ( i = 0; i <= 0x22; ++i )\n    {\n      if ( !strcmp((const char *)(12LL * i + 6341380), a1) )\n        return dword_60C300[3 * i];\n    }\n    v3 = __libc_current_sigrtmin();\n    v4 = __libc_current_sigrtmax();\n    if ( v3 > 0 && !strncmp(a1, \"RTMIN\", 5uLL) )\n    {\n      v7 = strtol(a1 + 5, &endptr, 10);\n      if ( !*endptr && v7 >= 0 && v4 - v3 >= v7 )\n        return (unsigned int)(v7 + v3);\n    }\n    else if ( v4 > 0 && !strncmp(a1, \"RTMAX\", 5uLL) )\n    {\n      v8 = strtol(a1 + 5, &endptr, 10);\n      if ( !*endptr && v3 - v4 <= v8 && v8 <= 0 )\n        return (unsigned int)(v8 + v4);\n    }\n  }\n  else\n  {\n    v6 = strtol(a1, &endptr, 10);\n    if ( !*endptr && v6 <= 64 )\n      return v6;\n  }\n  return 0xFFFFFFFFLL;\n}\n"], [4220798, "sub_40677E", "__int64 __fastcall sub_40677E(const char *a1, int *a2)\n{\n  __int64 result; // rax\n\n  *a2 = sub_4065CC(a1);\n  if ( *a2 >= 0 )\n    result = 0LL;\n  else\n    result = 0xFFFFFFFFLL;\n  return result;\n}\n"], [4220856, "sub_4067B8", "__int64 __fastcall sub_4067B8(int a1, char *a2)\n{\n  unsigned int i; // [rsp+1Ch] [rbp-14h]\n  int v4; // [rsp+20h] [rbp-10h]\n  int v5; // [rsp+24h] [rbp-Ch]\n\n  for ( i = 0; i <= 0x22; ++i )\n  {\n    if ( dword_60C300[3 * i] == a1 )\n    {\n      strcpy(a2, (const char *)(12LL * i + 6341380));\n      return 0LL;\n    }\n  }\n  v4 = __libc_current_sigrtmin();\n  v5 = __libc_current_sigrtmax();\n  if ( v4 > a1 || a1 > v5 )\n    return 0xFFFFFFFFLL;\n  if ( (v5 - v4) / 2 + v4 < a1 )\n  {\n    if ( v5 == a1 )\n      sprintf(a2, \"RTMAX\");\n    else\n      sprintf(a2, \"RTMAX-%d\", (unsigned int)(v5 - a1));\n  }\n  else if ( a1 == v4 )\n  {\n    sprintf(a2, \"RTMIN\");\n  }\n  else\n  {\n    sprintf(a2, \"RTMIN+%d\", (unsigned int)(a1 - v4));\n  }\n  return 0LL;\n}\n"], [4221160, "sub_4068E8", "__int64 __fastcall sub_4068E8(unsigned __int8 *a1, unsigned __int8 *a2)\n{\n  unsigned __int8 *v2; // r12\n  unsigned __int8 *v3; // rbx\n  unsigned __int8 v5; // [rsp+1Eh] [rbp-12h]\n  unsigned __int8 v6; // [rsp+1Fh] [rbp-11h]\n\n  v2 = a1;\n  v3 = a2;\n  if ( a1 == a2 )\n    return 0LL;\n  do\n  {\n    v5 = sub_409015(*v2);\n    v6 = sub_409015(*v3);\n    if ( !v5 )\n      break;\n    ++v2;\n    ++v3;\n  }\n  while ( v5 == v6 );\n  return v5 - (unsigned int)v6;\n}\n"], [4221279, "sub_40695F", "__int64 __fastcall sub_40695F(FILE *a1)\n{\n  bool v2; // [rsp+1Dh] [rbp-3h]\n  bool v3; // [rsp+1Eh] [rbp-2h]\n  bool v4; // [rsp+1Fh] [rbp-1h]\n\n  v2 = __fpending(a1) != 0;\n  v3 = ferror_unlocked(a1) != 0;\n  v4 = (unsigned int)sub_408BE2(a1) != 0;\n  if ( !v3 && (!v4 || !v2 && *__errno_location() == 9) )\n    return 0LL;\n  if ( !v4 )\n    *__errno_location() = 0;\n  return 0xFFFFFFFFLL;\n}\n"], [4221418, "sub_4069EA", "void *sub_4069EA()\n{\n  _BOOL4 v0; // eax\n  size_t v1; // rax\n  _BOOL4 v3; // [rsp+4h] [rbp-FCh]\n  int fd; // [rsp+8h] [rbp-F8h]\n  int c; // [rsp+Ch] [rbp-F4h]\n  int ca; // [rsp+Ch] [rbp-F4h]\n  void *v7; // [rsp+10h] [rbp-F0h]\n  const char *s; // [rsp+18h] [rbp-E8h]\n  void *ptr; // [rsp+20h] [rbp-E0h]\n  __int64 v10; // [rsp+28h] [rbp-D8h]\n  size_t n; // [rsp+38h] [rbp-C8h]\n  size_t v12; // [rsp+40h] [rbp-C0h]\n  char *dest; // [rsp+48h] [rbp-B8h]\n  FILE *stream; // [rsp+50h] [rbp-B0h]\n  size_t v15; // [rsp+58h] [rbp-A8h]\n  size_t v16; // [rsp+60h] [rbp-A0h]\n  void *v17; // [rsp+68h] [rbp-98h]\n  char src[64]; // [rsp+70h] [rbp-90h] BYREF\n  char v19[56]; // [rsp+B0h] [rbp-50h] BYREF\n  unsigned __int64 v20; // [rsp+E8h] [rbp-18h]\n\n  v20 = __readfsqword(0x28u);\n  v7 = (void *)qword_60C7C0;\n  if ( !qword_60C7C0 )\n  {\n    s = getenv(\"CHARSETALIASDIR\");\n    if ( !s || !*s )\n      s = \"/root/Product/coreutils/exe/lib\";\n    n = strlen(s);\n    v12 = strlen(\"charset.alias\");\n    v0 = n && s[n - 1] != 47;\n    v3 = v0;\n    dest = (char *)malloc(n + v0 + v12 + 1);\n    if ( dest )\n    {\n      memcpy(dest, s, n);\n      if ( v3 )\n        dest[n] = 47;\n      memcpy(&dest[n + v3], \"charset.alias\", v12 + 1);\n    }\n    if ( dest )\n    {\n      fd = open(dest, 0x20000);\n      if ( fd >= 0 )\n      {\n        stream = fdopen(fd, \"r\");\n        if ( stream )\n        {\n          ptr = 0LL;\n          v10 = 0LL;\n          while ( 1 )\n          {\n            c = getc_unlocked(stream);\n            if ( c == -1 )\n              break;\n            if ( c != 10 && c != 32 && c != 9 )\n            {\n              if ( c == 35 )\n              {\n                do\n                  ca = getc_unlocked(stream);\n                while ( ca != -1 && ca != 10 );\n                if ( ca == -1 )\n                  break;\n              }\n              else\n              {\n                ungetc(c, stream);\n                if ( fscanf(stream, \"%50s %50s\", src, v19) <= 1 )\n                  break;\n                v15 = strlen(src);\n                v16 = strlen(v19);\n                v17 = ptr;\n                if ( v10 )\n                {\n                  v1 = v16 + v15 + v10;\n                  v10 = v1 + 2;\n                  ptr = realloc(ptr, v1 + 3);\n                }\n                else\n                {\n                  v10 = v15 + v16 + 2;\n                  ptr = malloc(v15 + v16 + 3);\n                }\n                if ( !ptr )\n                {\n                  v10 = 0LL;\n                  free(v17);\n                  break;\n                }\n                strcpy((char *)ptr + v10 - v16 - v15 - 2, src);\n                strcpy((char *)ptr + v10 - v16 - 1, v19);\n              }\n            }\n          }\n          sub_408BE2(stream);\n          if ( v10 )\n          {\n            *((_BYTE *)ptr + v10) = 0;\n            v7 = ptr;\n          }\n          else\n          {\n            v7 = &unk_40A528;\n          }\n        }\n        else\n        {\n          close(fd);\n          v7 = &unk_40A528;\n        }\n      }\n      else\n      {\n        v7 = &unk_40A528;\n      }\n      free(dest);\n    }\n    else\n    {\n      v7 = &unk_40A528;\n    }\n    qword_60C7C0 = (__int64)v7;\n  }\n  return v7;\n}\n"], [4222672, "sub_406ED0", "const char *sub_406ED0()\n{\n  const char *s1; // [rsp+0h] [rbp-10h]\n  char *s2; // [rsp+8h] [rbp-8h]\n  char *s2a; // [rsp+8h] [rbp-8h]\n\n  s1 = nl_langinfo(14);\n  if ( !s1 )\n    s1 = (const char *)&unk_40A528;\n  for ( s2 = (char *)sub_4069EA(); *s2; s2 = &s2a[strlen(s2a) + 1] )\n  {\n    if ( !strcmp(s1, s2) || *s2 == 42 && !s2[1] )\n    {\n      s1 = &s2[strlen(s2) + 1];\n      break;\n    }\n    s2a = &s2[strlen(s2) + 1];\n  }\n  if ( !*s1 )\n    s1 = \"ASCII\";\n  return s1;\n}\n"], [4222878, "sub_406F9E", "__int64 __fastcall sub_406F9E(__int64 a1, __int64 a2)\n{\n  __int64 result; // rax\n\n  if ( *(_QWORD *)a2 == a2 + 24 )\n  {\n    memcpy((void *)(a1 + 24), (const void *)(a2 + 24), *(_QWORD *)(a2 + 8));\n    *(_QWORD *)a1 = a1 + 24;\n  }\n  else\n  {\n    *(_QWORD *)a1 = *(_QWORD *)a2;\n  }\n  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);\n  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);\n  result = *(unsigned __int8 *)(a1 + 16);\n  if ( (_BYTE)result )\n  {\n    result = a1;\n    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);\n  }\n  return result;\n}\n"], [4223039, "sub_40703F", "bool __fastcall sub_40703F(unsigned __int8 a1)\n{\n  return (((unsigned int)dword_40A540[a1 >> 5] >> (a1 & 0x1F)) & 1) != 0;\n}\n"], [4223093, "sub_407075", "__int64 __fastcall sub_407075(__int64 a1)\n{\n  __int64 result; // rax\n  size_t v2; // rax\n  __int64 v3; // rax\n\n  result = *(unsigned __int8 *)(a1 + 12);\n  if ( !(_BYTE)result )\n  {\n    if ( !*(_BYTE *)a1 )\n    {\n      if ( sub_40703F(**(_BYTE **)(a1 + 16)) )\n      {\n        *(_QWORD *)(a1 + 24) = 1LL;\n        *(_DWORD *)(a1 + 36) = **(char **)(a1 + 16);\n        *(_BYTE *)(a1 + 32) = 1;\nLABEL_19:\n        result = a1;\n        *(_BYTE *)(a1 + 12) = 1;\n        return result;\n      }\n      if ( !mbsinit((const mbstate_t *)(a1 + 4)) )\n        __assert_fail(\"mbsinit (&iter->state)\", \"../../src/lib/mbuiter.h\", 0x8Eu, \"mbuiter_multi_next\");\n      *(_BYTE *)a1 = 1;\n    }\n    v2 = __ctype_get_mb_cur_max();\n    v3 = sub_40531B(*(const void **)(a1 + 16), v2);\n    *(_QWORD *)(a1 + 24) = mbrtowc((wchar_t *)(a1 + 36), *(const char **)(a1 + 16), v3, (mbstate_t *)(a1 + 4));\n    if ( *(_QWORD *)(a1 + 24) == -1LL )\n    {\n      *(_QWORD *)(a1 + 24) = 1LL;\n      *(_BYTE *)(a1 + 32) = 0;\n    }\n    else if ( *(_QWORD *)(a1 + 24) == -2LL )\n    {\n      *(_QWORD *)(a1 + 24) = strlen(*(const char **)(a1 + 16));\n      *(_BYTE *)(a1 + 32) = 0;\n    }\n    else\n    {\n      if ( !*(_QWORD *)(a1 + 24) )\n      {\n        *(_QWORD *)(a1 + 24) = 1LL;\n        if ( **(_BYTE **)(a1 + 16) )\n          __assert_fail(\"*iter->cur.ptr == '\\\\0'\", \"../../src/lib/mbuiter.h\", 0xAAu, \"mbuiter_multi_next\");\n        if ( *(_DWORD *)(a1 + 36) )\n          __assert_fail(\"iter->cur.wc == 0\", \"../../src/lib/mbuiter.h\", 0xABu, \"mbuiter_multi_next\");\n      }\n      *(_BYTE *)(a1 + 32) = 1;\n      if ( mbsinit((const mbstate_t *)(a1 + 4)) )\n        *(_BYTE *)a1 = 0;\n    }\n    goto LABEL_19;\n  }\n  return result;\n}\n"], [4223573, "sub_407255", "__int64 __fastcall sub_407255(_BYTE *a1, __int64 a2, unsigned __int64 a3, _QWORD *a4)\n{\n  void *v4; // rsp\n  unsigned __int64 v5; // rax\n  __int64 v8; // [rsp+8h] [rbp-68h] BYREF\n  __int64 v9; // [rsp+10h] [rbp-60h]\n  _BYTE *v10; // [rsp+18h] [rbp-58h]\n  char v11; // [rsp+27h] [rbp-49h]\n  unsigned __int64 i; // [rsp+28h] [rbp-48h]\n  __int64 v13; // [rsp+30h] [rbp-40h]\n  __int64 v14; // [rsp+38h] [rbp-38h]\n  _BYTE *v15; // [rsp+40h] [rbp-30h]\n  _BYTE *v16; // [rsp+48h] [rbp-28h]\n  unsigned __int64 v17; // [rsp+50h] [rbp-20h]\n  unsigned __int64 v18; // [rsp+58h] [rbp-18h]\n\n  v10 = a1;\n  v9 = a2;\n  HIBYTE(v8) = HIBYTE(a3);\n  v17 = a3;\n  if ( a3 > 0x1FFFFFFFFFFFFFFFLL )\n  {\n    v5 = 0LL;\n  }\n  else if ( 8 * v17 > 0xFAF )\n  {\n    v5 = sub_409055(8 * v17);\n  }\n  else\n  {\n    v4 = alloca(16 * ((8 * (v17 + 2) + 30) / 0x10));\n    v5 = 16 * (((unsigned __int64)&v8 + 7) >> 4) + 16;\n  }\n  v18 = v5;\n  if ( !v5 )\n    return 0LL;\n  *(_QWORD *)(v18 + 8) = 1LL;\n  v13 = 0LL;\n  for ( i = 2LL; i < v17; ++i )\n  {\n    v11 = *(_BYTE *)(i - 1 + v9);\n    while ( 1 )\n    {\n      if ( *(_BYTE *)(v9 + v13) == v11 )\n      {\n        ++v13;\n        *(_QWORD *)(8 * i + v18) = i - v13;\n        goto LABEL_15;\n      }\n      if ( !v13 )\n        break;\n      v13 -= *(_QWORD *)(8 * v13 + v18);\n    }\n    *(_QWORD *)(v18 + 8 * i) = i;\nLABEL_15:\n    ;\n  }\n  *a4 = 0LL;\n  v14 = 0LL;\n  v15 = v10;\n  v16 = v10;\n  while ( *v16 )\n  {\n    if ( *(_BYTE *)(v9 + v14) == *v16 )\n    {\n      ++v14;\n      ++v16;\n      if ( v14 == v17 )\n      {\n        *a4 = v15;\n        break;\n      }\n    }\n    else if ( v14 )\n    {\n      v15 += *(_QWORD *)(8 * v14 + v18);\n      v14 -= *(_QWORD *)(8 * v14 + v18);\n    }\n    else\n    {\n      ++v15;\n      ++v16;\n    }\n  }\n  sub_409110(v18);\n  return 1LL;\n}\n"], [4224159, "sub_40749F", "__int64 __fastcall sub_40749F(char *a1, void *a2, _QWORD *a3)\n{\n  void *v3; // rsp\n  unsigned __int64 v4; // rax\n  bool v7; // al\n  bool v8; // al\n  bool v9; // al\n  bool v10; // al\n  _QWORD *v14; // [rsp+8h] [rbp-108h] BYREF\n  void *v15; // [rsp+10h] [rbp-100h]\n  char *v16; // [rsp+18h] [rbp-F8h]\n  __int64 v17; // [rsp+20h] [rbp-F0h]\n  unsigned __int64 i; // [rsp+28h] [rbp-E8h]\n  __int64 v19; // [rsp+30h] [rbp-E0h]\n  __int64 v20; // [rsp+38h] [rbp-D8h]\n  __int64 v21; // [rsp+40h] [rbp-D0h]\n  unsigned __int64 v22; // [rsp+48h] [rbp-C8h]\n  unsigned __int64 v23; // [rsp+50h] [rbp-C0h]\n  unsigned __int64 v24; // [rsp+58h] [rbp-B8h]\n  unsigned __int64 v25; // [rsp+60h] [rbp-B0h]\n  unsigned __int64 v26; // [rsp+68h] [rbp-A8h]\n  char v27[4]; // [rsp+70h] [rbp-A0h] BYREF\n  int v28; // [rsp+74h] [rbp-9Ch] BYREF\n  char v29; // [rsp+7Ch] [rbp-94h]\n  char *v30; // [rsp+80h] [rbp-90h]\n  __int64 v31; // [rsp+88h] [rbp-88h]\n  char v32; // [rsp+90h] [rbp-80h]\n  int v33; // [rsp+94h] [rbp-7Ch]\n  char v34[4]; // [rsp+B0h] [rbp-60h] BYREF\n  int v35; // [rsp+B4h] [rbp-5Ch] BYREF\n  char v36; // [rsp+BCh] [rbp-54h]\n  void *s2; // [rsp+C0h] [rbp-50h] BYREF\n  __int64 v38; // [rsp+C8h] [rbp-48h]\n  char v39; // [rsp+D0h] [rbp-40h]\n  int v40; // [rsp+D4h] [rbp-3Ch]\n  unsigned __int64 v41; // [rsp+F8h] [rbp-18h]\n\n  v16 = a1;\n  v15 = a2;\n  v14 = a3;\n  v41 = __readfsqword(0x28u);\n  v22 = sub_4093EF(a2);\n  if ( v22 > 0x492492492492492LL )\n  {\n    v4 = 0LL;\n  }\n  else if ( 56 * v22 > 0xFAF )\n  {\n    v4 = sub_409055(56 * v22);\n  }\n  else\n  {\n    v3 = alloca(16 * ((56 * v22 + 46) / 0x10));\n    v4 = 16 * (((unsigned __int64)&v14 + 7) >> 4) + 16;\n  }\n  v23 = v4;\n  if ( !v4 )\n    return 0LL;\n  v24 = v23;\n  v25 = 48 * v22 + v23;\n  v17 = 0LL;\n  s2 = v15;\n  v34[0] = 0;\n  memset(&v35, 0, 8uLL);\n  v36 = 0;\n  while ( 1 )\n  {\n    sub_407075((__int64)v34);\n    if ( v39 == 1 && !v40 )\n      break;\n    sub_406F9E(48 * v17 + v24, (__int64)&s2);\n    s2 = (char *)s2 + v38;\n    v36 = 0;\n    ++v17;\n  }\n  *(_QWORD *)(v25 + 8) = 1LL;\n  v19 = 0LL;\n  for ( i = 2LL; i < v22; ++i )\n  {\n    v26 = 48 * i - 48 + v24;\n    while ( 1 )\n    {\n      if ( *(_BYTE *)(v26 + 16) && *(_BYTE *)(48 * v19 + v24 + 16) )\n      {\n        v7 = *(_DWORD *)(v26 + 20) == *(_DWORD *)(48 * v19 + v24 + 20);\n      }\n      else\n      {\n        v8 = *(_QWORD *)(v26 + 8) == *(_QWORD *)(48 * v19 + v24 + 8)\n          && !memcmp(*(const void **)v26, *(const void **)(48 * v19 + v24), *(_QWORD *)(v26 + 8));\n        v7 = v8;\n      }\n      if ( v7 )\n      {\n        ++v19;\n        *(_QWORD *)(8 * i + v25) = i - v19;\n        goto LABEL_30;\n      }\n      if ( !v19 )\n        break;\n      v19 -= *(_QWORD *)(8 * v19 + v25);\n    }\n    *(_QWORD *)(v25 + 8 * i) = i;\nLABEL_30:\n    ;\n  }\n  *v14 = 0LL;\n  v20 = 0LL;\n  v30 = v16;\n  v27[0] = 0;\n  memset(&v28, 0, 8uLL);\n  v29 = 0;\n  s2 = v16;\n  v34[0] = 0;\n  memset(&v35, 0, 8uLL);\n  v36 = 0;\n  while ( 1 )\n  {\n    sub_407075((__int64)v34);\n    if ( v39 == 1 && !v40 )\n      break;\n    if ( *(_BYTE *)(48 * v20 + v24 + 16) && v39 )\n    {\n      v9 = *(_DWORD *)(48 * v20 + v24 + 20) == v40;\n    }\n    else\n    {\n      v10 = *(_QWORD *)(48 * v20 + v24 + 8) == v38\n         && !memcmp(*(const void **)(48 * v20 + v24), s2, *(_QWORD *)(48 * v20 + v24 + 8));\n      v9 = v10;\n    }\n    if ( v9 )\n    {\n      ++v20;\n      s2 = (char *)s2 + v38;\n      v36 = 0;\n      if ( v20 == v22 )\n      {\n        *v14 = v30;\n        break;\n      }\n    }\n    else if ( v20 )\n    {\n      v21 = *(_QWORD *)(8 * v20 + v25);\n      v20 -= v21;\n      while ( v21 )\n      {\n        sub_407075((__int64)v27);\n        if ( v32 == 1 && !v33 )\n          abort();\n        v30 += v31;\n        v29 = 0;\n        --v21;\n      }\n    }\n    else\n    {\n      sub_407075((__int64)v27);\n      if ( v32 == 1 && !v33 )\n        abort();\n      v30 += v31;\n      v29 = 0;\n      s2 = (char *)s2 + v38;\n      v36 = 0;\n    }\n  }\n  sub_409110(v23);\n  return 1LL;\n}\n"], [4226022, "sub_407BE6", "_BYTE *__fastcall sub_407BE6(_BYTE *a1, char *a2)\n{\n  _BYTE *result; // rax\n  bool v7; // al\n  bool v8; // al\n  bool v12; // al\n  bool v13; // al\n  size_t v14; // rax\n  unsigned __int64 v15; // rax\n  _BYTE *v16; // [rsp+8h] [rbp-1C8h]\n  char v17; // [rsp+13h] [rbp-1BDh]\n  char v18; // [rsp+14h] [rbp-1BCh]\n  char v19; // [rsp+16h] [rbp-1BAh]\n  __int64 v20; // [rsp+18h] [rbp-1B8h] BYREF\n  unsigned __int64 v21; // [rsp+20h] [rbp-1B0h]\n  unsigned __int64 v22; // [rsp+28h] [rbp-1A8h]\n  unsigned __int64 v23; // [rsp+30h] [rbp-1A0h]\n  unsigned __int64 j; // [rsp+38h] [rbp-198h]\n  unsigned __int64 v25; // [rsp+40h] [rbp-190h]\n  unsigned __int64 v26; // [rsp+48h] [rbp-188h]\n  unsigned __int64 v27; // [rsp+50h] [rbp-180h]\n  char *string; // [rsp+58h] [rbp-178h]\n  _BYTE *v29; // [rsp+60h] [rbp-170h]\n  _BYTE *i; // [rsp+68h] [rbp-168h]\n  char v31[4]; // [rsp+70h] [rbp-160h] BYREF\n  _BYTE v32[12]; // [rsp+74h] [rbp-15Ch] BYREF\n  void *s2; // [rsp+80h] [rbp-150h]\n  __int64 v34; // [rsp+88h] [rbp-148h]\n  char v35; // [rsp+90h] [rbp-140h]\n  int v36; // [rsp+94h] [rbp-13Ch]\n  char v37[4]; // [rsp+B0h] [rbp-120h] BYREF\n  int v38; // [rsp+B4h] [rbp-11Ch] BYREF\n  char v39; // [rsp+BCh] [rbp-114h]\n  char *v40; // [rsp+C0h] [rbp-110h]\n  __int64 v41; // [rsp+C8h] [rbp-108h]\n  char v42; // [rsp+D0h] [rbp-100h]\n  int v43; // [rsp+D4h] [rbp-FCh]\n  __int64 v44; // [rsp+F0h] [rbp-E0h] BYREF\n  __int64 v45; // [rsp+F8h] [rbp-D8h]\n  void *s1; // [rsp+100h] [rbp-D0h]\n  size_t n; // [rsp+108h] [rbp-C8h]\n  __int64 v48; // [rsp+110h] [rbp-C0h]\n  __int64 v49; // [rsp+118h] [rbp-B8h]\n  __int64 v50; // [rsp+120h] [rbp-B0h]\n  __int64 v51; // [rsp+128h] [rbp-A8h]\n  __int64 v52; // [rsp+130h] [rbp-A0h] BYREF\n  __int64 v53; // [rsp+138h] [rbp-98h]\n  void *v54; // [rsp+140h] [rbp-90h]\n  size_t v55; // [rsp+148h] [rbp-88h]\n  __int64 v56; // [rsp+150h] [rbp-80h]\n  __int64 v57; // [rsp+158h] [rbp-78h]\n  __int64 v58; // [rsp+160h] [rbp-70h]\n  __int64 v59; // [rsp+168h] [rbp-68h]\n  char v60[4]; // [rsp+170h] [rbp-60h] BYREF\n  int v61; // [rsp+174h] [rbp-5Ch] BYREF\n  char k; // [rsp+17Ch] [rbp-54h]\n  void *v63; // [rsp+180h] [rbp-50h]\n  __int64 v64; // [rsp+188h] [rbp-48h]\n  char v65; // [rsp+190h] [rbp-40h]\n  int v66; // [rsp+194h] [rbp-3Ch]\n  unsigned __int64 v67; // [rsp+1B8h] [rbp-18h]\n\n  v16 = a1;\n  v67 = __readfsqword(0x28u);\n  if ( __ctype_get_mb_cur_max() <= 1 )\n  {\n    if ( *a2 )\n    {\n      v18 = 1;\n      v25 = 0LL;\n      v26 = 0LL;\n      v27 = 0LL;\n      string = a2;\n      v19 = *a2;\n      while ( 1 )\n      {\n        if ( !*v16 )\n          return 0LL;\n        if ( v18 && v25 > 9 && 5 * v25 <= v26 )\n        {\n          if ( string )\n          {\n            v14 = strnlen(string, v26 - v27);\n            string += v14;\n            if ( !*string )\n              string = 0LL;\n            v27 = v26;\n          }\n          if ( !string )\n          {\n            v15 = strlen(a2);\n            if ( (unsigned __int8)sub_407255(v16, (__int64)a2, v15, &v20) )\n              return (_BYTE *)v20;\n            v18 = 0;\n          }\n        }\n        ++v25;\n        ++v26;\n        if ( *v16 == v19 )\n          break;\nLABEL_96:\n        ++v16;\n      }\n      v29 = v16 + 1;\n      for ( i = a2 + 1; ; ++i )\n      {\n        if ( !*i )\n          return v16;\n        if ( !*v29 )\n          break;\n        ++v26;\n        if ( *v29 != *i )\n          goto LABEL_96;\n        ++v29;\n      }\n      result = 0LL;\n    }\n    else\n    {\n      result = a1;\n    }\n  }\n  else\n  {\n    s2 = a2;\n    v31[0] = 0;\n    memset(v32, 0, 8uLL);\n    v32[8] = 0;\n    sub_407075((__int64)v31);\n    if ( v35 != 1 || v36 )\n    {\n      v17 = 1;\n      v21 = 0LL;\n      v22 = 0LL;\n      v23 = 0LL;\n      v40 = a2;\n      v37[0] = 0;\n      memset(&v38, 0, 8uLL);\n      v39 = 0;\n      s1 = a1;\n      LOBYTE(v44) = 0;\n      memset((char *)&v44 + 4, 0, sizeof(__int64));\n      for ( BYTE4(v45) = 0; ; BYTE4(v45) = 0 )\n      {\n        sub_407075((__int64)&v44);\n        if ( (unsigned __int8)v48 == 1 && !HIDWORD(v48) )\n          return 0LL;\n        if ( v17 && v21 > 9 && 5 * v21 <= v22 )\n        {\n          for ( j = v22 - v23; j; --j )\n          {\n            sub_407075((__int64)v37);\n            if ( v42 == 1 && !v43 )\n              break;\n            v40 += v41;\n            v39 = 0;\n          }\n          v23 = v22;\n          sub_407075((__int64)v37);\n          if ( v42 == 1 && !v43 )\n          {\n            if ( (unsigned __int8)sub_40749F(a1, a2, &v20) )\n              return (_BYTE *)v20;\n            v17 = 0;\n          }\n        }\n        ++v21;\n        ++v22;\n        if ( (_BYTE)v48 && v35 )\n        {\n          v7 = HIDWORD(v48) == v36;\n        }\n        else\n        {\n          v8 = n == v34 && !memcmp(s1, s2, n);\n          v7 = v8;\n        }\n        if ( v7 )\n          break;\nLABEL_71:\n        s1 = (char *)s1 + n;\n      }\n      v52 = v44;\n      v53 = v45;\n      v55 = n;\n      v56 = v48;\n      v57 = v49;\n      v58 = v50;\n      v59 = v51;\n      v54 = (char *)s1 + n;\n      BYTE4(v53) = 0;\n      v63 = a2;\n      v60[0] = 0;\n      memset(&v61, 0, 8uLL);\n      k = 0;\n      sub_407075((__int64)v60);\n      if ( v65 == 1 && !v66 )\n        abort();\n      v63 = (char *)v63 + v64;\n      for ( k = 0; ; k = 0 )\n      {\n        sub_407075((__int64)v60);\n        if ( v65 == 1 && !v66 )\n          return s1;\n        sub_407075((__int64)&v52);\n        if ( (unsigned __int8)v56 == 1 && !HIDWORD(v56) )\n          break;\n        ++v22;\n        if ( (_BYTE)v56 && v65 )\n        {\n          v12 = HIDWORD(v56) != v66;\n        }\n        else\n        {\n          v13 = v55 != v64 || memcmp(v54, v63, v55);\n          v12 = v13;\n        }\n        if ( v12 )\n          goto LABEL_71;\n        v54 = (char *)v54 + v55;\n        BYTE4(v53) = 0;\n        v63 = (char *)v63 + v64;\n      }\n      result = 0LL;\n    }\n    else\n    {\n      result = a1;\n    }\n  }\n  return result;\n}\n"], [4228038, "sub_4083C6", "__int64 __fastcall sub_4083C6(char *a1, size_t a2, void *a3, void **a4, size_t *a5)\n{\n  int v9; // [rsp+34h] [rbp-107Ch]\n  char *inbuf; // [rsp+38h] [rbp-1078h] BYREF\n  size_t inbytesleft; // [rsp+40h] [rbp-1070h] BYREF\n  char *outbuf; // [rsp+48h] [rbp-1068h] BYREF\n  size_t outbytesleft; // [rsp+50h] [rbp-1060h] BYREF\n  void *ptr; // [rsp+58h] [rbp-1058h]\n  size_t v15; // [rsp+60h] [rbp-1050h]\n  size_t v16; // [rsp+68h] [rbp-1048h]\n  size_t v17; // [rsp+70h] [rbp-1040h]\n  size_t size; // [rsp+78h] [rbp-1038h]\n  size_t v19; // [rsp+80h] [rbp-1030h]\n  size_t v20; // [rsp+88h] [rbp-1028h]\n  char v21[4104]; // [rsp+90h] [rbp-1020h] BYREF\n  unsigned __int64 v22; // [rsp+1098h] [rbp-18h]\n\n  v22 = __readfsqword(0x28u);\n  iconv(a3, 0LL, 0LL, 0LL, 0LL);\n  v15 = 0LL;\n  inbuf = a1;\n  inbytesleft = a2;\n  while ( inbytesleft )\n  {\n    outbuf = v21;\n    outbytesleft = 4096LL;\n    v16 = iconv(a3, &inbuf, &inbytesleft, &outbuf, &outbytesleft);\n    if ( v16 == -1LL && *__errno_location() != 7 )\n    {\n      if ( *__errno_location() != 22 )\n        return 0xFFFFFFFFLL;\n      break;\n    }\n    v15 += outbuf - v21;\n  }\n  outbuf = v21;\n  outbytesleft = 4096LL;\n  v17 = iconv(a3, 0LL, 0LL, &outbuf, &outbytesleft);\n  if ( v17 == -1LL )\n    return 0xFFFFFFFFLL;\n  v15 += outbuf - v21;\n  size = v15;\n  if ( !v15 )\n  {\n    *a5 = 0LL;\n    return 0LL;\n  }\n  if ( *a4 && *a5 >= size )\n  {\n    ptr = *a4;\n  }\n  else\n  {\n    ptr = malloc(size);\n    if ( !ptr )\n    {\n      *__errno_location() = 12;\n      return 0xFFFFFFFFLL;\n    }\n  }\n  iconv(a3, 0LL, 0LL, 0LL, 0LL);\n  inbuf = a1;\n  inbytesleft = a2;\n  outbuf = (char *)ptr;\n  outbytesleft = size;\n  while ( inbytesleft )\n  {\n    v19 = iconv(a3, &inbuf, &inbytesleft, &outbuf, &outbytesleft);\n    if ( v19 == -1LL )\n    {\n      if ( *__errno_location() != 22 )\n        goto LABEL_26;\n      break;\n    }\n  }\n  v20 = iconv(a3, 0LL, 0LL, &outbuf, &outbytesleft);\n  if ( v20 != -1LL )\n  {\n    if ( outbytesleft )\n      abort();\n    *a4 = ptr;\n    *a5 = size;\n    return 0LL;\n  }\nLABEL_26:\n  if ( *a4 != ptr )\n  {\n    v9 = *__errno_location();\n    free(ptr);\n    *__errno_location() = v9;\n  }\n  return 0xFFFFFFFFLL;\n}\n"], [4229034, "sub_4087AA", "void *__fastcall sub_4087AA(char *a1, void *a2)\n{\n  void *result; // rax\n  char *v3; // rax\n  int v4; // [rsp+14h] [rbp-8Ch]\n  char *inbuf; // [rsp+18h] [rbp-88h] BYREF\n  size_t inbytesleft; // [rsp+20h] [rbp-80h] BYREF\n  char *outbuf; // [rsp+28h] [rbp-78h] BYREF\n  size_t outbytesleft; // [rsp+30h] [rbp-70h] BYREF\n  void *ptr; // [rsp+38h] [rbp-68h]\n  size_t size; // [rsp+40h] [rbp-60h]\n  __int64 v11; // [rsp+48h] [rbp-58h]\n  size_t v12; // [rsp+50h] [rbp-50h]\n  __int64 v13; // [rsp+58h] [rbp-48h]\n  size_t v14; // [rsp+60h] [rbp-40h]\n  char *v15; // [rsp+68h] [rbp-38h]\n  size_t v16; // [rsp+70h] [rbp-30h]\n  __int64 v17; // [rsp+78h] [rbp-28h]\n  size_t v18; // [rsp+80h] [rbp-20h]\n  char *v19; // [rsp+88h] [rbp-18h]\n  size_t v20; // [rsp+90h] [rbp-10h]\n  void *v21; // [rsp+98h] [rbp-8h]\n\n  inbuf = a1;\n  inbytesleft = strlen(a1);\n  size = inbytesleft;\n  v11 = 0xFFFFFFFFLL;\n  if ( inbytesleft <= 0xFFFFFFF )\n    size *= 16LL;\n  ptr = malloc(++size);\n  if ( ptr )\n  {\n    iconv(a2, 0LL, 0LL, 0LL, 0LL);\n    outbuf = (char *)ptr;\n    for ( outbytesleft = size - 1; ; outbytesleft = v14 - v13 - 1 )\n    {\n      v12 = iconv(a2, &inbuf, &inbytesleft, &outbuf, &outbytesleft);\n      if ( v12 != -1LL || *__errno_location() == 22 )\n        break;\n      if ( *__errno_location() != 7 )\n        goto LABEL_23;\n      v13 = outbuf - (_BYTE *)ptr;\n      v14 = 2 * size;\n      if ( 2 * size <= size || (v15 = (char *)realloc(ptr, v14)) == 0LL )\n      {\nLABEL_18:\n        *__errno_location() = 12;\nLABEL_23:\n        v4 = *__errno_location();\n        free(ptr);\n        *__errno_location() = v4;\n        return 0LL;\n      }\n      ptr = v15;\n      size = v14;\n      outbuf = &v15[v13];\n    }\n    while ( 1 )\n    {\n      v16 = iconv(a2, 0LL, 0LL, &outbuf, &outbytesleft);\n      if ( v16 != -1LL )\n        break;\n      if ( *__errno_location() != 7 )\n        goto LABEL_23;\n      v17 = outbuf - (_BYTE *)ptr;\n      v18 = 2 * size;\n      if ( 2 * size <= size )\n        goto LABEL_18;\n      v19 = (char *)realloc(ptr, v18);\n      if ( !v19 )\n        goto LABEL_18;\n      ptr = v19;\n      size = v18;\n      outbuf = &v19[v17];\n      outbytesleft = v18 - v17 - 1;\n    }\n    v3 = outbuf++;\n    *v3 = 0;\n    v20 = outbuf - (_BYTE *)ptr;\n    if ( outbuf - (_BYTE *)ptr < size )\n    {\n      v21 = realloc(ptr, v20);\n      if ( v21 )\n        ptr = v21;\n    }\n    result = ptr;\n  }\n  else\n  {\n    *__errno_location() = 12;\n    result = 0LL;\n  }\n  return result;\n}\n"], [4229855, "sub_408ADF", "char *__fastcall sub_408ADF(char *a1, char *a2, char *a3)\n{\n  char *result; // rax\n  int v5; // [rsp+20h] [rbp-20h]\n  int v6; // [rsp+24h] [rbp-1Ch]\n  iconv_t cd; // [rsp+28h] [rbp-18h]\n  void *ptr; // [rsp+30h] [rbp-10h]\n  char *v9; // [rsp+38h] [rbp-8h]\n\n  if ( *a1 && (unsigned int)sub_4068E8((unsigned __int8 *)a2, (unsigned __int8 *)a3) )\n  {\n    cd = iconv_open(a3, a2);\n    if ( cd == (iconv_t)-1LL )\n      return 0LL;\n    ptr = sub_4087AA(a1, cd);\n    if ( ptr )\n    {\n      if ( iconv_close(cd) < 0 )\n      {\n        v6 = *__errno_location();\n        free(ptr);\n        *__errno_location() = v6;\n        return 0LL;\n      }\n    }\n    else\n    {\n      v5 = *__errno_location();\n      iconv_close(cd);\n      *__errno_location() = v5;\n    }\n    result = (char *)ptr;\n  }\n  else\n  {\n    v9 = strdup(a1);\n    if ( !v9 )\n      *__errno_location() = 12;\n    result = v9;\n  }\n  return result;\n}\n"], [4230114, "sub_408BE2", "int __fastcall sub_408BE2(FILE *a1)\n{\n  int v2; // eax\n  int v3; // [rsp+14h] [rbp-Ch]\n  int v4; // [rsp+18h] [rbp-8h]\n\n  v3 = 0;\n  if ( fileno(a1) < 0 )\n    return fclose(a1);\n  if ( !__freading(a1) || (v2 = fileno(a1), lseek(v2, 0LL, 1) != -1) )\n  {\n    if ( (unsigned int)sub_408CCA(a1) )\n      v3 = *__errno_location();\n  }\n  v4 = fclose(a1);\n  if ( v3 )\n  {\n    *__errno_location() = v3;\n    v4 = -1;\n  }\n  return v4;\n}\n"], [4230295, "sub_408C97", "__int64 __fastcall sub_408C97(_DWORD *a1)\n{\n  __int64 result; // rax\n\n  result = *a1 & 0x100;\n  if ( (_DWORD)result )\n    result = sub_408D15(a1, 0LL, 1LL);\n  return result;\n}\n"], [4230346, "sub_408CCA", "int __fastcall sub_408CCA(FILE *a1)\n{\n  if ( !a1 || !__freading(a1) )\n    return fflush(a1);\n  sub_408C97(a1);\n  return fflush(a1);\n}\n"], [4230421, "sub_408D15", "int __fastcall sub_408D15(FILE *a1, __off_t a2, int a3)\n{\n  int v3; // eax\n  __off_t v6; // [rsp+28h] [rbp-8h]\n\n  if ( a1->_IO_read_end != a1->_IO_read_ptr || a1->_IO_write_ptr != a1->_IO_write_base || a1->_IO_save_base )\n    return fseeko(a1, a2, a3);\n  v3 = fileno(a1);\n  v6 = lseek(v3, a2, a3);\n  if ( v6 == -1 )\n    return -1;\n  a1->_flags &= 0xFFFFFFEF;\n  a1->_offset = v6;\n  return 0;\n}\n"], [4230605, "sub_408DCD", "_BOOL8 __fastcall sub_408DCD(int a1)\n{\n  return a1 >= 0 && a1 <= 127;\n}\n"], [4230641, "sub_408DF1", "_BOOL8 __fastcall sub_408DF1(int a1)\n{\n  return a1 > 47 && a1 <= 57 || (int)(a1 & 0xFFFFFFDF) > 64 && (int)(a1 & 0xFFFFFFDF) <= 90;\n}\n"], [4230699, "sub_408E2B", "_BOOL8 __fastcall sub_408E2B(int a1)\n{\n  return (int)(a1 & 0xFFFFFFDF) > 64 && (int)(a1 & 0xFFFFFFDF) <= 90;\n}\n"], [4230745, "sub_408E59", "_BOOL8 __fastcall sub_408E59(int a1)\n{\n  return a1 == 32 || a1 == 9;\n}\n"], [4230781, "sub_408E7D", "_BOOL8 __fastcall sub_408E7D(int a1)\n{\n  return (a1 & 0xFFFFFFE0) == 0 || a1 == 127;\n}\n"], [4230821, "sub_408EA5", "_BOOL8 __fastcall sub_408EA5(int a1)\n{\n  return a1 > 47 && a1 <= 57;\n}\n"], [4230857, "sub_408EC9", "_BOOL8 __fastcall sub_408EC9(int a1)\n{\n  return a1 > 96 && a1 <= 122;\n}\n"], [4230893, "sub_408EED", "_BOOL8 __fastcall sub_408EED(int a1)\n{\n  return a1 > 32 && a1 <= 126;\n}\n"], [4230929, "sub_408F11", "_BOOL8 __fastcall sub_408F11(int a1)\n{\n  return a1 > 31 && a1 <= 126;\n}\n"], [4230965, "sub_408F35", "_BOOL8 __fastcall sub_408F35(int a1)\n{\n  return a1 > 32 && a1 <= 126 && (a1 <= 47 || a1 > 57) && ((int)(a1 & 0xFFFFFFDF) <= 64 || (int)(a1 & 0xFFFFFFDF) > 90);\n}\n"], [4231035, "sub_408F7B", "_BOOL8 __fastcall sub_408F7B(int a1)\n{\n  return a1 == 32 || a1 == 9 || a1 == 10 || a1 == 11 || a1 == 12 || a1 == 13;\n}\n"], [4231095, "sub_408FB7", "_BOOL8 __fastcall sub_408FB7(int a1)\n{\n  return a1 > 64 && a1 <= 90;\n}\n"], [4231131, "sub_408FDB", "_BOOL8 __fastcall sub_408FDB(int a1)\n{\n  return a1 > 47 && a1 <= 57 || (int)(a1 & 0xFFFFFFDF) > 64 && (int)(a1 & 0xFFFFFFDF) <= 70;\n}\n"], [4231189, "sub_409015", "__int64 __fastcall sub_409015(int a1)\n{\n  __int64 result; // rax\n\n  if ( a1 <= 64 || a1 > 90 )\n    result = (unsigned int)a1;\n  else\n    result = (unsigned int)(a1 + 32);\n  return result;\n}\n"], [4231221, "sub_409035", "__int64 __fastcall sub_409035(int a1)\n{\n  __int64 result; // rax\n\n  if ( a1 <= 96 || a1 > 122 )\n    result = (unsigned int)a1;\n  else\n    result = (unsigned int)(a1 - 32);\n  return result;\n}\n"], [4231253, "sub_409055", "unsigned __int64 __fastcall sub_409055(unsigned __int64 a1)\n{\n  void *v2; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v3; // [rsp+20h] [rbp-10h]\n\n  if ( a1 + 16 < a1 )\n    return 0LL;\n  v2 = malloc(a1 + 16);\n  if ( !v2 )\n    return 0LL;\n  v3 = (unsigned __int64)v2 + 16;\n  *(_DWORD *)(v3 - 4) = 336984906;\n  *(_QWORD *)(v3 - 16) = qword_60C7E0[v3 % 0x101];\n  qword_60C7E0[v3 % 0x101] = v3;\n  return v3;\n}\n"], [4231440, "sub_409110", "void __fastcall sub_409110(unsigned __int64 a1)\n{\n  _QWORD *i; // [rsp+18h] [rbp-18h]\n\n  if ( a1 && *(_DWORD *)(a1 - 4) == 336984906 )\n  {\n    for ( i = (_QWORD *)(8 * (a1 % 0x101) + 6342624); *i; i = (_QWORD *)(*i - 16LL) )\n    {\n      if ( *i == a1 )\n      {\n        *i = *(_QWORD *)(a1 - 16);\n        free((void *)(a1 - 16));\n        return;\n      }\n    }\n  }\n}\n"], [4231641, "sub_4091D9", "bool __fastcall sub_4091D9(unsigned __int8 a1)\n{\n  return (((unsigned int)dword_40A540[a1 >> 5] >> (a1 & 0x1F)) & 1) != 0;\n}\n"], [4231695, "sub_40920F", "__int64 __fastcall sub_40920F(__int64 a1)\n{\n  __int64 result; // rax\n  size_t v2; // rax\n  __int64 v3; // rax\n\n  result = *(unsigned __int8 *)(a1 + 12);\n  if ( !(_BYTE)result )\n  {\n    if ( !*(_BYTE *)a1 )\n    {\n      if ( sub_4091D9(**(_BYTE **)(a1 + 16)) )\n      {\n        *(_QWORD *)(a1 + 24) = 1LL;\n        *(_DWORD *)(a1 + 36) = **(char **)(a1 + 16);\n        *(_BYTE *)(a1 + 32) = 1;\nLABEL_19:\n        result = a1;\n        *(_BYTE *)(a1 + 12) = 1;\n        return result;\n      }\n      if ( !mbsinit((const mbstate_t *)(a1 + 4)) )\n        __assert_fail(\"mbsinit (&iter->state)\", \"../../src/lib/mbuiter.h\", 0x8Eu, \"mbuiter_multi_next\");\n      *(_BYTE *)a1 = 1;\n    }\n    v2 = __ctype_get_mb_cur_max();\n    v3 = sub_40531B(*(const void **)(a1 + 16), v2);\n    *(_QWORD *)(a1 + 24) = mbrtowc((wchar_t *)(a1 + 36), *(const char **)(a1 + 16), v3, (mbstate_t *)(a1 + 4));\n    if ( *(_QWORD *)(a1 + 24) == -1LL )\n    {\n      *(_QWORD *)(a1 + 24) = 1LL;\n      *(_BYTE *)(a1 + 32) = 0;\n    }\n    else if ( *(_QWORD *)(a1 + 24) == -2LL )\n    {\n      *(_QWORD *)(a1 + 24) = strlen(*(const char **)(a1 + 16));\n      *(_BYTE *)(a1 + 32) = 0;\n    }\n    else\n    {\n      if ( !*(_QWORD *)(a1 + 24) )\n      {\n        *(_QWORD *)(a1 + 24) = 1LL;\n        if ( **(_BYTE **)(a1 + 16) )\n          __assert_fail(\"*iter->cur.ptr == '\\\\0'\", \"../../src/lib/mbuiter.h\", 0xAAu, \"mbuiter_multi_next\");\n        if ( *(_DWORD *)(a1 + 36) )\n          __assert_fail(\"iter->cur.wc == 0\", \"../../src/lib/mbuiter.h\", 0xABu, \"mbuiter_multi_next\");\n      }\n      *(_BYTE *)(a1 + 32) = 1;\n      if ( mbsinit((const mbstate_t *)(a1 + 4)) )\n        *(_BYTE *)a1 = 0;\n    }\n    goto LABEL_19;\n  }\n  return result;\n}\n"], [4232175, "sub_4093EF", "size_t __fastcall sub_4093EF(const char *a1)\n{\n  __int64 v3; // [rsp+18h] [rbp-58h]\n  char v4[4]; // [rsp+20h] [rbp-50h] BYREF\n  int v5; // [rsp+24h] [rbp-4Ch] BYREF\n  char i; // [rsp+2Ch] [rbp-44h]\n  const char *v7; // [rsp+30h] [rbp-40h]\n  __int64 v8; // [rsp+38h] [rbp-38h]\n  char v9; // [rsp+40h] [rbp-30h]\n  int v10; // [rsp+44h] [rbp-2Ch]\n  unsigned __int64 v11; // [rsp+68h] [rbp-8h]\n\n  v11 = __readfsqword(0x28u);\n  if ( __ctype_get_mb_cur_max() <= 1 )\n    return strlen(a1);\n  v3 = 0LL;\n  v7 = a1;\n  v4[0] = 0;\n  memset(&v5, 0, 8uLL);\n  for ( i = 0; ; i = 0 )\n  {\n    sub_40920F((__int64)v4);\n    if ( v9 == 1 && !v10 )\n      break;\n    ++v3;\n    v7 += v8;\n  }\n  return v3;\n}\n"], [4232384, "init", "void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)\n{\n  __int64 v4; // rbx\n  signed __int64 v5; // rbp\n\n  v4 = 0LL;\n  v5 = &off_60BE08 - off_60BE00;\n  init_proc();\n  if ( v5 )\n  {\n    do\n      ((void (__fastcall *)(_QWORD, __int64, __int64))off_60BE00[v4++])(a1, a2, a3);\n    while ( v4 != v5 );\n  }\n}\n"], [4232496, "fini", "void fini(void)\n{\n  ;\n}\n"], [4232512, "sub_409540", "int __fastcall sub_409540(void (__fastcall *a1)(void *))\n{\n  void *v1; // rdx\n\n  if ( &qword_60C2A8 )\n    v1 = (void *)qword_60C2A8;\n  else\n    v1 = 0LL;\n  return __cxa_atexit(a1, 0LL, v1);\n}\n"], [4232540, ".term_proc", "void term_proc()\n{\n  ;\n}\n"]]