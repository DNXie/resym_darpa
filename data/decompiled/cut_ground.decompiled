[[4199192, ".init_proc", "void *init_proc()\n{\n  void *result; // rax\n\n  result = &_gmon_start__;\n  if ( &_gmon_start__ )\n    result = (void *)__gmon_start__();\n  return result;\n}\n"], [4199232, "sub_401340", "__int64 sub_401340()\n{\n  return qword_60B010();\n}\n"], [4199248, ".free", "// attributes: thunk\nvoid free(void *ptr)\n{\n  free(ptr);\n}\n"], [4199264, ".abort", "// attributes: thunk\nvoid __noreturn abort(void)\n{\n  abort();\n}\n"], [4199280, ".__errno_location", "// attributes: thunk\nint *__errno_location(void)\n{\n  return _errno_location();\n}\n"], [4199296, ".strncmp", "// attributes: thunk\nint strncmp(const char *s1, const char *s2, size_t n)\n{\n  return strncmp(s1, s2, n);\n}\n"], [4199312, "._exit", "// attributes: thunk\nvoid __noreturn _exit(int status)\n{\n  exit(status);\n}\n"], [4199328, ".__fpending", "// attributes: thunk\nsize_t __fpending(FILE *fp)\n{\n  return _fpending(fp);\n}\n"], [4199344, ".ferror", "// attributes: thunk\nint ferror(FILE *stream)\n{\n  return ferror(stream);\n}\n"], [4199360, ".getc_unlocked", "// attributes: thunk\nint getc_unlocked(FILE *stream)\n{\n  return getc_unlocked(stream);\n}\n"], [4199376, ".qsort", "// attributes: thunk\nvoid qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar)\n{\n  qsort(base, nmemb, size, compar);\n}\n"], [4199392, ".fread", "// attributes: thunk\nsize_t fread(void *ptr, size_t size, size_t n, FILE *stream)\n{\n  return fread(ptr, size, n, stream);\n}\n"], [4199408, ".clearerr_unlocked", "// attributes: thunk\nvoid clearerr_unlocked(FILE *stream)\n{\n  clearerr_unlocked(stream);\n}\n"], [4199424, ".textdomain", "// attributes: thunk\nchar *textdomain(const char *domainname)\n{\n  return textdomain(domainname);\n}\n"], [4199440, ".fclose", "// attributes: thunk\nint fclose(FILE *stream)\n{\n  return fclose(stream);\n}\n"], [4199456, ".bindtextdomain", "// attributes: thunk\nchar *bindtextdomain(const char *domainname, const char *dirname)\n{\n  return bindtextdomain(domainname, dirname);\n}\n"], [4199472, ".__ctype_get_mb_cur_max", "// attributes: thunk\nsize_t __ctype_get_mb_cur_max(void)\n{\n  return _ctype_get_mb_cur_max();\n}\n"], [4199488, ".strlen", "// attributes: thunk\nsize_t strlen(const char *s)\n{\n  return strlen(s);\n}\n"], [4199504, ".__stack_chk_fail", "// attributes: thunk\nvoid __noreturn __stack_chk_fail()\n{\n  _stack_chk_fail();\n}\n"], [4199520, ".getopt_long", "// attributes: thunk\nint getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind)\n{\n  return getopt_long(argc, argv, shortopts, longopts, longind);\n}\n"], [4199536, ".mbrtowc", "// attributes: thunk\nsize_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p)\n{\n  return mbrtowc(pwc, s, n, p);\n}\n"], [4199552, ".gettext", "// attributes: thunk\nchar *gettext(const char *msgid)\n{\n  return gettext(msgid);\n}\n"], [4199568, ".printf", "// attributes: thunk\nint printf(const char *format, ...)\n{\n  return printf(format);\n}\n"], [4199584, ".strrchr", "// attributes: thunk\nchar *strrchr(const char *s, int c)\n{\n  return strrchr(s, c);\n}\n"], [4199600, ".lseek", "// attributes: thunk\n__off_t lseek(int fd, __off_t offset, int whence)\n{\n  return lseek(fd, offset, whence);\n}\n"], [4199616, ".__assert_fail", "// attributes: thunk\nvoid __noreturn __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function)\n{\n  _assert_fail(assertion, file, line, function);\n}\n"], [4199632, ".memset", "// attributes: thunk\nvoid *memset(void *s, int c, size_t n)\n{\n  return memset(s, c, n);\n}\n"], [4199648, ".fgetc", "// attributes: thunk\nint fgetc(FILE *stream)\n{\n  return fgetc(stream);\n}\n"], [4199664, ".strspn", "// attributes: thunk\nsize_t strspn(const char *s, const char *accept)\n{\n  return strspn(s, accept);\n}\n"], [4199680, ".posix_fadvise", "// attributes: thunk\nint posix_fadvise(int fd, off_t offset, off_t len, int advise)\n{\n  return posix_fadvise(fd, offset, len, advise);\n}\n"], [4199696, ".memchr", "// attributes: thunk\nvoid *memchr(const void *s, int c, size_t n)\n{\n  return memchr(s, c, n);\n}\n"], [4199712, ".strndup", "// attributes: thunk\nchar *strndup(const char *string, size_t n)\n{\n  return strndup(string, n);\n}\n"], [4199728, ".__libc_start_main", "// attributes: thunk\nint __fastcall __libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end)\n{\n  return _libc_start_main(main, argc, ubp_av, init, fini, rtld_fini, stack_end);\n}\n"], [4199744, ".memcmp", "// attributes: thunk\nint memcmp(const void *s1, const void *s2, size_t n)\n{\n  return memcmp(s1, s2, n);\n}\n"], [4199760, ".fputs_unlocked", "// attributes: thunk\nint fputs_unlocked(const char *s, FILE *stream)\n{\n  return fputs_unlocked(s, stream);\n}\n"], [4199776, ".ferror_unlocked", "// attributes: thunk\nint ferror_unlocked(FILE *stream)\n{\n  return ferror_unlocked(stream);\n}\n"], [4199792, ".calloc", "// attributes: thunk\nvoid *calloc(size_t nmemb, size_t size)\n{\n  return calloc(nmemb, size);\n}\n"], [4199808, ".strcmp", "// attributes: thunk\nint strcmp(const char *s1, const char *s2)\n{\n  return strcmp(s1, s2);\n}\n"], [4199824, ".fprintf", "// attributes: thunk\nint fprintf(FILE *stream, const char *format, ...)\n{\n  return fprintf(stream, format);\n}\n"], [4199840, ".__gmon_start__", "// attributes: thunk\n__int64 __gmon_start__(void)\n{\n  return _gmon_start__();\n}\n"], [4199856, ".memcpy", "// attributes: thunk\nvoid *memcpy(void *dest, const void *src, size_t n)\n{\n  return memcpy(dest, src, n);\n}\n"], [4199872, ".putchar_unlocked", "// attributes: thunk\nint putchar_unlocked(int c)\n{\n  return putchar_unlocked(c);\n}\n"], [4199888, ".fileno", "// attributes: thunk\nint fileno(FILE *stream)\n{\n  return fileno(stream);\n}\n"], [4199904, ".malloc", "// attributes: thunk\nvoid *malloc(size_t size)\n{\n  return malloc(size);\n}\n"], [4199920, ".fflush", "// attributes: thunk\nint fflush(FILE *stream)\n{\n  return fflush(stream);\n}\n"], [4199936, ".ungetc", "// attributes: thunk\nint ungetc(int c, FILE *stream)\n{\n  return ungetc(c, stream);\n}\n"], [4199952, ".__freading", "// attributes: thunk\nint __freading(FILE *fp)\n{\n  return _freading(fp);\n}\n"], [4199968, ".fwrite_unlocked", "// attributes: thunk\nsize_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)\n{\n  return fwrite_unlocked(ptr, size, n, stream);\n}\n"], [4199984, ".realloc", "// attributes: thunk\nvoid *realloc(void *ptr, size_t size)\n{\n  return realloc(ptr, size);\n}\n"], [4200000, ".setlocale", "// attributes: thunk\nchar *setlocale(int category, const char *locale)\n{\n  return setlocale(category, locale);\n}\n"], [4200016, ".error", "// attributes: thunk\nvoid error(int status, int errnum, const char *format, ...)\n{\n  error(status, errnum, format);\n}\n"], [4200032, ".fseeko", "// attributes: thunk\nint fseeko(FILE *stream, __off_t off, int whence)\n{\n  return fseeko(stream, off, whence);\n}\n"], [4200048, ".fopen", "// attributes: thunk\nFILE *fopen(const char *filename, const char *modes)\n{\n  return fopen(filename, modes);\n}\n"], [4200064, ".__cxa_atexit", "// attributes: thunk\nint __fastcall __cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle)\n{\n  return _cxa_atexit(lpfunc, obj, lpdso_handle);\n}\n"], [4200080, ".exit", "// attributes: thunk\nvoid __noreturn exit(int status)\n{\n  exit(status);\n}\n"], [4200096, ".fwrite", "// attributes: thunk\nsize_t fwrite(const void *ptr, size_t size, size_t n, FILE *s)\n{\n  return fwrite(ptr, size, n, s);\n}\n"], [4200112, ".mbsinit", "// attributes: thunk\nint mbsinit(const mbstate_t *ps)\n{\n  return mbsinit(ps);\n}\n"], [4200128, ".iswprint", "// attributes: thunk\nint iswprint(wint_t wc)\n{\n  return iswprint(wc);\n}\n"], [4200144, ".feof_unlocked", "// attributes: thunk\nint feof_unlocked(FILE *stream)\n{\n  return feof_unlocked(stream);\n}\n"], [4200160, ".__ctype_b_loc", "// attributes: thunk\nconst unsigned __int16 **__ctype_b_loc(void)\n{\n  return _ctype_b_loc();\n}\n"], [4200176, "start", "// positive sp value has been detected, the output may be wrong!\nvoid __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))\n{\n  __int64 v3; // rax\n  int v4; // esi\n  __int64 v5; // [rsp-8h] [rbp-8h] BYREF\n  char *retaddr; // [rsp+0h] [rbp+0h] BYREF\n\n  v4 = v5;\n  v5 = v3;\n  __libc_start_main(main, v4, &retaddr, init, fini, a3, &v5);\n  __halt();\n}\n"], [4200224, "sub_401720", "signed __int64 sub_401720()\n{\n  signed __int64 result; // rax\n\n  result = &unk_60B23F - &unk_60B238;\n  if ( (unsigned __int64)(&unk_60B23F - &unk_60B238) > 0xE )\n    result = 0LL;\n  return result;\n}\n"], [4200272, "sub_401750", "__int64 sub_401750()\n{\n  return 0LL;\n}\n"], [4200336, "sub_401790", "signed __int64 sub_401790()\n{\n  signed __int64 result; // rax\n\n  if ( !byte_60B298 )\n  {\n    result = sub_401720();\n    byte_60B298 = 1;\n  }\n  return result;\n}\n"], [4200368, "sub_4017B0", "__int64 sub_4017B0()\n{\n  return sub_401750();\n}\n"], [4200413, "sub_4017DD", "__int64 __fastcall sub_4017DD(unsigned __int8 a1)\n{\n  return a1;\n}\n"], [4200428, "sub_4017EC", "int sub_4017EC()\n{\n  __int64 v0; // rbx\n  char *v1; // rax\n  char *v2; // rax\n  FILE *v3; // rbx\n  char *v4; // rax\n  __int64 v5; // rbx\n  char *v6; // rax\n  __int64 v7; // rbx\n  char *v8; // rax\n  const char *s1; // [rsp+8h] [rbp-18h]\n\n  v0 = sub_40307A(qword_60B310);\n  v1 = gettext(\"\\nReport %s bugs to %s\\n\");\n  printf(v1, v0, \"bug-coreutils@gnu.org\");\n  v2 = gettext(\"%s home page: <%s>\\n\");\n  printf(v2, \"GNU coreutils\", \"http://www.gnu.org/software/coreutils/\");\n  v3 = stdout;\n  v4 = gettext(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\");\n  fputs_unlocked(v4, v3);\n  s1 = setlocale(5, 0LL);\n  if ( s1 && strncmp(s1, \"en_\", 3uLL) )\n  {\n    v5 = sub_40307A(qword_60B310);\n    v6 = gettext(\"Report %s translation bugs to <http://translationproject.org/team/>\\n\");\n    printf(v6, v5);\n  }\n  v7 = sub_40307A(qword_60B310);\n  v8 = gettext(\"For complete documentation, run: info coreutils '%s invocation'\\n\");\n  return printf(v8, v7);\n}\n"], [4200694, "sub_4018F6", "void __fastcall __noreturn sub_4018F6(int a1)\n{\n  __int64 v1; // rbx\n  char *v2; // rax\n  char *v3; // rax\n  FILE *v4; // rbx\n  char *v5; // rax\n  FILE *v6; // rbx\n  char *v7; // rax\n  FILE *v8; // rbx\n  char *v9; // rax\n  FILE *v10; // rbx\n  char *v11; // rax\n  FILE *v12; // rbx\n  char *v13; // rax\n  FILE *v14; // rbx\n  char *v15; // rax\n  FILE *v16; // rbx\n  char *v17; // rax\n  FILE *v18; // rbx\n  char *v19; // rax\n  FILE *v20; // rbx\n  char *v21; // rax\n  FILE *v22; // rbx\n  char *v23; // rax\n\n  v1 = qword_60B310;\n  if ( a1 )\n  {\n    v2 = gettext(\"Try `%s --help' for more information.\\n\");\n    fprintf(stderr, v2, v1);\n  }\n  else\n  {\n    v3 = gettext(\"Usage: %s OPTION... [FILE]...\\n\");\n    printf(v3, v1);\n    v4 = stdout;\n    v5 = gettext(\"Print selected parts of lines from each FILE to standard output.\\n\\n\");\n    fputs_unlocked(v5, v4);\n    v6 = stdout;\n    v7 = gettext(\"Mandatory arguments to long options are mandatory for short options too.\\n\");\n    fputs_unlocked(v7, v6);\n    v8 = stdout;\n    v9 = gettext(\n           \"  -b, --bytes=LIST        select only these bytes\\n\"\n           \"  -c, --characters=LIST   select only these characters\\n\"\n           \"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\\n\");\n    fputs_unlocked(v9, v8);\n    v10 = stdout;\n    v11 = gettext(\n            \"  -f, --fields=LIST       select only these fields;  also print any line\\n\"\n            \"                            that contains no delimiter character, unless\\n\"\n            \"                            the -s option is specified\\n\"\n            \"  -n                      (ignored)\\n\");\n    fputs_unlocked(v11, v10);\n    v12 = stdout;\n    v13 = gettext(\n            \"      --complement        complement the set of selected bytes, characters\\n\"\n            \"                            or fields\\n\");\n    fputs_unlocked(v13, v12);\n    v14 = stdout;\n    v15 = gettext(\n            \"  -s, --only-delimited    do not print lines not containing delimiters\\n\"\n            \"      --output-delimiter=STRING  use STRING as the output delimiter\\n\"\n            \"                            the default is to use the input delimiter\\n\");\n    fputs_unlocked(v15, v14);\n    v16 = stdout;\n    v17 = gettext(\"      --help     display this help and exit\\n\");\n    fputs_unlocked(v17, v16);\n    v18 = stdout;\n    v19 = gettext(\"      --version  output version information and exit\\n\");\n    fputs_unlocked(v19, v18);\n    v20 = stdout;\n    v21 = gettext(\n            \"\\n\"\n            \"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\\n\"\n            \"range, or many ranges separated by commas.  Selected input is written\\n\"\n            \"in the same order that it is read, and is written exactly once.\\n\");\n    fputs_unlocked(v21, v20);\n    v22 = stdout;\n    v23 = gettext(\n            \"Each range is one of:\\n\"\n            \"\\n\"\n            \"  N     N'th byte, character or field, counted from 1\\n\"\n            \"  N-    from N'th byte, character or field, to end of line\\n\"\n            \"  N-M   from N'th to M'th (included) byte, character or field\\n\"\n            \"  -M    from first to M'th (included) byte, character or field\\n\"\n            \"\\n\"\n            \"With no FILE, or when FILE is -, read standard input.\\n\");\n    fputs_unlocked(v23, v22);\n    sub_4017EC();\n  }\n  exit(a1);\n}\n"], [4201091, "sub_401A83", "__int64 __fastcall sub_401A83(__int64 a1)\n{\n  __int64 result; // rax\n  __int64 v2; // [rsp+18h] [rbp-8h]\n\n  v2 = sub_404B31(qword_60B2E8, a1);\n  if ( !v2 )\n    sub_40739E();\n  result = v2;\n  if ( v2 != a1 )\n    __assert_fail(\"(size_t) ent_from_table == i\", \"../../src/src/cut.c\", 0xFEu, \"mark_range_start\");\n  return result;\n}\n"], [4201178, "sub_401ADA", "__int64 __fastcall sub_401ADA(unsigned __int64 a1)\n{\n  __int64 result; // rax\n\n  result = *(unsigned __int8 *)(qword_60B2C0 + (a1 >> 3)) | (unsigned int)(1 << (a1 & 7));\n  *(_BYTE *)((a1 >> 3) + qword_60B2C0) = *(_BYTE *)(qword_60B2C0 + (a1 >> 3)) | (1 << (a1 & 7));\n  return result;\n}\n"], [4201255, "sub_401B27", "bool __fastcall sub_401B27(unsigned __int64 a1)\n{\n  return (((int)*(unsigned __int8 *)(qword_60B2C0 + (a1 >> 3)) >> (a1 & 7)) & 1) != 0;\n}\n"], [4201318, "sub_401B66", "unsigned __int64 __fastcall sub_401B66(unsigned __int64 a1, unsigned __int64 a2)\n{\n  return a1 % a2;\n}\n"], [4201356, "sub_401B8C", "bool __fastcall sub_401B8C(__int64 a1, __int64 a2)\n{\n  return a1 == a2;\n}\n"], [4201381, "sub_401BA5", "bool __fastcall sub_401BA5(__int64 a1)\n{\n  return sub_403862(qword_60B2E8, a1) != 0;\n}\n"], [4201423, "sub_401BCF", "_BOOL8 __fastcall sub_401BCF(unsigned __int64 a1, bool *a2)\n{\n  bool v2; // al\n  bool v4; // [rsp+1Fh] [rbp-1h]\n\n  v2 = qword_60B2B8 && qword_60B2B8 <= a1 || a1 <= qword_60B2B0 && sub_401B27(a1);\n  v4 = v2 != byte_60B2CD;\n  if ( a2 && v2 != byte_60B2CD )\n    *a2 = sub_401BA5(a1);\n  return v4;\n}\n"], [4201573, "compar", "__int64 __fastcall compar(const void *a1, const void *a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+18h] [rbp-8h]\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  v3 = *(_QWORD *)a1;\n  v4 = *(_QWORD *)a2;\n  if ( v3 < v4 )\n    result = 0xFFFFFFFFLL;\n  else\n    result = v3 > v4;\n  return result;\n}\n"], [4201634, "sub_401CA2", "__int64 __fastcall sub_401CA2(unsigned __int8 *a1)\n{\n  char *v1; // rax\n  unsigned __int64 v2; // rax\n  const unsigned __int16 *v3; // rbx\n  char *v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  char *v7; // rax\n  char *v8; // rax\n  char v9; // al\n  __int64 v10; // rbx\n  char *v11; // rax\n  char *v12; // rax\n  __int64 v13; // rax\n  char v16; // [rsp+1Bh] [rbp-65h]\n  char v17; // [rsp+1Ch] [rbp-64h]\n  char v18; // [rsp+1Dh] [rbp-63h]\n  unsigned __int8 v19; // [rsp+1Eh] [rbp-62h]\n  char v20; // [rsp+1Fh] [rbp-61h]\n  unsigned __int64 v21; // [rsp+20h] [rbp-60h]\n  size_t v22; // [rsp+28h] [rbp-58h] BYREF\n  unsigned __int64 v23; // [rsp+30h] [rbp-50h]\n  void *base; // [rsp+38h] [rbp-48h]\n  size_t nmemb; // [rsp+40h] [rbp-40h]\n  size_t i; // [rsp+48h] [rbp-38h]\n  unsigned __int64 j; // [rsp+50h] [rbp-30h]\n  size_t v28; // [rsp+58h] [rbp-28h]\n  void *ptr; // [rsp+60h] [rbp-20h]\n  unsigned __int64 v30; // [rsp+68h] [rbp-18h]\n\n  v23 = 1LL;\n  v21 = 0LL;\n  v16 = 0;\n  v17 = 0;\n  v18 = 0;\n  v19 = 0;\n  base = 0LL;\n  nmemb = 0LL;\n  v22 = 0LL;\n  v20 = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( *a1 == 45 )\n      {\n        v20 = 0;\n        if ( v18 )\n        {\n          v1 = gettext(\"invalid byte or field list\");\n          error(0, 0, v1);\n          sub_4018F6(1);\n        }\n        v18 = 1;\n        ++a1;\n        if ( v16 )\n          v2 = v21;\n        else\n          v2 = 1LL;\n        v23 = v2;\n        v21 = 0LL;\n      }\n      if ( *a1 == 44 )\n        break;\n      v3 = *__ctype_b_loc();\n      if ( (v3[(unsigned __int8)sub_4017DD(*a1)] & 1) != 0 || !*a1 )\n        break;\n      if ( (unsigned int)((char)*a1 - 48) > 9 )\n      {\n        v12 = gettext(\"invalid byte or field list\");\n        error(0, 0, v12);\n        sub_4018F6(1);\n      }\n      if ( v20 != 1 || !s )\n        s = (char *)a1;\n      v20 = 1;\n      if ( v18 )\n        v17 = 1;\n      else\n        v16 = 1;\n      if ( v21 > 0x1999999999999999LL || (char)*a1 - 48 + 10 * v21 < v21 )\n      {\n        v9 = 1;\n      }\n      else\n      {\n        v21 = 10 * v21 + (char)*a1 - 48;\n        v9 = 0;\n      }\n      if ( v9 )\n      {\n        v28 = strspn(s, \"0123456789\");\n        ptr = (void *)sub_4073D3(s, v28);\n        if ( dword_60B2C8 == 1 )\n        {\n          v10 = sub_4050EA(ptr);\n          v11 = gettext(\"byte offset %s is too large\");\n        }\n        else\n        {\n          v10 = sub_4050EA(ptr);\n          v11 = gettext(\"field number %s is too large\");\n        }\n        error(0, 0, v11, v10);\n        free(ptr);\n        exit(1);\n      }\n      ++a1;\n    }\n    v20 = 0;\n    if ( v18 )\n    {\n      v18 = 0;\n      if ( v16 != 1 && v17 != 1 )\n      {\n        v4 = gettext(\"invalid range with no endpoint: -\");\n        error(0, 0, v4);\n        sub_4018F6(1);\n      }\n      if ( v17 != 1 )\n      {\n        qword_60B2B8 = v23;\n        v19 = 1;\n      }\n      else\n      {\n        if ( v21 < v23 )\n        {\n          v5 = gettext(\"invalid decreasing range\");\n          error(0, 0, v5);\n          sub_4018F6(1);\n        }\n        if ( qword_60B2B8 )\n        {\n          if ( v23 < qword_60B2B8 )\n          {\n            if ( qword_60B2B8 > v21 )\n            {\n              if ( !v23 || !v21 )\n              {\n                v6 = gettext(\"fields and positions are numbered from 1\");\n                error(0, 0, v6);\n                sub_4018F6(1);\n              }\n              if ( nmemb >= v22 )\n                base = (void *)sub_40715D(base, &v22, 16LL);\n              *((_QWORD *)base + 2 * nmemb) = v23;\n              *((_QWORD *)base + 2 * nmemb++ + 1) = v21;\n            }\n            else\n            {\n              qword_60B2B8 = v23;\n            }\n            v19 = 1;\n          }\n        }\n        else\n        {\n          if ( !v23 || !v21 )\n          {\n            v7 = gettext(\"fields and positions are numbered from 1\");\n            error(0, 0, v7);\n            sub_4018F6(1);\n          }\n          if ( nmemb >= v22 )\n            base = (void *)sub_40715D(base, &v22, 16LL);\n          *((_QWORD *)base + 2 * nmemb) = v23;\n          *((_QWORD *)base + 2 * nmemb++ + 1) = v21;\n          v19 = 1;\n        }\n        v21 = 0LL;\n      }\n    }\n    else\n    {\n      if ( !v21 )\n      {\n        v8 = gettext(\"fields and positions are numbered from 1\");\n        error(0, 0, v8);\n        sub_4018F6(1);\n      }\n      if ( nmemb >= v22 )\n        base = (void *)sub_40715D(base, &v22, 16LL);\n      *((_QWORD *)base + 2 * nmemb) = v21;\n      *((_QWORD *)base + 2 * nmemb++ + 1) = v21;\n      v21 = 0LL;\n      v19 = 1;\n    }\n    if ( !*a1 )\n      break;\n    ++a1;\n    v16 = 0;\n    v17 = 0;\n  }\n  qword_60B2B0 = 0LL;\n  for ( i = 0LL; i < nmemb; ++i )\n  {\n    if ( *((_QWORD *)base + 2 * i + 1) > (unsigned __int64)qword_60B2B0 )\n      qword_60B2B0 = *((_QWORD *)base + 2 * i + 1);\n  }\n  if ( qword_60B2B0 < (unsigned __int64)qword_60B2B8 )\n    qword_60B2B0 = qword_60B2B8;\n  qword_60B2C0 = sub_4072DC(((unsigned __int64)qword_60B2B0 >> 3) + 1);\n  qsort(base, nmemb, 0x10uLL, (__compar_fn_t)compar);\n  for ( i = 0LL; i < nmemb; ++i )\n  {\n    if ( byte_60B2CD )\n      v13 = *((_QWORD *)base + 2 * i + 1) + 1LL;\n    else\n      v13 = *((_QWORD *)base + 2 * i);\n    v30 = v13;\n    if ( byte_60B2CF && !sub_401B27(v30) )\n      sub_401A83(v30);\n    for ( j = *((_QWORD *)base + 2 * i); *((_QWORD *)base + 2 * i + 1) >= j; ++j )\n      sub_401ADA(j);\n  }\n  if ( byte_60B2CF && byte_60B2CD != 1 && qword_60B2B8 && !sub_401B27(qword_60B2B8) )\n    sub_401A83(qword_60B2B8);\n  free(base);\n  return v19;\n}\n"], [4203592, "sub_402448", "int __fastcall sub_402448(FILE *a1)\n{\n  int result; // eax\n  bool *v2; // rax\n  char v3; // [rsp+1Ah] [rbp-16h] BYREF\n  char v4; // [rsp+1Bh] [rbp-15h]\n  int c; // [rsp+1Ch] [rbp-14h]\n  unsigned __int64 v6; // [rsp+20h] [rbp-10h]\n  bool *v7; // [rsp+28h] [rbp-8h]\n\n  v6 = 0LL;\n  v4 = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      result = getc_unlocked(a1);\n      c = result;\n      if ( result != 10 )\n        break;\n      putchar_unlocked(10);\n      v6 = 0LL;\n      v4 = 0;\n    }\n    if ( c == -1 )\n      break;\n    if ( byte_60B2CF )\n      v2 = (bool *)&v3;\n    else\n      v2 = 0LL;\n    v7 = v2;\n    if ( sub_401BCF(++v6, v2) )\n    {\n      if ( v7 && *v7 && v4 )\n        fwrite_unlocked(ptr, 1uLL, n, stdout);\n      v4 = 1;\n      putchar_unlocked(c);\n    }\n  }\n  if ( v6 )\n    result = putchar_unlocked(10);\n  return result;\n}\n"], [4203835, "sub_40253B", "int __fastcall sub_40253B(FILE *a1)\n{\n  int result; // eax\n  int v2; // ebx\n  char v3; // [rsp+12h] [rbp-2Eh]\n  char v4; // [rsp+13h] [rbp-2Dh]\n  int c; // [rsp+14h] [rbp-2Ch]\n  unsigned __int64 v6; // [rsp+18h] [rbp-28h]\n  signed __int64 v7; // [rsp+20h] [rbp-20h]\n\n  v6 = 1LL;\n  v3 = 0;\n  result = getc_unlocked(a1);\n  c = result;\n  if ( result == -1 )\n    return result;\n  ungetc(result, a1);\n  v2 = (unsigned __int8)byte_60B2CC;\n  v4 = v2 ^ !sub_401BCF(1uLL, 0LL);\n  while ( 1 )\n  {\n    while ( v6 != 1 || !v4 )\n    {\nLABEL_19:\n      if ( c != -1 )\n      {\n        if ( sub_401BCF(v6, 0LL) )\n        {\n          if ( v3 )\n            fwrite_unlocked(ptr, 1uLL, n, stdout);\n          v3 = 1;\n          while ( 1 )\n          {\n            c = getc_unlocked(a1);\n            if ( c == (unsigned __int8)byte_60B2CE || c == 10 || c == -1 )\n              break;\n            putchar_unlocked(c);\n          }\n        }\n        else\n        {\n          do\n            c = getc_unlocked(a1);\n          while ( c != (unsigned __int8)byte_60B2CE && c != 10 && c != -1 );\n        }\n      }\n      if ( c == 10 )\n      {\n        c = getc_unlocked(a1);\n        if ( c != -1 )\n        {\n          ungetc(c, a1);\n          c = 10;\n        }\n      }\n      if ( (unsigned __int8)byte_60B2CE == c )\n      {\n        ++v6;\n      }\n      else if ( c == 10 || c == -1 )\n      {\n        if ( v3 || (result = (unsigned __int8)byte_60B2CC ^ 1) != 0 || v6 != 1 )\n          result = putchar_unlocked(10);\n        if ( c == -1 )\n          return result;\n        v6 = 1LL;\n        v3 = 0;\n      }\n    }\n    v7 = sub_40319B((int)&qword_60B2A0, (int)&unk_60B2A8, 0, -1, (unsigned __int8)byte_60B2CE, 10, a1);\n    if ( v7 < 0 )\n      break;\n    if ( !v7 )\n      __assert_fail(\"n_bytes != 0\", \"../../src/src/cut.c\", 0x274u, \"cut_fields\");\n    if ( (unsigned __int8)sub_4017DD(*((_BYTE *)qword_60B2A0 + v7 - 1)) == byte_60B2CE )\n    {\n      if ( sub_401BCF(1uLL, 0LL) )\n      {\n        fwrite_unlocked(qword_60B2A0, 1uLL, v7 - 1, stdout);\n        v3 = 1;\n      }\n      v6 = 2LL;\n      goto LABEL_19;\n    }\n    if ( !byte_60B2CC )\n    {\n      fwrite_unlocked(qword_60B2A0, 1uLL, v7, stdout);\n      if ( *((_BYTE *)qword_60B2A0 + v7 - 1) != 10 )\n        putchar_unlocked(10);\n    }\n  }\n  free(qword_60B2A0);\n  qword_60B2A0 = 0LL;\n  result = ferror_unlocked(a1);\n  if ( !result )\n  {\n    result = feof_unlocked(a1);\n    if ( !result )\n      sub_40739E();\n  }\n  return result;\n}\n"], [4204671, "sub_40287F", "int __fastcall sub_40287F(FILE *a1)\n{\n  int result; // eax\n\n  if ( dword_60B2C8 == 1 )\n    result = sub_402448(a1);\n  else\n    result = sub_40253B(a1);\n  return result;\n}\n"], [4204722, "sub_4028B2", "__int64 __fastcall sub_4028B2(const char *a1)\n{\n  int *v1; // rax\n  FILE *stream; // [rsp+18h] [rbp-8h]\n\n  if ( !strcmp(a1, \"-\") )\n  {\n    byte_60B2E0 = 1;\n    stream = (FILE *)stdin;\n    sub_403161(stdin, 2LL);\n  }\n  else\n  {\n    stream = fopen(a1, \"r\");\n    if ( !stream )\n      goto LABEL_10;\n    sub_403161(stream, 2LL);\n  }\n  sub_40287F(stream);\n  if ( ferror_unlocked(stream) )\n    goto LABEL_10;\n  if ( strcmp(a1, \"-\") )\n  {\n    if ( (unsigned int)sub_40740C(stream) != -1 )\n      return 1LL;\nLABEL_10:\n    v1 = __errno_location();\n    error(0, *v1, \"%s\", a1);\n    return 0LL;\n  }\n  clearerr_unlocked(stream);\n  return 1LL;\n}\n"], [4205039, "main", "void __fastcall __noreturn main(int a1, char **a2, char **a3)\n{\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  size_t v6; // rax\n  char *v7; // rax\n  char *v8; // rax\n  char *v9; // rax\n  char *v10; // rax\n  char *v11; // rax\n  int *v12; // rax\n  char v13; // [rsp+22h] [rbp-1Eh]\n  char v14; // [rsp+23h] [rbp-1Dh]\n  int v15; // [rsp+24h] [rbp-1Ch]\n  unsigned __int8 *v16; // [rsp+28h] [rbp-18h]\n\n  v14 = 0;\n  sub_404FDF(*a2, a2, a3);\n  setlocale(6, locale);\n  bindtextdomain(\"coreutils\", \"/root/Product/coreutils/exe/share/locale\");\n  textdomain(\"coreutils\");\n  sub_407A50(sub_402F8F);\n  dword_60B2C8 = 0;\n  byte_60B2CC = 0;\n  byte_60B2CE = 0;\n  byte_60B2E0 = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        v15 = getopt_long(a1, a2, \"b:c:d:f:ns\", &longopts, 0LL);\n        if ( v15 == -1 )\n        {\n          if ( !dword_60B2C8 )\n          {\n            v7 = gettext(\"you must specify a list of bytes, characters, or fields\");\n            error(0, 0, v7);\n            sub_4018F6(1);\n          }\n          if ( byte_60B2CE && dword_60B2C8 != 2 )\n          {\n            v8 = gettext(\"an input delimiter may be specified only when operating on fields\");\n            error(0, 0, v8);\n            sub_4018F6(1);\n          }\n          if ( byte_60B2CC && dword_60B2C8 != 2 )\n          {\n            v9 = gettext(\"suppressing non-delimited lines makes sense\\n\\tonly when operating on fields\");\n            error(0, 0, v9);\n            sub_4018F6(1);\n          }\n          if ( byte_60B2CF )\n          {\n            qword_60B2E8 = sub_403E9B(31LL, 0LL, sub_401B66, sub_401B8C, 0LL);\n            if ( !qword_60B2E8 )\n              sub_40739E();\n          }\n          if ( (unsigned __int8)sub_401CA2(v16) != 1 )\n          {\n            if ( dword_60B2C8 == 2 )\n            {\n              v10 = gettext(\"missing list of fields\");\n              error(0, 0, v10);\n              sub_4018F6(1);\n            }\n            v11 = gettext(\"missing list of positions\");\n            error(0, 0, v11);\n            sub_4018F6(1);\n          }\n          if ( v14 != 1 )\n            byte_60B2CE = 9;\n          if ( !ptr )\n          {\n            byte_60B2F8 = byte_60B2CE;\n            byte_60B2F9 = 0;\n            ptr = &byte_60B2F8;\n            n = 1LL;\n          }\n          if ( optind == a1 )\n          {\n            v13 = sub_4028B2(\"-\");\n          }\n          else\n          {\n            v13 = 1;\n            while ( optind < a1 )\n            {\n              v13 = (unsigned __int8)(v13 & sub_4028B2(a2[optind])) != 0;\n              ++optind;\n            }\n          }\n          if ( qword_60B2E8 )\n            sub_404106(qword_60B2E8);\n          if ( byte_60B2E0 && (unsigned int)sub_40740C(stdin) == -1 )\n          {\n            v12 = __errno_location();\n            error(0, *v12, \"-\");\n            v13 = 0;\n          }\n          exit(v13 == 0);\n        }\n        if ( v15 != 100 )\n          break;\n        if ( *optarg && optarg[1] )\n        {\n          v5 = gettext(\"the delimiter must be a single character\");\n          error(0, 0, v5);\n          sub_4018F6(1);\n        }\n        byte_60B2CE = *optarg;\n        v14 = 1;\n      }\n      if ( v15 <= 100 )\n        break;\n      if ( v15 == 115 )\n      {\n        byte_60B2CC = 1;\n      }\n      else if ( v15 > 115 )\n      {\n        if ( v15 == 128 )\n        {\n          byte_60B2CF = 1;\n          if ( *optarg )\n            v6 = strlen(optarg);\n          else\n            v6 = 1LL;\n          n = v6;\n          ptr = (void *)sub_407371(optarg);\n        }\n        else\n        {\n          if ( v15 != 129 )\n            goto LABEL_36;\n          byte_60B2CD = 1;\n        }\n      }\n      else if ( v15 == 102 )\n      {\n        if ( dword_60B2C8 )\n        {\n          v4 = gettext(\"only one type of list may be specified\");\n          error(0, 0, v4);\n          sub_4018F6(1);\n        }\n        dword_60B2C8 = 2;\n        v16 = (unsigned __int8 *)optarg;\n      }\n      else if ( v15 != 110 )\n      {\n        goto LABEL_36;\n      }\n    }\n    if ( v15 == -130 )\n      sub_4018F6(0);\n    if ( v15 <= -130 )\n    {\n      if ( v15 == -131 )\n      {\n        sub_406FB4(\n          (_DWORD)stdout,\n          (unsigned int)\"cut\",\n          (unsigned int)\"GNU coreutils\",\n          (_DWORD)off_60B200,\n          (unsigned int)\"David M. Ihnat\",\n          (unsigned int)\"David MacKenzie\",\n          \"Jim Meyering\",\n          0LL);\n        exit(0);\n      }\nLABEL_36:\n      sub_4018F6(1);\n    }\n    if ( v15 < 98 )\n      goto LABEL_36;\n    if ( dword_60B2C8 )\n    {\n      v3 = gettext(\"only one type of list may be specified\");\n      error(0, 0, v3);\n      sub_4018F6(1);\n    }\n    dword_60B2C8 = 1;\n    v16 = (unsigned __int8 *)optarg;\n  }\n}\n"], [4206458, "sub_402F7A", "__int64 __fastcall sub_402F7A(unsigned __int8 a1)\n{\n  __int64 result; // rax\n\n  result = a1;\n  byte_60B308 = a1;\n  return result;\n}\n"], [4206479, "sub_402F8F", "__int64 sub_402F8F()\n{\n  const char *v0; // rbx\n  int *v1; // rax\n  int *v2; // rax\n  __int64 result; // rax\n  char *v4; // [rsp+8h] [rbp-18h]\n\n  if ( (unsigned int)sub_4075F7(stdout) && (byte_60B308 != 1 || *__errno_location() != 32) )\n  {\n    v4 = gettext(\"write error\");\n    if ( qword_60B300 )\n    {\n      v0 = (const char *)sub_406703(qword_60B300);\n      v1 = __errno_location();\n      error(0, *v1, \"%s: %s\", v0, v4);\n    }\n    else\n    {\n      v2 = __errno_location();\n      error(0, *v2, \"%s\", v4);\n    }\n    _exit(status);\n  }\n  result = sub_4075F7(stderr);\n  if ( (_DWORD)result )\n    _exit(status);\n  return result;\n}\n"], [4206714, "sub_40307A", "_BYTE *__fastcall sub_40307A(_BYTE *a1)\n{\n  char v2; // [rsp+17h] [rbp-11h]\n  _BYTE *i; // [rsp+20h] [rbp-8h]\n\n  v2 = 0;\n  while ( *a1 == 47 )\n    ++a1;\n  for ( i = a1; *i; ++i )\n  {\n    if ( *i == 47 )\n    {\n      v2 = 1;\n    }\n    else if ( v2 )\n    {\n      a1 = i;\n      v2 = 0;\n    }\n  }\n  return a1;\n}\n"], [4206819, "sub_4030E3", "size_t __fastcall sub_4030E3(const char *a1)\n{\n  size_t i; // [rsp+10h] [rbp-10h]\n\n  for ( i = strlen(a1); i > 1 && a1[i - 1] == 47; --i )\n    ;\n  return i;\n}\n"], [4206897, "sub_403131", "int __fastcall sub_403131(int a1, off_t a2, off_t a3, int a4)\n{\n  return posix_fadvise(a1, a2, a3, a4);\n}\n"], [4206945, "sub_403161", "void __fastcall sub_403161(FILE *a1, int a2)\n{\n  int v2; // eax\n\n  if ( a1 )\n  {\n    v2 = fileno(a1);\n    sub_403131(v2, 0LL, 0LL, a2);\n  }\n}\n"], [4207003, "sub_40319B", "__int64 __fastcall sub_40319B(void **a1, size_t *a2, size_t a3, size_t a4, unsigned int a5, unsigned int a6, FILE *stream)\n{\n  size_t v7; // rax\n  __int64 result; // rax\n  size_t v9; // rax\n  char v14; // [rsp+3Bh] [rbp-65h]\n  int v15; // [rsp+3Ch] [rbp-64h]\n  size_t v16; // [rsp+40h] [rbp-60h] BYREF\n  size_t v17; // [rsp+48h] [rbp-58h]\n  void *dest; // [rsp+50h] [rbp-50h]\n  __int64 v19; // [rsp+58h] [rbp-48h]\n  void *ptr; // [rsp+60h] [rbp-40h]\n  size_t size; // [rsp+68h] [rbp-38h]\n  size_t v22; // [rsp+70h] [rbp-30h]\n  size_t n; // [rsp+78h] [rbp-28h]\n  void *src; // [rsp+80h] [rbp-20h]\n  __int64 v25; // [rsp+88h] [rbp-18h]\n  size_t v26; // [rsp+90h] [rbp-10h]\n  char *v27; // [rsp+98h] [rbp-8h]\n\n  v19 = -1LL;\n  ptr = *a1;\n  size = *a2;\n  if ( !ptr )\n  {\n    v7 = 64LL;\n    if ( a4 <= 0x40 )\n      v7 = a4;\n    size = v7;\n    ptr = malloc(v7);\n    if ( !ptr )\n      return -1LL;\n  }\n  if ( size < a3 )\n    goto LABEL_52;\n  v17 = size - a3;\n  dest = (char *)ptr + a3;\n  if ( size == a3 && a4 <= size )\n    goto LABEL_52;\n  if ( a5 == -1 )\n  {\n    a5 = a6;\n  }\n  else if ( a6 == -1 )\n  {\n    a6 = a5;\n  }\n  v14 = 0;\n  while ( 1 )\n  {\n    src = (void *)sub_407682(stream, &v16);\n    if ( !src )\n      break;\n    if ( a5 != -1 )\n    {\n      v25 = sub_404E29(src, a5, a6, v16);\n      if ( v25 )\n      {\n        v16 = v25 - (_QWORD)src + 1;\n        v14 = 1;\n      }\n    }\nLABEL_26:\n    if ( v16 + 1 > v17 && size < a4 )\n    {\n      if ( size > 0x3F )\n        v9 = 2 * size;\n      else\n        v9 = size + 64;\n      v22 = v9;\n      if ( v9 + (_BYTE *)ptr - (_BYTE *)dest < v16 + 1 )\n        v22 = (_BYTE *)dest - (_BYTE *)ptr + v16 + 1;\n      if ( size >= v22 || v22 > a4 )\n        v22 = a4;\n      if ( (__int64)(v22 - a3) < 0 )\n      {\n        v26 = a3 + 0x8000000000000000LL;\n        if ( size == a3 + 0x8000000000000000LL )\n          goto LABEL_52;\n        v22 = v26;\n      }\n      v17 = (_BYTE *)ptr - (_BYTE *)dest + v22;\n      v27 = (char *)realloc(ptr, v22);\n      if ( !v27 )\n        goto LABEL_52;\n      ptr = v27;\n      size = v22;\n      dest = &v27[v22 - v17];\n    }\n    if ( v17 > 1 )\n    {\n      n = v17 - 1;\n      if ( v16 < v17 - 1 )\n        n = v16;\n      if ( src )\n        memcpy(dest, src, n);\n      else\n        *(_BYTE *)dest = v15;\n      dest = (char *)dest + n;\n      v17 -= n;\n    }\n    if ( src && (unsigned int)sub_40770F(stream, v16) )\n      goto LABEL_52;\n    if ( v14 == 1 )\n      goto LABEL_51;\n  }\n  v15 = getc_unlocked(stream);\n  if ( v15 != -1 )\n  {\n    if ( v15 == a5 || v15 == a6 )\n      v14 = 1;\n    v16 = 1LL;\n    goto LABEL_26;\n  }\n  if ( dest == ptr )\n    goto LABEL_52;\nLABEL_51:\n  *(_BYTE *)dest = 0;\n  v19 = (_BYTE *)dest - ((_BYTE *)ptr + a3);\nLABEL_52:\n  *a1 = ptr;\n  *a2 = size;\n  if ( v19 )\n    result = v19;\n  else\n    result = -1LL;\n  return result;\n}\n"], [4208009, "sub_403589", "__int64 __fastcall sub_403589(__int64 a1, char a2)\n{\n  return __ROR8__(a1, a2);\n}\n"], [4208037, "sub_4035A5", "__int64 __fastcall sub_4035A5(__int64 a1)\n{\n  return *(_QWORD *)(a1 + 16);\n}\n"], [4208055, "sub_4035B7", "__int64 __fastcall sub_4035B7(__int64 a1)\n{\n  return *(_QWORD *)(a1 + 24);\n}\n"], [4208073, "sub_4035C9", "__int64 __fastcall sub_4035C9(__int64 a1)\n{\n  return *(_QWORD *)(a1 + 32);\n}\n"], [4208091, "sub_4035DB", "unsigned __int64 __fastcall sub_4035DB(__int64 a1)\n{\n  _QWORD *i; // [rsp+8h] [rbp-20h]\n  unsigned __int64 v3; // [rsp+10h] [rbp-18h]\n  _QWORD *v4; // [rsp+18h] [rbp-10h]\n  unsigned __int64 j; // [rsp+20h] [rbp-8h]\n\n  v3 = 0LL;\n  for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      v4 = i;\n      for ( j = 1LL; ; ++j )\n      {\n        v4 = (_QWORD *)v4[1];\n        if ( !v4 )\n          break;\n      }\n      if ( j > v3 )\n        v3 = j;\n    }\n  }\n  return v3;\n}\n"], [4208217, "sub_403659", "_BOOL8 __fastcall sub_403659(__int64 a1)\n{\n  _QWORD *i; // [rsp+8h] [rbp-20h]\n  __int64 v3; // [rsp+10h] [rbp-18h]\n  __int64 v4; // [rsp+18h] [rbp-10h]\n  _QWORD *v5; // [rsp+20h] [rbp-8h]\n\n  v3 = 0LL;\n  v4 = 0LL;\n  for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      v5 = i;\n      ++v3;\n      ++v4;\n      while ( 1 )\n      {\n        v5 = (_QWORD *)v5[1];\n        if ( !v5 )\n          break;\n        ++v4;\n      }\n    }\n  }\n  return *(_QWORD *)(a1 + 24) == v3 && *(_QWORD *)(a1 + 32) == v4;\n}\n"], [4208371, "sub_4036F3", "int __fastcall sub_4036F3(__int64 a1, FILE *a2)\n{\n  double v2; // xmm0_8\n  double v3; // xmm1_8\n  double v4; // xmm0_8\n  __int64 v6; // [rsp+10h] [rbp-20h]\n  __int64 v7; // [rsp+18h] [rbp-18h]\n  __int64 v8; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v9; // [rsp+28h] [rbp-8h]\n\n  v6 = sub_4035C9(a1);\n  v7 = sub_4035A5(a1);\n  v8 = sub_4035B7(a1);\n  v9 = sub_4035DB(a1);\n  fprintf(a2, \"# entries:         %lu\\n\", v6);\n  fprintf(a2, \"# buckets:         %lu\\n\", v7);\n  if ( v8 < 0 )\n    v2 = (double)(int)(v8 & 1 | ((unsigned __int64)v8 >> 1)) + (double)(int)(v8 & 1 | ((unsigned __int64)v8 >> 1));\n  else\n    v2 = (double)(int)v8;\n  v3 = 100.0 * v2;\n  if ( v7 < 0 )\n    v4 = (double)(int)(v7 & 1 | ((unsigned __int64)v7 >> 1)) + (double)(int)(v7 & 1 | ((unsigned __int64)v7 >> 1));\n  else\n    v4 = (double)(int)v7;\n  fprintf(a2, \"# buckets used:    %lu (%.2f%%)\\n\", v8, v3 / v4);\n  return fprintf(a2, \"max bucket length: %lu\\n\", v9);\n}\n"], [4208651, "sub_40380B", "__int64 __fastcall sub_40380B(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 48))(a2, *(_QWORD *)(a1 + 16));\n  if ( *(_QWORD *)(a1 + 16) <= v3 )\n    abort();\n  return 16 * v3 + *(_QWORD *)a1;\n}\n"], [4208738, "sub_403862", "__int64 __fastcall sub_403862(__int64 a1, __int64 a2)\n{\n  _QWORD *i; // [rsp+10h] [rbp-10h]\n  _QWORD *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = (_QWORD *)sub_40380B(a1, a2);\n  if ( !*v4 )\n    return 0LL;\n  for ( i = v4; i; i = (_QWORD *)i[1] )\n  {\n    if ( *i == a2 || (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(a1 + 56))(a2, *i) )\n      return *i;\n  }\n  return 0LL;\n}\n"], [4208885, "sub_4038F5", "__int64 __fastcall sub_4038F5(unsigned __int64 *a1)\n{\n  unsigned __int64 i; // [rsp+18h] [rbp-8h]\n\n  if ( !a1[4] )\n    return 0LL;\n  for ( i = *a1; ; i += 16LL )\n  {\n    if ( a1[1] <= i )\n      abort();\n    if ( *(_QWORD *)i )\n      break;\n  }\n  return *(_QWORD *)i;\n}\n"], [4208977, "sub_403951", "__int64 __fastcall sub_403951(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v3; // [rsp+10h] [rbp-10h]\n  unsigned __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40380B(a1, a2);\n  v4 = v3;\n  do\n  {\n    if ( *(_QWORD *)v4 == a2 && *(_QWORD *)(v4 + 8) )\n      return **(_QWORD **)(v4 + 8);\n    v4 = *(_QWORD *)(v4 + 8);\n  }\n  while ( v4 );\n  while ( 1 )\n  {\n    v3 += 16LL;\n    if ( v3 >= *(_QWORD *)(a1 + 8) )\n      break;\n    if ( *(_QWORD *)v3 )\n      return *(_QWORD *)v3;\n  }\n  return 0LL;\n}\n"], [4209131, "sub_4039EB", "unsigned __int64 __fastcall sub_4039EB(__int64 a1, __int64 a2, unsigned __int64 a3)\n{\n  __int64 v4; // rax\n  unsigned __int64 v5; // [rsp+20h] [rbp-18h]\n  _QWORD *i; // [rsp+28h] [rbp-10h]\n  _QWORD *j; // [rsp+30h] [rbp-8h]\n\n  v5 = 0LL;\n  for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      for ( j = i; j; j = (_QWORD *)j[1] )\n      {\n        if ( v5 >= a3 )\n          return v5;\n        v4 = v5++;\n        *(_QWORD *)(a2 + 8 * v4) = *j;\n      }\n    }\n  }\n  return v5;\n}\n"], [4209287, "sub_403A87", "__int64 __fastcall sub_403A87(__int64 a1, unsigned __int8 (__fastcall *a2)(_QWORD, __int64), __int64 a3)\n{\n  __int64 v5; // [rsp+28h] [rbp-18h]\n  _QWORD *i; // [rsp+30h] [rbp-10h]\n  _QWORD *j; // [rsp+38h] [rbp-8h]\n\n  v5 = 0LL;\n  for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      for ( j = i; j; j = (_QWORD *)j[1] )\n      {\n        if ( a2(*j, a3) != 1 )\n          return v5;\n        ++v5;\n      }\n    }\n  }\n  return v5;\n}\n"], [4209435, "sub_403B1B", "unsigned __int64 __fastcall sub_403B1B(_BYTE *a1, unsigned __int64 a2)\n{\n  unsigned __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v4 = 0LL;\n  while ( *a1 )\n    v4 = (31 * v4 + (unsigned __int8)*a1++) % a2;\n  return v4;\n}\n"], [4209521, "sub_403B71", "bool __fastcall sub_403B71(unsigned __int64 a1)\n{\n  unsigned __int64 v2; // [rsp+8h] [rbp-10h]\n  unsigned __int64 v3; // [rsp+8h] [rbp-10h]\n  unsigned __int64 v4; // [rsp+10h] [rbp-8h]\n\n  v2 = 3LL;\n  v4 = 9LL;\n  while ( v4 < a1 && a1 % v2 )\n  {\n    v3 = v2 + 1;\n    v4 += 4 * v3;\n    v2 = v3 + 1;\n  }\n  return a1 % v2 != 0;\n}\n"], [4209629, "sub_403BDD", "__int64 __fastcall sub_403BDD(unsigned __int64 a1)\n{\n  __int64 v2; // [rsp+0h] [rbp-8h]\n  __int64 i; // [rsp+0h] [rbp-8h]\n\n  v2 = a1;\n  if ( a1 <= 9 )\n    v2 = 10LL;\n  for ( i = v2 | 1; i != -1 && !sub_403B71(i); i += 2LL )\n    ;\n  return i;\n}\n"], [4209700, "sub_403C24", "__int64 __fastcall sub_403C24(__int64 a1)\n{\n  __int64 result; // rax\n\n  *(_DWORD *)a1 = 0;\n  *(_DWORD *)(a1 + 4) = 1065353216;\n  *(_DWORD *)(a1 + 8) = 1061997773;\n  *(_DWORD *)(a1 + 12) = 1068826100;\n  result = a1;\n  *(_BYTE *)(a1 + 16) = 0;\n  return result;\n}\n"], [4209769, "sub_403C69", "unsigned __int64 __fastcall sub_403C69(__int64 a1, unsigned __int64 a2)\n{\n  return sub_403589(a1, 3) % a2;\n}\n"], [4209824, "sub_403CA0", "bool __fastcall sub_403CA0(__int64 a1, __int64 a2)\n{\n  return a1 == a2;\n}\n"], [4209849, "sub_403CB9", "__int64 __fastcall sub_403CB9(__int64 a1)\n{\n  __int64 v2; // [rsp+10h] [rbp-8h]\n\n  v2 = *(_QWORD *)(a1 + 40);\n  if ( (_UNKNOWN *)v2 == &unk_408710 )\n    return 1LL;\n  if ( *(float *)(v2 + 8) > 0.1\n    && (float)(1.0 - 0.1) > *(float *)(v2 + 8)\n    && *(float *)(v2 + 12) > (float)(0.1 + 1.0)\n    && *(float *)v2 >= 0.0\n    && *(float *)(v2 + 4) > (float)(*(float *)v2 + 0.1)\n    && *(float *)(v2 + 4) <= 1.0\n    && *(float *)(v2 + 8) > (float)(*(float *)v2 + 0.1) )\n  {\n    return 1LL;\n  }\n  *(_QWORD *)(a1 + 40) = &unk_408710;\n  return 0LL;\n}\n"], [4210097, "sub_403DB1", "unsigned __int64 __fastcall sub_403DB1(__int64 a1, __int64 a2)\n{\n  float v2; // xmm0_4\n  unsigned __int64 result; // rax\n  unsigned __int64 v4; // [rsp+8h] [rbp-18h]\n  unsigned __int64 v5; // [rsp+8h] [rbp-18h]\n  float v6; // [rsp+1Ch] [rbp-4h]\n\n  v4 = a1;\n  if ( *(_BYTE *)(a2 + 16) != 1 )\n  {\n    if ( a1 < 0 )\n      v2 = (float)(a1 & 1 | (unsigned int)((unsigned __int64)a1 >> 1))\n         + (float)(a1 & 1 | (unsigned int)((unsigned __int64)a1 >> 1));\n    else\n      v2 = (float)(int)a1;\n    v6 = v2 / *(float *)(a2 + 8);\n    if ( v6 >= 1.8446744e19 )\n      return 0LL;\n    if ( v6 >= 9.223372e18 )\n      v4 = (unsigned int)(int)(float)(v6 - 9.223372e18) ^ 0x8000000000000000LL;\n    else\n      v4 = (unsigned int)(int)v6;\n  }\n  v5 = sub_403BDD(v4);\n  if ( v5 <= 0x1FFFFFFFFFFFFFFFLL )\n    result = v5;\n  else\n    result = 0LL;\n  return result;\n}\n"], [4210331, "sub_403E9B", "size_t *__fastcall sub_403E9B(__int64 a1, void *a2, unsigned __int64 (__fastcall *a3)(__int64 a1, unsigned __int64 a2), bool (__fastcall *a4)(__int64 a1, __int64 a2), size_t a5)\n{\n  size_t *result; // rax\n  bool (__fastcall *v7)(__int64, __int64); // [rsp+10h] [rbp-30h]\n  unsigned __int64 (__fastcall *v8)(__int64, unsigned __int64); // [rsp+18h] [rbp-28h]\n  void *v9; // [rsp+20h] [rbp-20h]\n  size_t *ptr; // [rsp+38h] [rbp-8h]\n\n  v9 = a2;\n  v8 = a3;\n  v7 = a4;\n  if ( !a3 )\n    v8 = sub_403C69;\n  if ( !a4 )\n    v7 = sub_403CA0;\n  ptr = (size_t *)malloc(0x50uLL);\n  if ( !ptr )\n    return 0LL;\n  if ( !a2 )\n    v9 = &unk_408710;\n  ptr[5] = (size_t)v9;\n  if ( (unsigned __int8)sub_403CB9((__int64)ptr) == 1\n    && (ptr[2] = sub_403DB1(a1, (__int64)v9)) != 0\n    && (*ptr = (size_t)calloc(ptr[2], 0x10uLL)) != 0 )\n  {\n    ptr[1] = 16 * ptr[2] + *ptr;\n    ptr[3] = 0LL;\n    ptr[4] = 0LL;\n    ptr[6] = (size_t)v8;\n    ptr[7] = (size_t)v7;\n    ptr[8] = a5;\n    ptr[9] = 0LL;\n    result = ptr;\n  }\n  else\n  {\n    free(ptr);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4210688, "sub_404000", "__int64 __fastcall sub_404000(__int64 a1)\n{\n  __int64 result; // rax\n  _QWORD *i; // [rsp+18h] [rbp-18h]\n  _QWORD *j; // [rsp+20h] [rbp-10h]\n  _QWORD *v4; // [rsp+28h] [rbp-8h]\n\n  for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      for ( j = (_QWORD *)i[1]; j; j = v4 )\n      {\n        if ( *(_QWORD *)(a1 + 64) )\n          (*(void (__fastcall **)(_QWORD))(a1 + 64))(*j);\n        *j = 0LL;\n        v4 = (_QWORD *)j[1];\n        j[1] = *(_QWORD *)(a1 + 72);\n        *(_QWORD *)(a1 + 72) = j;\n      }\n      if ( *(_QWORD *)(a1 + 64) )\n        (*(void (__fastcall **)(_QWORD))(a1 + 64))(*i);\n      *i = 0LL;\n      i[1] = 0LL;\n    }\n  }\n  *(_QWORD *)(a1 + 24) = 0LL;\n  result = a1;\n  *(_QWORD *)(a1 + 32) = 0LL;\n  return result;\n}\n"], [4210950, "sub_404106", "void __fastcall sub_404106(__int64 a1)\n{\n  _QWORD *i; // [rsp+18h] [rbp-18h]\n  _QWORD *j; // [rsp+18h] [rbp-18h]\n  _QWORD *ptr; // [rsp+20h] [rbp-10h]\n  _QWORD *ptra; // [rsp+20h] [rbp-10h]\n  _QWORD *ptrb; // [rsp+20h] [rbp-10h]\n  _QWORD *v6; // [rsp+28h] [rbp-8h]\n  _QWORD *v7; // [rsp+28h] [rbp-8h]\n\n  if ( *(_QWORD *)(a1 + 64) && *(_QWORD *)(a1 + 32) )\n  {\n    for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n    {\n      if ( *i )\n      {\n        for ( ptr = i; ptr; ptr = (_QWORD *)ptr[1] )\n          (*(void (__fastcall **)(_QWORD))(a1 + 64))(*ptr);\n      }\n    }\n  }\n  for ( j = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)j; j += 2 )\n  {\n    for ( ptra = (_QWORD *)j[1]; ptra; ptra = v6 )\n    {\n      v6 = (_QWORD *)ptra[1];\n      free(ptra);\n    }\n  }\n  for ( ptrb = *(_QWORD **)(a1 + 72); ptrb; ptrb = v7 )\n  {\n    v7 = (_QWORD *)ptrb[1];\n    free(ptrb);\n  }\n  free(*(void **)a1);\n  free((void *)a1);\n}\n"], [4211248, "sub_404230", "void *__fastcall sub_404230(__int64 a1)\n{\n  __int64 v2; // [rsp+18h] [rbp-8h]\n\n  if ( !*(_QWORD *)(a1 + 72) )\n    return malloc(0x10uLL);\n  v2 = *(_QWORD *)(a1 + 72);\n  *(_QWORD *)(a1 + 72) = *(_QWORD *)(v2 + 8);\n  return (void *)v2;\n}\n"], [4211323, "sub_40427B", "__int64 __fastcall sub_40427B(__int64 a1, _QWORD *a2)\n{\n  __int64 result; // rax\n\n  *a2 = 0LL;\n  a2[1] = *(_QWORD *)(a1 + 72);\n  result = a1;\n  *(_QWORD *)(a1 + 72) = a2;\n  return result;\n}\n"], [4211376, "sub_4042B0", "__int64 __fastcall sub_4042B0(__int64 a1, __int64 a2, _QWORD *a3, char a4)\n{\n  __int64 result; // rax\n  __int64 v5; // rdx\n  _QWORD *i; // [rsp+20h] [rbp-30h]\n  _QWORD *v9; // [rsp+28h] [rbp-28h]\n  __int64 v10; // [rsp+30h] [rbp-20h]\n  _QWORD *v11; // [rsp+38h] [rbp-18h]\n  __int64 v12; // [rsp+40h] [rbp-10h]\n  _QWORD *v13; // [rsp+48h] [rbp-8h]\n\n  v9 = (_QWORD *)sub_40380B(a1, a2);\n  *a3 = v9;\n  if ( !*v9 )\n    return 0LL;\n  if ( *v9 == a2 || (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(a1 + 56))(a2, *v9) )\n  {\n    v12 = *v9;\n    if ( a4 )\n    {\n      if ( v9[1] )\n      {\n        v13 = (_QWORD *)v9[1];\n        v5 = v13[1];\n        *v9 = *v13;\n        v9[1] = v5;\n        sub_40427B(a1, v13);\n      }\n      else\n      {\n        *v9 = 0LL;\n      }\n    }\n    result = v12;\n  }\n  else\n  {\n    for ( i = v9; ; i = (_QWORD *)i[1] )\n    {\n      if ( !i[1] )\n        return 0LL;\n      if ( *(_QWORD *)i[1] == a2 || (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(a1 + 56))(a2, *(_QWORD *)i[1]) )\n        break;\n    }\n    v10 = *(_QWORD *)i[1];\n    if ( a4 )\n    {\n      v11 = (_QWORD *)i[1];\n      i[1] = v11[1];\n      sub_40427B(a1, v11);\n    }\n    result = v10;\n  }\n  return result;\n}\n"], [4211781, "sub_404445", "__int64 __fastcall sub_404445(__int64 a1, __int64 a2, char a3)\n{\n  __int64 *i; // [rsp+20h] [rbp-30h]\n  __int64 *j; // [rsp+28h] [rbp-28h]\n  __int64 v7; // [rsp+30h] [rbp-20h]\n  __int64 v8; // [rsp+30h] [rbp-20h]\n  _QWORD *v9; // [rsp+38h] [rbp-18h]\n  _QWORD *v10; // [rsp+38h] [rbp-18h]\n  __int64 *v11; // [rsp+40h] [rbp-10h]\n  _QWORD *v12; // [rsp+48h] [rbp-8h]\n\n  for ( i = *(__int64 **)a2; *(_QWORD *)(a2 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      for ( j = (__int64 *)i[1]; j; j = v11 )\n      {\n        v7 = *j;\n        v9 = (_QWORD *)sub_40380B(a1, *j);\n        v11 = (__int64 *)j[1];\n        if ( *v9 )\n        {\n          j[1] = v9[1];\n          v9[1] = j;\n        }\n        else\n        {\n          *v9 = v7;\n          ++*(_QWORD *)(a1 + 24);\n          sub_40427B(a1, j);\n        }\n      }\n      v8 = *i;\n      i[1] = 0LL;\n      if ( !a3 )\n      {\n        v10 = (_QWORD *)sub_40380B(a1, v8);\n        if ( *v10 )\n        {\n          v12 = sub_404230(a1);\n          if ( !v12 )\n            return 0LL;\n          *v12 = v8;\n          v12[1] = v10[1];\n          v10[1] = v12;\n        }\n        else\n        {\n          *v10 = v8;\n          ++*(_QWORD *)(a1 + 24);\n        }\n        *i = 0LL;\n        --*(_QWORD *)(a2 + 24);\n      }\n    }\n  }\n  return 1LL;\n}\n"], [4212243, "sub_404613", "__int64 __fastcall sub_404613(__int64 a1, __int64 a2)\n{\n  __int64 result; // rax\n  unsigned __int64 nmemb; // [rsp+10h] [rbp-60h]\n  void *v4; // [rsp+20h] [rbp-50h] BYREF\n  __int64 v5; // [rsp+28h] [rbp-48h]\n  unsigned __int64 v6; // [rsp+30h] [rbp-40h]\n  __int64 v7; // [rsp+38h] [rbp-38h]\n  __int64 v8; // [rsp+40h] [rbp-30h]\n  __int64 v9; // [rsp+48h] [rbp-28h]\n  __int64 v10; // [rsp+50h] [rbp-20h]\n  __int64 v11; // [rsp+58h] [rbp-18h]\n  __int64 v12; // [rsp+60h] [rbp-10h]\n  __int64 v13; // [rsp+68h] [rbp-8h]\n\n  nmemb = sub_403DB1(a2, *(_QWORD *)(a1 + 40));\n  if ( !nmemb )\n    return 0LL;\n  if ( *(_QWORD *)(a1 + 16) == nmemb )\n    return 1LL;\n  v4 = calloc(nmemb, 0x10uLL);\n  if ( !v4 )\n    return 0LL;\n  v6 = nmemb;\n  v5 = (__int64)v4 + 16 * nmemb;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = *(_QWORD *)(a1 + 40);\n  v10 = *(_QWORD *)(a1 + 48);\n  v11 = *(_QWORD *)(a1 + 56);\n  v12 = *(_QWORD *)(a1 + 64);\n  v13 = *(_QWORD *)(a1 + 72);\n  if ( (unsigned __int8)sub_404445((__int64)&v4, a1, 0) )\n  {\n    free(*(void **)a1);\n    *(_QWORD *)a1 = v4;\n    *(_QWORD *)(a1 + 8) = v5;\n    *(_QWORD *)(a1 + 16) = v6;\n    *(_QWORD *)(a1 + 24) = v7;\n    *(_QWORD *)(a1 + 72) = v13;\n    result = 1LL;\n  }\n  else\n  {\n    *(_QWORD *)(a1 + 72) = v13;\n    if ( (unsigned __int8)sub_404445(a1, (__int64)&v4, 1) != 1 || (unsigned __int8)sub_404445(a1, (__int64)&v4, 0) != 1 )\n      abort();\n    free(v4);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4212759, "sub_404817", "__int64 __fastcall sub_404817(_QWORD *a1, __int64 a2, _QWORD *a3)\n{\n  __int64 result; // rax\n  __int64 v4; // rax\n  float v5; // xmm0_4\n  __int64 v6; // rdx\n  __int64 v7; // rax\n  float v8; // xmm1_4\n  __int64 v9; // rdx\n  __int64 v10; // rax\n  float v11; // xmm0_4\n  __int64 v12; // rdx\n  __int64 v13; // rax\n  float v14; // xmm1_4\n  __int64 v15; // rdx\n  __int64 v16; // rax\n  float v17; // xmm0_4\n  __int64 v18; // rdx\n  float v19; // xmm0_4\n  __int64 v20; // rax\n  float v21; // xmm0_4\n  __int64 v22; // rdx\n  __int64 v23; // rax\n  __int64 *v25; // [rsp+30h] [rbp-20h] BYREF\n  __int64 v26; // [rsp+38h] [rbp-18h]\n  __int64 v27; // [rsp+40h] [rbp-10h]\n  _QWORD *v28; // [rsp+48h] [rbp-8h]\n\n  if ( !a2 )\n    abort();\n  v26 = sub_4042B0((__int64)a1, a2, &v25, 0);\n  if ( v26 )\n  {\n    if ( a3 )\n      *a3 = v26;\n    result = 0LL;\n  }\n  else\n  {\n    v4 = a1[3];\n    if ( v4 < 0 )\n    {\n      v6 = a1[3] & 1LL | ((unsigned __int64)v4 >> 1);\n      v5 = (float)(int)v6 + (float)(int)v6;\n    }\n    else\n    {\n      v5 = (float)(int)v4;\n    }\n    v7 = a1[2];\n    if ( v7 < 0 )\n    {\n      v9 = a1[2] & 1LL | ((unsigned __int64)v7 >> 1);\n      v8 = (float)(int)v9 + (float)(int)v9;\n    }\n    else\n    {\n      v8 = (float)(int)v7;\n    }\n    if ( v5 > (float)(v8 * *(float *)(a1[5] + 8LL)) )\n    {\n      sub_403CB9((__int64)a1);\n      v10 = a1[3];\n      if ( v10 < 0 )\n      {\n        v12 = a1[3] & 1LL | ((unsigned __int64)v10 >> 1);\n        v11 = (float)(int)v12 + (float)(int)v12;\n      }\n      else\n      {\n        v11 = (float)(int)v10;\n      }\n      v13 = a1[2];\n      if ( v13 < 0 )\n      {\n        v15 = a1[2] & 1LL | ((unsigned __int64)v13 >> 1);\n        v14 = (float)(int)v15 + (float)(int)v15;\n      }\n      else\n      {\n        v14 = (float)(int)v13;\n      }\n      if ( v11 > (float)(v14 * *(float *)(a1[5] + 8LL)) )\n      {\n        v27 = a1[5];\n        if ( *(_BYTE *)(v27 + 16) )\n        {\n          v16 = a1[2];\n          if ( v16 < 0 )\n          {\n            v18 = a1[2] & 1LL | ((unsigned __int64)v16 >> 1);\n            v17 = (float)(int)v18 + (float)(int)v18;\n          }\n          else\n          {\n            v17 = (float)(int)v16;\n          }\n          v19 = v17 * *(float *)(v27 + 12);\n        }\n        else\n        {\n          v20 = a1[2];\n          if ( v20 < 0 )\n          {\n            v22 = a1[2] & 1LL | ((unsigned __int64)v20 >> 1);\n            v21 = (float)(int)v22 + (float)(int)v22;\n          }\n          else\n          {\n            v21 = (float)(int)v20;\n          }\n          v19 = (float)(v21 * *(float *)(v27 + 12)) * *(float *)(v27 + 8);\n        }\n        if ( v19 >= 1.8446744e19 )\n          return 0xFFFFFFFFLL;\n        if ( v19 >= 9.223372e18 )\n          v23 = (unsigned int)(int)(float)(v19 - 9.223372e18) ^ 0x8000000000000000LL;\n        else\n          v23 = (unsigned int)(int)v19;\n        if ( (unsigned __int8)sub_404613((__int64)a1, v23) != 1 )\n          return 0xFFFFFFFFLL;\n        if ( sub_4042B0((__int64)a1, a2, &v25, 0) )\n          abort();\n      }\n    }\n    if ( *v25 )\n    {\n      v28 = sub_404230((__int64)a1);\n      if ( v28 )\n      {\n        *v28 = a2;\n        v28[1] = v25[1];\n        v25[1] = (__int64)v28;\n        ++a1[4];\n        result = 1LL;\n      }\n      else\n      {\n        result = 0xFFFFFFFFLL;\n      }\n    }\n    else\n    {\n      *v25 = a2;\n      ++a1[4];\n      ++a1[3];\n      result = 1LL;\n    }\n  }\n  return result;\n}\n"], [4213553, "sub_404B31", "__int64 __fastcall sub_404B31(_QWORD *a1, __int64 a2)\n{\n  int v3; // [rsp+14h] [rbp-Ch]\n  __int64 v4; // [rsp+18h] [rbp-8h] BYREF\n\n  v3 = sub_404817(a1, a2, &v4);\n  if ( v3 == -1 )\n    return 0LL;\n  if ( v3 )\n    return a2;\n  return v4;\n}\n"], [4213626, "sub_404B7A", "__int64 __fastcall sub_404B7A(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rax\n  float v4; // xmm0_4\n  __int64 v5; // rdx\n  __int64 v6; // rax\n  float v7; // xmm1_4\n  __int64 v8; // rdx\n  __int64 v9; // rax\n  float v10; // xmm0_4\n  __int64 v11; // rdx\n  __int64 v12; // rax\n  float v13; // xmm1_4\n  __int64 v14; // rdx\n  __int64 v15; // rax\n  float v16; // xmm0_4\n  __int64 v17; // rdx\n  float v18; // xmm0_4\n  __int64 v19; // rax\n  __int64 v20; // rax\n  float v21; // xmm0_4\n  __int64 v22; // rdx\n  float v23; // xmm0_4\n  _QWORD *v24; // [rsp+10h] [rbp-30h] BYREF\n  void *ptr; // [rsp+18h] [rbp-28h]\n  __int64 v26; // [rsp+20h] [rbp-20h]\n  __int64 v27; // [rsp+28h] [rbp-18h]\n  __int64 v28; // [rsp+30h] [rbp-10h]\n  void *v29; // [rsp+38h] [rbp-8h]\n\n  v26 = sub_4042B0(a1, a2, &v24, 1);\n  if ( !v26 )\n    return 0LL;\n  --*(_QWORD *)(a1 + 32);\n  if ( !*v24 )\n  {\n    v3 = --*(_QWORD *)(a1 + 24);\n    if ( v3 < 0 )\n    {\n      v5 = *(_QWORD *)(a1 + 24) & 1LL | ((unsigned __int64)v3 >> 1);\n      v4 = (float)(int)v5 + (float)(int)v5;\n    }\n    else\n    {\n      v4 = (float)(int)v3;\n    }\n    v6 = *(_QWORD *)(a1 + 16);\n    if ( v6 < 0 )\n    {\n      v8 = *(_QWORD *)(a1 + 16) & 1LL | ((unsigned __int64)v6 >> 1);\n      v7 = (float)(int)v8 + (float)(int)v8;\n    }\n    else\n    {\n      v7 = (float)(int)v6;\n    }\n    if ( (float)(v7 * **(float **)(a1 + 40)) > v4 )\n    {\n      sub_403CB9(a1);\n      v9 = *(_QWORD *)(a1 + 24);\n      if ( v9 < 0 )\n      {\n        v11 = *(_QWORD *)(a1 + 24) & 1LL | ((unsigned __int64)v9 >> 1);\n        v10 = (float)(int)v11 + (float)(int)v11;\n      }\n      else\n      {\n        v10 = (float)(int)v9;\n      }\n      v12 = *(_QWORD *)(a1 + 16);\n      if ( v12 < 0 )\n      {\n        v14 = *(_QWORD *)(a1 + 16) & 1LL | ((unsigned __int64)v12 >> 1);\n        v13 = (float)(int)v14 + (float)(int)v14;\n      }\n      else\n      {\n        v13 = (float)(int)v12;\n      }\n      if ( (float)(v13 * **(float **)(a1 + 40)) > v10 )\n      {\n        v27 = *(_QWORD *)(a1 + 40);\n        if ( *(_BYTE *)(v27 + 16) )\n        {\n          v15 = *(_QWORD *)(a1 + 16);\n          if ( v15 < 0 )\n          {\n            v17 = *(_QWORD *)(a1 + 16) & 1LL | ((unsigned __int64)v15 >> 1);\n            v16 = (float)(int)v17 + (float)(int)v17;\n          }\n          else\n          {\n            v16 = (float)(int)v15;\n          }\n          v18 = v16 * *(float *)(v27 + 4);\n          if ( v18 >= 9.223372e18 )\n            v19 = (unsigned int)(int)(float)(v18 - 9.223372e18) ^ 0x8000000000000000LL;\n          else\n            v19 = (unsigned int)(int)v18;\n        }\n        else\n        {\n          v20 = *(_QWORD *)(a1 + 16);\n          if ( v20 < 0 )\n          {\n            v22 = *(_QWORD *)(a1 + 16) & 1LL | ((unsigned __int64)v20 >> 1);\n            v21 = (float)(int)v22 + (float)(int)v22;\n          }\n          else\n          {\n            v21 = (float)(int)v20;\n          }\n          v23 = (float)(v21 * *(float *)(v27 + 4)) * *(float *)(v27 + 8);\n          if ( v23 >= 9.223372e18 )\n            v19 = (unsigned int)(int)(float)(v23 - 9.223372e18) ^ 0x8000000000000000LL;\n          else\n            v19 = (unsigned int)(int)v23;\n        }\n        v28 = v19;\n        if ( (unsigned __int8)sub_404613(a1, v19) != 1 )\n        {\n          for ( ptr = *(void **)(a1 + 72); ptr; ptr = v29 )\n          {\n            v29 = (void *)*((_QWORD *)ptr + 1);\n            free(ptr);\n          }\n          *(_QWORD *)(a1 + 72) = 0LL;\n        }\n      }\n    }\n  }\n  return v26;\n}\n"], [4214313, "sub_404E29", "_BYTE *__fastcall sub_404E29(const void *a1, unsigned __int8 a2, unsigned __int8 a3, size_t a4)\n{\n  size_t n; // [rsp+8h] [rbp-58h]\n  _BYTE *i; // [rsp+28h] [rbp-38h]\n  _BYTE *v7; // [rsp+28h] [rbp-38h]\n  _QWORD *v8; // [rsp+30h] [rbp-30h]\n  __int64 v9; // [rsp+40h] [rbp-20h]\n  __int64 v10; // [rsp+40h] [rbp-20h]\n  __int64 v11; // [rsp+48h] [rbp-18h]\n  __int64 v12; // [rsp+48h] [rbp-18h]\n\n  n = a4;\n  if ( a2 == a3 )\n    return memchr(a1, a2, a4);\n  for ( i = a1; n && ((unsigned __int8)i & 7) != 0; ++i )\n  {\n    if ( *i == a2 || *i == a3 )\n      return i;\n    --n;\n  }\n  v8 = i;\n  v11 = (a3 << 8) | (unsigned int)a3;\n  v9 = ((__int64)((a2 << 8) | (unsigned int)a2) << 16) | (a2 << 8) | (unsigned int)a2;\n  v10 = (v9 << 32) | v9;\n  v12 = (((v11 << 16) | v11) << 32) | (v11 << 16) | v11;\n  while ( n > 7\n       && ((((v12 ^ *v8) - 0x101010101010101LL) & ~(v12 ^ *v8) | ~(v10 ^ *v8) & ((v10 ^ *v8) - 0x101010101010101LL)) & 0x8080808080808080LL) == 0 )\n  {\n    ++v8;\n    n -= 8LL;\n  }\n  v7 = v8;\n  while ( n )\n  {\n    if ( *v7 == a2 || *v7 == a3 )\n      return v7;\n    --n;\n    ++v7;\n  }\n  return 0LL;\n}\n"], [4214751, "sub_404FDF", "char *__fastcall sub_404FDF(const char *a1)\n{\n  char *v1; // rax\n  char *result; // rax\n  char *s; // [rsp+8h] [rbp-18h]\n  char *v4; // [rsp+10h] [rbp-10h]\n  char *s1; // [rsp+18h] [rbp-8h]\n\n  s = (char *)a1;\n  if ( !a1 )\n  {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\", 1uLL, 0x37uLL, stderr);\n    abort();\n  }\n  v4 = strrchr(a1, 47);\n  if ( v4 )\n    v1 = v4 + 1;\n  else\n    v1 = (char *)a1;\n  s1 = v1;\n  if ( v1 - a1 > 6 && !strncmp(v1 - 7, \"/.libs/\", 7uLL) )\n  {\n    s = s1;\n    if ( !strncmp(s1, \"lt-\", 3uLL) )\n    {\n      s = s1 + 3;\n      program_invocation_short_name = (__int64)(s1 + 3);\n    }\n  }\n  qword_60B310 = (__int64)s;\n  result = s;\n  program_invocation_name = (__int64)s;\n  return result;\n}\n"], [4214982, "sub_4050C6", "__int64 __fastcall sub_4050C6(unsigned int a1, __int64 a2)\n{\n  return sub_406575(a1, 6LL, a2);\n}\n"], [4215018, "sub_4050EA", "__int64 __fastcall sub_4050EA(__int64 a1)\n{\n  return sub_4050C6(0, a1);\n}\n"], [4215049, "sub_405109", "__int64 __fastcall sub_405109(__int64 *a1)\n{\n  __int64 *v1; // rax\n  int v3; // [rsp+14h] [rbp-Ch]\n  __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v3 = *__errno_location();\n  if ( a1 )\n    v1 = a1;\n  else\n    v1 = &qword_60B320;\n  v4 = sub_407340(v1, 56LL);\n  *__errno_location() = v3;\n  return v4;\n}\n"], [4215122, "sub_405152", "__int64 __fastcall sub_405152(__int64 *a1)\n{\n  __int64 *v1; // rax\n\n  if ( a1 )\n    v1 = a1;\n  else\n    v1 = &qword_60B320;\n  return *(unsigned int *)v1;\n}\n"], [4215152, "sub_405170", "__int64 *__fastcall sub_405170(__int64 *a1, int a2)\n{\n  __int64 *result; // rax\n\n  if ( a1 )\n    result = a1;\n  else\n    result = &qword_60B320;\n  *(_DWORD *)result = a2;\n  return result;\n}\n"], [4215188, "sub_405194", "__int64 __fastcall sub_405194(__int64 *a1, unsigned __int8 a2, char a3)\n{\n  __int64 *v3; // rax\n  unsigned int v5; // [rsp+24h] [rbp-Ch]\n\n  if ( a1 )\n    v3 = a1;\n  else\n    v3 = &qword_60B320;\n  v5 = (*((_DWORD *)v3 + (a2 >> 5) + 2) >> (a2 & 0x1F)) & 1;\n  *((_DWORD *)v3 + (a2 >> 5) + 2) ^= (v5 ^ a3 & 1) << (a2 & 0x1F);\n  return v5;\n}\n"], [4215324, "sub_40521C", "__int64 __fastcall sub_40521C(__int64 *a1, int a2)\n{\n  __int64 *v3; // [rsp+4h] [rbp-18h]\n  unsigned int v4; // [rsp+18h] [rbp-4h]\n\n  v3 = a1;\n  if ( !a1 )\n    v3 = &qword_60B320;\n  v4 = *((_DWORD *)v3 + 1);\n  *((_DWORD *)v3 + 1) = a2;\n  return v4;\n}\n"], [4215375, "sub_40524F", "__int64 *__fastcall sub_40524F(__int64 *a1, __int64 a2, __int64 a3)\n{\n  __int64 *result; // rax\n  __int64 *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = a1;\n  if ( !a1 )\n    v4 = &qword_60B320;\n  *(_DWORD *)v4 = 8;\n  if ( !a2 || !a3 )\n    abort();\n  v4[5] = a2;\n  result = v4;\n  v4[6] = a3;\n  return result;\n}\n"], [4215465, "sub_4052A9", "_QWORD *__fastcall sub_4052A9(_QWORD *a1, int a2)\n{\n  __int64 v3[7]; // [rsp+10h] [rbp-40h] BYREF\n\n  memset(v3, 0, sizeof(v3));\n  if ( a2 == 8 )\n    abort();\n  LODWORD(v3[0]) = a2;\n  *a1 = v3[0];\n  a1[1] = v3[1];\n  a1[2] = v3[2];\n  a1[3] = v3[3];\n  a1[4] = v3[4];\n  a1[5] = v3[5];\n  a1[6] = v3[6];\n  return a1;\n}\n"], [4215585, "sub_405321", "char *__fastcall sub_405321(const char *a1, int a2)\n{\n  char *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = gettext(a1);\n  if ( v3 == a1 && a2 == 7 )\n    v3 = (char *)L\"\\\"`'\";\n  return v3;\n}\n"], [4215646, "sub_40535E", "unsigned __int64 __fastcall sub_40535E(__int64 a1, unsigned __int64 a2, __int64 a3, size_t a4, unsigned int a5, int a6, __int64 a7, char *a8, char *a9)\n{\n  int v9; // eax\n  bool v10; // al\n  int v11; // eax\n  char v20; // [rsp+65h] [rbp-6Bh]\n  bool v21; // [rsp+66h] [rbp-6Ah]\n  unsigned __int8 v22; // [rsp+67h] [rbp-69h]\n  char v23; // [rsp+68h] [rbp-68h]\n  char v24; // [rsp+69h] [rbp-67h]\n  bool v25; // [rsp+6Ah] [rbp-66h]\n  bool v26; // [rsp+6Bh] [rbp-65h]\n  wchar_t pwc; // [rsp+6Ch] [rbp-64h] BYREF\n  __int64 i; // [rsp+70h] [rbp-60h]\n  unsigned __int64 v29; // [rsp+78h] [rbp-58h]\n  char *s; // [rsp+80h] [rbp-50h]\n  size_t n; // [rsp+88h] [rbp-48h]\n  unsigned __int64 v32; // [rsp+90h] [rbp-40h]\n  unsigned __int64 j; // [rsp+98h] [rbp-38h]\n  size_t v34; // [rsp+A0h] [rbp-30h]\n  unsigned __int64 v35; // [rsp+A8h] [rbp-28h]\n  mbstate_t p; // [rsp+B0h] [rbp-20h] BYREF\n  unsigned __int64 v37; // [rsp+B8h] [rbp-18h]\n\n  v37 = __readfsqword(0x28u);\n  v29 = 0LL;\n  s = 0LL;\n  n = 0LL;\n  v20 = 0;\n  v26 = __ctype_get_mb_cur_max() == 1;\n  v21 = (a6 & 2) != 0;\n  if ( a5 == 3 )\n    goto LABEL_11;\n  if ( a5 > 3 )\n  {\n    if ( a5 == 5 )\n    {\n      v20 = 1;\n      v21 = 0;\n      goto LABEL_33;\n    }\n    if ( a5 >= 5 )\n    {\n      if ( a5 > 8 )\n        abort();\n      if ( a5 != 8 )\n      {\n        a8 = sub_405321((const char *)L\"`'\", a5);\n        a9 = sub_405321((const char *)L\"'\", a5);\n      }\n      if ( (a6 & 2) == 0 )\n      {\n        for ( s = a8; *s; ++s )\n        {\n          if ( v29 < a2 )\n            *(_BYTE *)(v29 + a1) = *s;\n          ++v29;\n        }\n      }\n      v20 = 1;\n      s = a9;\n      n = strlen(a9);\n      goto LABEL_33;\n    }\n    a5 = 3;\n    v21 = 1;\nLABEL_11:\n    if ( !v21 )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(a1 + v29) = 34;\n      ++v29;\n    }\n    v20 = 1;\n    s = (char *)L\"\\\"`'\";\n    n = 1LL;\n    goto LABEL_33;\n  }\n  if ( a5 == 1 )\n  {\n    a5 = 2;\n    v21 = 1;\n    goto LABEL_27;\n  }\n  if ( a5 > 1 )\n  {\nLABEL_27:\n    if ( !v21 )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(a1 + v29) = 39;\n      ++v29;\n    }\n    s = (_BYTE *)(L\"\\\"`'\" + 4);\n    n = 1LL;\n    goto LABEL_33;\n  }\n  v21 = 0;\nLABEL_33:\n  for ( i = 0LL; a4 == -1LL ? *(_BYTE *)(a3 + i) != 0 : i != a4; ++i )\n  {\n    v24 = 0;\n    if ( v20 && n && i + n <= a4 && !memcmp((const void *)(a3 + i), s, n) )\n    {\n      if ( v21 )\n        return sub_40535E(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n      v24 = 1;\n    }\n    v22 = *(_BYTE *)(a3 + i);\n    if ( v22 > 0x3Au )\n    {\n      if ( v22 == 94 )\n        goto LABEL_144;\n      if ( v22 > 0x5Eu )\n      {\n        if ( v22 <= 0x7Au )\n        {\n          if ( v22 >= 0x61u || v22 == 95 )\n            goto LABEL_206;\n          goto LABEL_144;\n        }\n        if ( v22 != 124 )\n        {\n          if ( v22 < 0x7Cu || v22 == 125 )\n          {\n            if ( a4 == -1LL )\n              v10 = *(_BYTE *)(a3 + 1) != 0;\n            else\n              v10 = a4 != 1;\n            if ( v10 )\n              goto LABEL_206;\n          }\n          else if ( v22 != 126 )\n          {\nLABEL_157:\n            if ( v26 )\n            {\n              v32 = 1LL;\n              v25 = ((*__ctype_b_loc())[v22] & 0x4000) != 0;\n            }\n            else\n            {\n              memset(&p, 0, sizeof(p));\n              v32 = 0LL;\n              v25 = 1;\n              if ( a4 == -1LL )\n                a4 = strlen((const char *)a3);\n              do\n              {\n                v34 = mbrtowc(&pwc, (const char *)(v32 + i + a3), a4 - (v32 + i), &p);\n                if ( !v34 )\n                  break;\n                if ( v34 == -1LL )\n                {\n                  v25 = 0;\n                  break;\n                }\n                if ( v34 == -2LL )\n                {\n                  v25 = 0;\n                  while ( i + v32 < a4 && *(_BYTE *)(v32 + i + a3) )\n                    ++v32;\n                  break;\n                }\n                if ( v21 && a5 == 2 )\n                {\n                  for ( j = 1LL; j < v34; ++j )\n                  {\n                    v11 = *(char *)(j + v32 + i + a3);\n                    if ( v11 == 94 )\n                      return sub_40535E(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    if ( v11 > 94 )\n                    {\n                      if ( v11 == 96 || v11 == 124 )\n                        return sub_40535E(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    }\n                    else if ( (unsigned int)(v11 - 91) <= 1 )\n                    {\n                      return sub_40535E(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    }\n                  }\n                }\n                if ( !iswprint(pwc) )\n                  v25 = 0;\n                v32 += v34;\n              }\n              while ( !mbsinit(&p) );\n            }\n            if ( v32 > 1 || v20 && !v25 )\n            {\n              v35 = i + v32;\n              while ( 1 )\n              {\n                if ( v20 && !v25 )\n                {\n                  if ( v21 )\n                    return sub_40535E(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                  if ( v29 < a2 )\n                    *(_BYTE *)(a1 + v29) = 92;\n                  if ( ++v29 < a2 )\n                    *(_BYTE *)(v29 + a1) = (v22 >> 6) + 48;\n                  if ( ++v29 < a2 )\n                    *(_BYTE *)(v29 + a1) = ((v22 >> 3) & 7) + 48;\n                  ++v29;\n                  v22 = (v22 & 7) + 48;\n                }\n                else if ( v24 )\n                {\n                  if ( v29 < a2 )\n                    *(_BYTE *)(a1 + v29) = 92;\n                  ++v29;\n                  v24 = 0;\n                }\n                if ( i + 1 >= v35 )\n                  break;\n                if ( v29 < a2 )\n                  *(_BYTE *)(v29 + a1) = v22;\n                ++v29;\n                ++i;\n                v22 = *(_BYTE *)(a3 + i);\n              }\n              goto LABEL_215;\n            }\n            goto LABEL_206;\n          }\n          goto LABEL_143;\n        }\nLABEL_144:\n        if ( a5 == 2 && v21 )\n          return sub_40535E(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        goto LABEL_206;\n      }\n      if ( v22 > 0x5Au )\n      {\n        if ( v22 == 92 )\n        {\n          v23 = *(_BYTE *)(a3 + i);\n          if ( v20 && v21 && n )\n            goto LABEL_215;\n          goto LABEL_134;\n        }\n        if ( v22 <= 0x5Cu )\n          goto LABEL_144;\n      }\n      else\n      {\n        if ( v22 >= 0x41u )\n          goto LABEL_206;\n        if ( v22 <= 0x3Eu )\n          goto LABEL_144;\n        if ( v22 != 63 )\n          goto LABEL_157;\n        if ( a5 == 2 )\n        {\n          if ( v21 )\n            return sub_40535E(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        }\n        else if ( a5 == 3 && (a6 & 4) != 0 && i + 2 < a4 && *(_BYTE *)(i + 1 + a3) == 63 )\n        {\n          v9 = *(char *)(i + 2 + a3);\n          if ( v9 != 45 )\n          {\n            if ( v9 > 45 )\n            {\n              if ( v9 != 47 && (v9 < 47 || (unsigned int)(v9 - 60) > 2) )\n                goto LABEL_206;\n            }\n            else if ( v9 != 33 && (v9 < 33 || (unsigned int)(v9 - 39) > 2) )\n            {\n              goto LABEL_206;\n            }\n          }\n          if ( v21 )\n            return sub_40535E(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          v22 = *(_BYTE *)(i + 2 + a3);\n          i += 2LL;\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 63;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 34;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 34;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 63;\n          ++v29;\n        }\n      }\n    }\n    else\n    {\n      if ( v22 >= 0x2Bu )\n        goto LABEL_206;\n      if ( v22 > 0x22u )\n      {\n        if ( v22 != 38 )\n        {\n          if ( v22 > 0x26u )\n          {\n            if ( v22 == 39 )\n            {\n              if ( a5 == 2 )\n              {\n                if ( v21 )\n                  return sub_40535E(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                if ( v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 39;\n                if ( ++v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 92;\n                if ( ++v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 39;\n                ++v29;\n              }\n              goto LABEL_206;\n            }\n            goto LABEL_144;\n          }\n          if ( v22 != 36 )\n          {\n            if ( v22 > 0x24u )\n              goto LABEL_206;\nLABEL_143:\n            if ( i )\n              goto LABEL_206;\n          }\n        }\n        goto LABEL_144;\n      }\n      if ( v22 >= 0x20u )\n        goto LABEL_144;\n      if ( v22 == 9 )\n      {\n        v23 = 116;\n        goto LABEL_134;\n      }\n      if ( v22 > 9u )\n      {\n        if ( v22 == 11 )\n        {\n          v23 = 118;\n        }\n        else\n        {\n          if ( v22 < 0xBu )\n          {\n            v23 = 110;\n            goto LABEL_134;\n          }\n          if ( v22 == 12 )\n          {\n            v23 = 102;\n          }\n          else\n          {\n            if ( v22 != 13 )\n              goto LABEL_157;\n            v23 = 114;\nLABEL_134:\n            if ( a5 == 2 && v21 )\n              return sub_40535E(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          }\n        }\nLABEL_136:\n        if ( v20 )\n        {\n          v22 = v23;\nLABEL_211:\n          if ( v21 )\n            return sub_40535E(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 92;\n          ++v29;\n          goto LABEL_215;\n        }\n        goto LABEL_206;\n      }\n      if ( v22 == 7 )\n      {\n        v23 = 97;\n        goto LABEL_136;\n      }\n      if ( v22 > 7u )\n      {\n        v23 = 98;\n        goto LABEL_136;\n      }\n      if ( v22 )\n        goto LABEL_157;\n      if ( v20 )\n      {\n        if ( v21 )\n          return sub_40535E(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        if ( v29 < a2 )\n          *(_BYTE *)(a1 + v29) = 92;\n        ++v29;\n        if ( i + 1 < a4 && *(char *)(i + 1 + a3) > 47 && *(char *)(i + 1 + a3) <= 57 )\n        {\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 48;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 48;\n          ++v29;\n        }\n        v22 = 48;\n      }\n      else if ( (a6 & 1) != 0 )\n      {\n        continue;\n      }\n    }\nLABEL_206:\n    if ( (v20 == 1 || v21) && a7 && (*(_DWORD *)(4LL * (v22 >> 5) + a7) & (1 << (v22 & 0x1F))) != 0 || v24 == 1 )\n      goto LABEL_211;\nLABEL_215:\n    if ( v29 < a2 )\n      *(_BYTE *)(v29 + a1) = v22;\n    ++v29;\n  }\n  if ( !v29 && a5 == 2 && v21 )\n    return sub_40535E(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n  if ( s && !v21 )\n  {\n    while ( *s )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(v29 + a1) = *s;\n      ++v29;\n      ++s;\n    }\n  }\n  if ( v29 < a2 )\n    *(_BYTE *)(a1 + v29) = 0;\n  return v29;\n}\n"], [4218793, "sub_405FA9", "unsigned __int64 __fastcall sub_405FA9(__int64 a1, unsigned __int64 a2, __int64 a3, size_t a4, __int64 *a5)\n{\n  __int64 *v5; // rax\n  int v9; // [rsp+4Ch] [rbp-14h]\n  __int64 *v10; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+58h] [rbp-8h]\n\n  if ( a5 )\n    v5 = a5;\n  else\n    v5 = &qword_60B320;\n  v10 = v5;\n  v9 = *__errno_location();\n  v11 = sub_40535E(\n          a1,\n          a2,\n          a3,\n          a4,\n          *(_DWORD *)v10,\n          *((_DWORD *)v10 + 1),\n          (__int64)(v10 + 1),\n          (char *)v10[5],\n          (char *)v10[6]);\n  *__errno_location() = v9;\n  return v11;\n}\n"], [4218953, "sub_406049", "__int64 __fastcall sub_406049(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_40607B(a1, a2, 0LL, a3);\n}\n"], [4219003, "sub_40607B", "__int64 __fastcall sub_40607B(__int64 a1, size_t a2, _QWORD *a3, __int64 *a4)\n{\n  __int64 *v4; // rax\n  int v7; // [rsp+40h] [rbp-20h]\n  int v8; // [rsp+44h] [rbp-1Ch]\n  __int64 *v9; // [rsp+48h] [rbp-18h]\n  unsigned __int64 v10; // [rsp+50h] [rbp-10h]\n  __int64 v11; // [rsp+58h] [rbp-8h]\n\n  if ( a4 )\n    v4 = a4;\n  else\n    v4 = &qword_60B320;\n  v9 = v4;\n  v7 = *__errno_location();\n  v8 = *((_DWORD *)v9 + 1) | (a3 == 0LL);\n  v10 = sub_40535E(0LL, 0LL, a1, a2, *(_DWORD *)v9, v8, (__int64)(v9 + 1), (char *)v9[5], (char *)v9[6]) + 1;\n  v11 = sub_407202(v10);\n  sub_40535E(v11, v10, a1, a2, *(_DWORD *)v9, v8, (__int64)(v9 + 1), (char *)v9[5], (char *)v9[6]);\n  *__errno_location() = v7;\n  if ( a3 )\n    *a3 = v10 - 1;\n  return v11;\n}\n"], [4219303, "sub_4061A7", "void sub_4061A7()\n{\n  unsigned int i; // [rsp+4h] [rbp-Ch]\n  void **ptr; // [rsp+8h] [rbp-8h]\n\n  ptr = (void **)off_60B230;\n  for ( i = 1; i < dword_60B210; ++i )\n    free(ptr[2 * i + 1]);\n  if ( ptr[1] != &unk_60B360 )\n  {\n    free(ptr[1]);\n    qword_60B220 = 256LL;\n    off_60B228 = &unk_60B360;\n  }\n  if ( ptr != (void **)&qword_60B220 )\n  {\n    free(ptr);\n    off_60B230 = &qword_60B220;\n  }\n  dword_60B210 = 1;\n}\n"], [4219474, "sub_406252", "void *__fastcall sub_406252(int a1, __int64 a2, size_t a3, __int64 a4)\n{\n  __int64 *v4; // rax\n  void *v5; // rdx\n  bool v9; // [rsp+4Bh] [rbp-45h]\n  int v10; // [rsp+4Ch] [rbp-44h]\n  int v11; // [rsp+54h] [rbp-3Ch]\n  __int64 *v12; // [rsp+58h] [rbp-38h]\n  void *ptr; // [rsp+60h] [rbp-30h]\n  __int64 v14; // [rsp+68h] [rbp-28h]\n  unsigned __int64 v15; // [rsp+70h] [rbp-20h]\n  unsigned __int64 v16; // [rsp+70h] [rbp-20h]\n  unsigned __int64 v17; // [rsp+78h] [rbp-18h]\n\n  v10 = *__errno_location();\n  v12 = off_60B230;\n  if ( a1 < 0 )\n    abort();\n  if ( dword_60B210 <= (unsigned int)a1 )\n  {\n    v14 = (unsigned int)(a1 + 1);\n    v9 = off_60B230 == &qword_60B220;\n    if ( off_60B230 == &qword_60B220 )\n      v4 = 0LL;\n    else\n      v4 = off_60B230;\n    v12 = (__int64 *)sub_407251(v4, 16 * v14);\n    off_60B230 = v12;\n    if ( v9 )\n    {\n      v5 = off_60B228;\n      *v12 = qword_60B220;\n      v12[1] = (__int64)v5;\n    }\n    memset(&v12[2 * (unsigned int)dword_60B210], 0, 16 * (v14 - (unsigned int)dword_60B210));\n    dword_60B210 = a1 + 1;\n  }\n  v15 = v12[2 * a1];\n  ptr = (void *)v12[2 * a1 + 1];\n  v11 = *(_DWORD *)(a4 + 4) | 1;\n  v17 = sub_40535E((__int64)ptr, v15, a2, a3, *(_DWORD *)a4, v11, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 48));\n  if ( v15 <= v17 )\n  {\n    v16 = v17 + 1;\n    v12[2 * a1] = v17 + 1;\n    if ( ptr != &unk_60B360 )\n      free(ptr);\n    ptr = (void *)sub_407202(v16);\n    v12[2 * a1 + 1] = (__int64)ptr;\n    sub_40535E((__int64)ptr, v16, a2, a3, *(_DWORD *)a4, v11, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 48));\n  }\n  *__errno_location() = v10;\n  return ptr;\n}\n"], [4220120, "sub_4064D8", "void *__fastcall sub_4064D8(int a1, __int64 a2)\n{\n  return sub_406252(a1, a2, 0xFFFFFFFFFFFFFFFFLL, (__int64)&qword_60B320);\n}\n"], [4220163, "sub_406503", "void *__fastcall sub_406503(int a1, __int64 a2, size_t a3)\n{\n  return sub_406252(a1, a2, a3, (__int64)&qword_60B320);\n}\n"], [4220207, "sub_40652F", "void *__fastcall sub_40652F(__int64 a1)\n{\n  return sub_4064D8(0, a1);\n}\n"], [4220238, "sub_40654E", "void *__fastcall sub_40654E(__int64 a1, size_t a2)\n{\n  return sub_406503(0, a1, a2);\n}\n"], [4220277, "sub_406575", "void *__fastcall sub_406575(int a1, int a2, __int64 a3)\n{\n  _QWORD v5[8]; // [rsp+10h] [rbp-40h] BYREF\n\n  sub_4052A9(v5, a2);\n  return sub_406252(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)v5);\n}\n"], [4220342, "sub_4065B6", "void *__fastcall sub_4065B6(int a1, int a2, __int64 a3, size_t a4)\n{\n  _QWORD v7[8]; // [rsp+20h] [rbp-40h] BYREF\n\n  sub_4052A9(v7, a2);\n  return sub_406252(a1, a3, a4, (__int64)v7);\n}\n"], [4220405, "sub_4065F5", "void *__fastcall sub_4065F5(int a1, __int64 a2)\n{\n  return sub_406575(0, a1, a2);\n}\n"], [4220441, "sub_406619", "void *__fastcall sub_406619(int a1, __int64 a2, size_t a3)\n{\n  return sub_4065B6(0, a1, a2, a3);\n}\n"], [4220485, "sub_406645", "void *__fastcall sub_406645(__int64 a1, size_t a2, unsigned __int8 a3)\n{\n  __int64 v4[8]; // [rsp+20h] [rbp-40h] BYREF\n\n  v4[0] = qword_60B320;\n  v4[1] = qword_60B328;\n  v4[2] = qword_60B330;\n  v4[3] = qword_60B338;\n  v4[4] = qword_60B340;\n  v4[5] = qword_60B348;\n  v4[6] = qword_60B350;\n  sub_405194(v4, a3, 1);\n  return sub_406252(0, a1, a2, (__int64)v4);\n}\n"], [4220633, "sub_4066D9", "void *__fastcall sub_4066D9(__int64 a1, unsigned __int8 a2)\n{\n  return sub_406645(a1, 0xFFFFFFFFFFFFFFFFLL, a2);\n}\n"], [4220675, "sub_406703", "void *__fastcall sub_406703(__int64 a1)\n{\n  return sub_4066D9(a1, 0x3Au);\n}\n"], [4220706, "sub_406722", "void *__fastcall sub_406722(__int64 a1, size_t a2)\n{\n  return sub_406645(a1, a2, 0x3Au);\n}\n"], [4220748, "sub_40674C", "__int64 __fastcall sub_40674C(unsigned int a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  return sub_406782(a1, a2, a3, a4, -1LL);\n}\n"], [4220802, "sub_406782", "void *__fastcall sub_406782(int a1, __int64 a2, __int64 a3, __int64 a4, size_t a5)\n{\n  __int64 v8[8]; // [rsp+30h] [rbp-40h] BYREF\n\n  v8[0] = qword_60B320;\n  v8[1] = qword_60B328;\n  v8[2] = qword_60B330;\n  v8[3] = qword_60B338;\n  v8[4] = qword_60B340;\n  v8[5] = qword_60B348;\n  v8[6] = qword_60B350;\n  sub_40524F(v8, a2, a3);\n  return sub_406252(a1, a4, a5, (__int64)v8);\n}\n"], [4220953, "sub_406819", "__int64 __fastcall sub_406819(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_40674C(0, a1, a2, a3);\n}\n"], [4221000, "sub_406848", "void *__fastcall sub_406848(__int64 a1, __int64 a2, __int64 a3, size_t a4)\n{\n  return sub_406782(0, a1, a2, a3, a4);\n}\n"], [4221058, "sub_406882", "int __fastcall sub_406882(FILE *a1, const char *a2, const char *a3, const char *a4, __int64 *a5, unsigned __int64 a6)\n{\n  char *v6; // rax\n  char *v7; // rax\n  __int64 v8; // rbx\n  char *v9; // rax\n  __int64 v10; // r12\n  __int64 v11; // rbx\n  char *v12; // rax\n  __int64 v13; // r13\n  __int64 v14; // r12\n  __int64 v15; // rbx\n  char *v16; // rax\n  int result; // eax\n  __int64 v18; // r14\n  __int64 v19; // r13\n  __int64 v20; // r12\n  __int64 v21; // rbx\n  char *v22; // rax\n  __int64 v23; // r13\n  __int64 v24; // r15\n  __int64 v25; // r14\n  __int64 v26; // r12\n  __int64 v27; // rbx\n  char *v28; // rax\n  __int64 v29; // r14\n  __int64 v30; // r13\n  __int64 v31; // r15\n  __int64 v32; // r12\n  __int64 v33; // rbx\n  char *v34; // rax\n  __int64 v35; // r15\n  __int64 v36; // r14\n  __int64 v37; // r13\n  __int64 v38; // r12\n  __int64 v39; // rbx\n  char *v40; // rax\n  __int64 v41; // r15\n  __int64 v42; // r14\n  __int64 v43; // r13\n  __int64 v44; // r12\n  __int64 v45; // rbx\n  char *v46; // rax\n  __int64 v47; // r15\n  __int64 v48; // r14\n  __int64 v49; // r13\n  __int64 v50; // r12\n  __int64 v51; // rbx\n  char *v52; // rax\n  __int64 v53; // [rsp+30h] [rbp-80h]\n  __int64 v54; // [rsp+38h] [rbp-78h]\n  __int64 v55; // [rsp+38h] [rbp-78h]\n  __int64 v56; // [rsp+40h] [rbp-70h]\n  __int64 v57; // [rsp+40h] [rbp-70h]\n  __int64 v58; // [rsp+40h] [rbp-70h]\n  __int64 v59; // [rsp+48h] [rbp-68h]\n  __int64 v60; // [rsp+48h] [rbp-68h]\n  __int64 v61; // [rsp+48h] [rbp-68h]\n  __int64 v62; // [rsp+48h] [rbp-68h]\n\n  if ( a2 )\n    fprintf(a1, \"%s (%s) %s\\n\", a2, a3, a4);\n  else\n    fprintf(a1, \"%s %s\\n\", a3, a4);\n  v6 = gettext(\"(C)\");\n  fprintf(a1, \"Copyright %s %d Free Software Foundation, Inc.\", v6, 2011LL);\n  v7 = gettext(\n         \"\\n\"\n         \"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n         \"\\n\");\n  fputs_unlocked(v7, a1);\n  if ( a6 == 4 )\n  {\n    v18 = a5[3];\n    v19 = a5[2];\n    v20 = a5[1];\n    v21 = *a5;\n    v22 = gettext(\"Written by %s, %s, %s,\\nand %s.\\n\");\n    result = fprintf(a1, v22, v21, v20, v19, v18);\n  }\n  else if ( a6 > 4 )\n  {\n    if ( a6 == 7 )\n    {\n      v35 = a5[6];\n      v36 = a5[5];\n      v37 = a5[4];\n      v60 = a5[3];\n      v56 = a5[2];\n      v38 = a5[1];\n      v39 = *a5;\n      v40 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\");\n      result = fprintf(a1, v40, v39, v38, v56, v60, v37, v36, v35);\n    }\n    else if ( a6 > 7 )\n    {\n      if ( a6 == 8 )\n      {\n        v61 = a5[7];\n        v41 = a5[6];\n        v42 = a5[5];\n        v43 = a5[4];\n        v57 = a5[3];\n        v54 = a5[2];\n        v44 = a5[1];\n        v45 = *a5;\n        v46 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\");\n        result = fprintf(a1, v46, v45, v44, v54, v57, v43, v42, v41, v61);\n      }\n      else\n      {\n        v62 = a5[8];\n        v58 = a5[7];\n        v47 = a5[6];\n        v48 = a5[5];\n        v49 = a5[4];\n        v55 = a5[3];\n        v53 = a5[2];\n        v50 = a5[1];\n        v51 = *a5;\n        if ( a6 == 9 )\n          v52 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\");\n        else\n          v52 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\");\n        result = fprintf(a1, v52, v51, v50, v53, v55, v49, v48, v47, v58, v62);\n      }\n    }\n    else if ( a6 == 5 )\n    {\n      v23 = a5[4];\n      v24 = a5[3];\n      v25 = a5[2];\n      v26 = a5[1];\n      v27 = *a5;\n      v28 = gettext(\"Written by %s, %s, %s,\\n%s, and %s.\\n\");\n      result = fprintf(a1, v28, v27, v26, v25, v24, v23);\n    }\n    else\n    {\n      v29 = a5[5];\n      v30 = a5[4];\n      v59 = a5[3];\n      v31 = a5[2];\n      v32 = a5[1];\n      v33 = *a5;\n      v34 = gettext(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\");\n      result = fprintf(a1, v34, v33, v32, v31, v59, v30, v29);\n    }\n  }\n  else\n  {\n    switch ( a6 )\n    {\n      case 1uLL:\n        v8 = *a5;\n        v9 = gettext(\"Written by %s.\\n\");\n        result = fprintf(a1, v9, v8);\n        break;\n      case 0uLL:\n        abort();\n      case 2uLL:\n        v10 = a5[1];\n        v11 = *a5;\n        v12 = gettext(\"Written by %s and %s.\\n\");\n        result = fprintf(a1, v12, v11, v10);\n        break;\n      default:\n        v13 = a5[2];\n        v14 = a5[1];\n        v15 = *a5;\n        v16 = gettext(\"Written by %s, %s, and %s.\\n\");\n        result = fprintf(a1, v16, v15, v14, v13);\n        break;\n    }\n  }\n  return result;\n}\n"], [4222573, "sub_406E6D", "int __fastcall sub_406E6D(FILE *a1, const char *a2, const char *a3, const char *a4, __int64 *a5)\n{\n  unsigned __int64 i; // [rsp+38h] [rbp-8h]\n\n  for ( i = 0LL; a5[i]; ++i )\n    ;\n  return sub_406882(a1, a2, a3, a4, a5, i);\n}\n"], [4222683, "sub_406EDB", "int __fastcall sub_406EDB(FILE *a1, const char *a2, const char *a3, const char *a4, unsigned int *a5)\n{\n  __int64 *v5; // rax\n  unsigned __int64 i; // [rsp+38h] [rbp-58h]\n  __int64 v8[10]; // [rsp+40h] [rbp-50h] BYREF\n\n  for ( i = 0LL; i <= 9; ++i )\n  {\n    if ( *a5 >= 0x30 )\n    {\n      v5 = (__int64 *)*((_QWORD *)a5 + 1);\n      *((_QWORD *)a5 + 1) = v5 + 1;\n    }\n    else\n    {\n      v5 = (__int64 *)(*((_QWORD *)a5 + 2) + *a5);\n      *a5 += 8;\n    }\n    v8[i] = *v5;\n    if ( !v8[i] )\n      break;\n  }\n  return sub_406882(a1, a2, a3, a4, v8, i);\n}\n"], [4222900, "sub_406FB4", "int sub_406FB4(FILE *a1, const char *a2, const char *a3, const char *a4, ...)\n{\n  gcc_va_list va; // [rsp+28h] [rbp-C8h] BYREF\n\n  va_start(va, a4);\n  return sub_406EDB(a1, a2, a3, a4, (unsigned int *)va);\n}\n"], [4223082, "sub_40706A", "int sub_40706A()\n{\n  char *v0; // rax\n  char *v1; // rax\n  FILE *v2; // rbx\n  char *v3; // rax\n\n  v0 = gettext(\"\\nReport bugs to: %s\\n\");\n  printf(v0, \"bug-coreutils@gnu.org\");\n  v1 = gettext(\"%s home page: <%s>\\n\");\n  printf(v1, \"GNU coreutils\", \"http://www.gnu.org/software/coreutils/\");\n  v2 = stdout;\n  v3 = gettext(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\");\n  return fputs_unlocked(v3, v2);\n}\n"], [4223187, "sub_4070D3", "__int64 __fastcall sub_4070D3(unsigned __int64 a1, unsigned __int64 a2)\n{\n  unsigned __int64 v2; // rdx\n\n  v2 = 0xFFFFFFFFFFFFFFFFLL % a2;\n  if ( 0xFFFFFFFFFFFFFFFFLL / a2 < a1 )\n    sub_40739E(a1, a2, v2);\n  return sub_40721C(a2 * a1, a2, v2);\n}\n"], [4223249, "sub_407111", "__int64 __fastcall sub_407111(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)\n{\n  unsigned __int64 v3; // rax\n  unsigned __int64 v4; // rdx\n\n  v3 = 0xFFFFFFFFFFFFFFFFLL / a3;\n  v4 = 0xFFFFFFFFFFFFFFFFLL % a3;\n  if ( v3 < a2 )\n    sub_40739E(a1, a2, v4);\n  return sub_407251(a1, a3 * a2);\n}\n"], [4223325, "sub_40715D", "__int64 __fastcall sub_40715D(__int64 a1, unsigned __int64 *a2, unsigned __int64 a3)\n{\n  unsigned __int64 v3; // rdx\n  unsigned __int64 v6; // [rsp+28h] [rbp-8h]\n\n  v6 = *a2;\n  if ( a1 )\n  {\n    v3 = 0xAAAAAAAAAAAAAAAALL % a3;\n    if ( 0xAAAAAAAAAAAAAAAALL / a3 <= v6 )\n      sub_40739E(a1, a2, v3);\n    v6 += (v6 + 1) >> 1;\n  }\n  else if ( !v6 )\n  {\n    v6 = (0x80 / a3 == 0) + 0x80 / a3;\n  }\n  *a2 = v6;\n  return sub_407251(a1, a3 * v6);\n}\n"], [4223490, "sub_407202", "__int64 __fastcall sub_407202(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_40721C(a1, a2, a3);\n}\n"], [4223516, "sub_40721C", "void *__fastcall sub_40721C(size_t a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  void *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = malloc(a1);\n  if ( !v4 && a1 )\n    sub_40739E(a1, a2, v2);\n  return v4;\n}\n"], [4223569, "sub_407251", "void *__fastcall sub_407251(void *a1, size_t a2)\n{\n  void *result; // rax\n  __int64 v3; // rdx\n  void *ptr; // [rsp+8h] [rbp-8h]\n\n  if ( a2 || !a1 )\n  {\n    ptr = realloc(a1, a2);\n    if ( !ptr )\n    {\n      if ( a2 )\n        sub_40739E(a1, a2, v3);\n    }\n    result = ptr;\n  }\n  else\n  {\n    free(a1);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4223666, "sub_4072B2", "__int64 __fastcall sub_4072B2(__int64 a1, unsigned __int64 *a2)\n{\n  return sub_40715D(a1, a2, 1uLL);\n}\n"], [4223708, "sub_4072DC", "void *__fastcall sub_4072DC(size_t a1, __int64 a2)\n{\n  void *v2; // rax\n\n  v2 = sub_40721C(a1, a2);\n  return memset(v2, 0, a1);\n}\n"], [4223751, "sub_407307", "void *__fastcall sub_407307(size_t a1, size_t a2)\n{\n  __int64 v2; // rdx\n  void *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = calloc(a1, a2);\n  if ( !v4 )\n    sub_40739E(a1, a2, v2);\n  return v4;\n}\n"], [4223808, "sub_407340", "void *__fastcall sub_407340(const void *a1, size_t a2)\n{\n  void *v2; // rax\n\n  v2 = sub_40721C(a2, a2);\n  return memcpy(v2, a1, a2);\n}\n"], [4223857, "sub_407371", "void *__fastcall sub_407371(const char *a1)\n{\n  size_t v1; // rax\n\n  v1 = strlen(a1);\n  return sub_407340(a1, v1 + 1);\n}\n"], [4223902, "sub_40739E", "void __noreturn sub_40739E()\n{\n  char *v0; // rax\n\n  v0 = gettext(\"memory exhausted\");\n  error(status, 0, \"%s\", v0);\n  abort();\n}\n"], [4223955, "sub_4073D3", "char *__fastcall sub_4073D3(const char *a1, size_t a2)\n{\n  char *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = strndup(a1, a2);\n  if ( !v3 )\n    sub_40739E();\n  return v3;\n}\n"], [4224012, "sub_40740C", "int __fastcall sub_40740C(FILE *a1)\n{\n  int v2; // eax\n  int v3; // [rsp+14h] [rbp-Ch]\n  int v4; // [rsp+18h] [rbp-8h]\n\n  v3 = 0;\n  if ( fileno(a1) < 0 )\n    return fclose(a1);\n  if ( !__freading(a1) || (v2 = fileno(a1), lseek(v2, 0LL, 1) != -1) )\n  {\n    if ( (unsigned int)sub_4074F4(a1) )\n      v3 = *__errno_location();\n  }\n  v4 = fclose(a1);\n  if ( v3 )\n  {\n    *__errno_location() = v3;\n    v4 = -1;\n  }\n  return v4;\n}\n"], [4224193, "sub_4074C1", "__int64 __fastcall sub_4074C1(_DWORD *a1)\n{\n  __int64 result; // rax\n\n  result = *a1 & 0x100;\n  if ( (_DWORD)result )\n    result = sub_40753F(a1, 0LL, 1LL);\n  return result;\n}\n"], [4224244, "sub_4074F4", "int __fastcall sub_4074F4(FILE *a1)\n{\n  if ( !a1 || !__freading(a1) )\n    return fflush(a1);\n  sub_4074C1(a1);\n  return fflush(a1);\n}\n"], [4224319, "sub_40753F", "int __fastcall sub_40753F(FILE *a1, __off_t a2, int a3)\n{\n  int v3; // eax\n  __off_t v6; // [rsp+28h] [rbp-8h]\n\n  if ( a1->_IO_read_end != a1->_IO_read_ptr || a1->_IO_write_ptr != a1->_IO_write_base || a1->_IO_save_base )\n    return fseeko(a1, a2, a3);\n  v3 = fileno(a1);\n  v6 = lseek(v3, a2, a3);\n  if ( v6 == -1 )\n    return -1;\n  a1->_flags &= 0xFFFFFFEF;\n  a1->_offset = v6;\n  return 0;\n}\n"], [4224503, "sub_4075F7", "__int64 __fastcall sub_4075F7(FILE *a1)\n{\n  bool v2; // [rsp+1Dh] [rbp-3h]\n  bool v3; // [rsp+1Eh] [rbp-2h]\n  bool v4; // [rsp+1Fh] [rbp-1h]\n\n  v2 = __fpending(a1) != 0;\n  v3 = ferror_unlocked(a1) != 0;\n  v4 = sub_40740C(a1) != 0;\n  if ( !v3 && (!v4 || !v2 && *__errno_location() == 9) )\n    return 0LL;\n  if ( !v4 )\n    *__errno_location() = 0;\n  return 0xFFFFFFFFLL;\n}\n"], [4224642, "sub_407682", "__int64 __fastcall sub_407682(_QWORD *a1, _QWORD *a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  if ( a1[5] > a1[4] )\n    return 0LL;\n  v3 = a1[2] - a1[1];\n  if ( !v3 )\n    return 0LL;\n  *a2 = v3;\n  return a1[1];\n}\n"], [4224746, "sub_4076EA", "__int64 __fastcall sub_4076EA(__int64 a1, __int64 a2)\n{\n  __int64 result; // rax\n\n  result = a1;\n  *(_QWORD *)(a1 + 8) += a2;\n  return result;\n}\n"], [4224783, "sub_40770F", "int __fastcall sub_40770F(FILE *a1, unsigned __int64 a2)\n{\n  int result; // eax\n  __int64 v3; // rax\n  size_t v4; // rax\n  size_t v5; // rax\n  unsigned __int64 v6; // [rsp+0h] [rbp-1060h]\n  int fd; // [rsp+1Ch] [rbp-1044h]\n  unsigned __int64 v8; // [rsp+20h] [rbp-1040h] BYREF\n  __int64 i; // [rsp+28h] [rbp-1038h]\n  __int64 v10; // [rsp+30h] [rbp-1030h]\n  size_t n; // [rsp+38h] [rbp-1028h]\n  char ptr[4104]; // [rsp+40h] [rbp-1020h] BYREF\n  unsigned __int64 v13; // [rsp+1048h] [rbp-18h]\n\n  v6 = a2;\n  v13 = __readfsqword(0x28u);\n  if ( !a2 )\n    return 0;\n  for ( i = sub_407953(a1); i; --i )\n  {\n    if ( sub_407682(a1, &v8) && v8 )\n    {\n      v3 = v8;\n      if ( v6 <= v8 )\n        v3 = v6;\n      v10 = v3;\n      sub_4076EA((__int64)a1, v3);\n      v6 -= v10;\n      if ( !v6 )\n        return 0;\n      i -= v10;\n      if ( !i )\n        break;\n    }\n    if ( fgetc(a1) == -1 )\n      goto LABEL_24;\n    if ( !--v6 )\n      return 0;\n  }\n  fd = fileno(a1);\n  if ( fd >= 0 && lseek(fd, 0LL, 1) >= 0 )\n    return sub_40753F(a1, v6, 1);\n  while ( 1 )\n  {\n    v4 = 4096LL;\n    if ( v6 <= 0x1000 )\n      v4 = v6;\n    n = v4;\n    v5 = fread(ptr, 1uLL, v4, a1);\n    if ( v5 < n )\n      break;\n    v6 -= n;\n    if ( !v6 )\n      return 0;\n  }\nLABEL_24:\n  if ( ferror(a1) )\n    result = -1;\n  else\n    result = 0;\n  return result;\n}\n"], [4225363, "sub_407953", "__int64 __fastcall sub_407953(__int64 a1)\n{\n  __int64 v2; // rax\n\n  if ( *(_QWORD *)(a1 + 40) > *(_QWORD *)(a1 + 32) )\n    return 0LL;\n  if ( (*(_DWORD *)a1 & 0x100) != 0 )\n    v2 = *(_QWORD *)(a1 + 88) - *(_QWORD *)(a1 + 72);\n  else\n    v2 = 0LL;\n  return *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) + v2;\n}\n"], [4225488, "init", "void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)\n{\n  __int64 v4; // rbx\n  signed __int64 v5; // rbp\n\n  v4 = 0LL;\n  v5 = &off_60AE18 - off_60AE10;\n  init_proc();\n  if ( v5 )\n  {\n    do\n      ((void (__fastcall *)(_QWORD, __int64, __int64))off_60AE10[v4++])(a1, a2, a3);\n    while ( v4 != v5 );\n  }\n}\n"], [4225600, "fini", "void fini(void)\n{\n  ;\n}\n"], [4225616, "sub_407A50", "int __fastcall sub_407A50(void (__fastcall *a1)(void *))\n{\n  void *v1; // rdx\n\n  if ( &qword_60B1F8 )\n    v1 = (void *)qword_60B1F8;\n  else\n    v1 = 0LL;\n  return __cxa_atexit(a1, 0LL, v1);\n}\n"], [4225644, ".term_proc", "void term_proc()\n{\n  ;\n}\n"]]