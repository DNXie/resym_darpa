[[4199720, ".init_proc", "void *init_proc()\n{\n  void *result; // rax\n\n  result = &_gmon_start__;\n  if ( &_gmon_start__ )\n    result = (void *)__gmon_start__();\n  return result;\n}\n"], [4199760, "sub_401550", "__int64 sub_401550()\n{\n  return qword_610010();\n}\n"], [4199776, ".getenv", "// attributes: thunk\nchar *getenv(const char *name)\n{\n  return getenv(name);\n}\n"], [4199792, ".free", "// attributes: thunk\nvoid free(void *ptr)\n{\n  free(ptr);\n}\n"], [4199808, ".abort", "// attributes: thunk\nvoid __noreturn abort(void)\n{\n  abort();\n}\n"], [4199824, ".__errno_location", "// attributes: thunk\nint *__errno_location(void)\n{\n  return _errno_location();\n}\n"], [4199840, ".strncmp", "// attributes: thunk\nint strncmp(const char *s1, const char *s2, size_t n)\n{\n  return strncmp(s1, s2, n);\n}\n"], [4199856, "._exit", "// attributes: thunk\nvoid __noreturn _exit(int status)\n{\n  exit(status);\n}\n"], [4199872, ".__fpending", "// attributes: thunk\nsize_t __fpending(FILE *fp)\n{\n  return _fpending(fp);\n}\n"], [4199888, ".isatty", "// attributes: thunk\nint isatty(int fd)\n{\n  return isatty(fd);\n}\n"], [4199904, ".fcntl", "// attributes: thunk\nint fcntl(int fd, int cmd, ...)\n{\n  return fcntl(fd, cmd);\n}\n"], [4199920, ".textdomain", "// attributes: thunk\nchar *textdomain(const char *domainname)\n{\n  return textdomain(domainname);\n}\n"], [4199936, ".strtod_l", "// attributes: thunk\ndouble strtod_l(const char *nptr, char **endptr, __locale_t loc)\n{\n  return strtod_l(nptr, endptr, loc);\n}\n"], [4199952, ".fclose", "// attributes: thunk\nint fclose(FILE *stream)\n{\n  return fclose(stream);\n}\n"], [4199968, ".bindtextdomain", "// attributes: thunk\nchar *bindtextdomain(const char *domainname, const char *dirname)\n{\n  return bindtextdomain(domainname, dirname);\n}\n"], [4199984, ".__ctype_get_mb_cur_max", "// attributes: thunk\nsize_t __ctype_get_mb_cur_max(void)\n{\n  return _ctype_get_mb_cur_max();\n}\n"], [4200000, ".strlen", "// attributes: thunk\nsize_t strlen(const char *s)\n{\n  return strlen(s);\n}\n"], [4200016, ".__stack_chk_fail", "// attributes: thunk\nvoid __noreturn __stack_chk_fail()\n{\n  _stack_chk_fail();\n}\n"], [4200032, ".getopt_long", "// attributes: thunk\nint getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind)\n{\n  return getopt_long(argc, argv, shortopts, longopts, longind);\n}\n"], [4200048, ".mbrtowc", "// attributes: thunk\nsize_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p)\n{\n  return mbrtowc(pwc, s, n, p);\n}\n"], [4200064, ".gettext", "// attributes: thunk\nchar *gettext(const char *msgid)\n{\n  return gettext(msgid);\n}\n"], [4200080, ".strchr", "// attributes: thunk\nchar *strchr(const char *s, int c)\n{\n  return strchr(s, c);\n}\n"], [4200096, ".printf", "// attributes: thunk\nint printf(const char *format, ...)\n{\n  return printf(format);\n}\n"], [4200112, ".newlocale", "// attributes: thunk\n__locale_t newlocale(int category_mask, const char *locale, __locale_t base)\n{\n  return newlocale(category_mask, locale, base);\n}\n"], [4200128, ".nanosleep", "// attributes: thunk\nint nanosleep(const struct timespec *requested_time, struct timespec *remaining)\n{\n  return nanosleep(requested_time, remaining);\n}\n"], [4200144, ".strrchr", "// attributes: thunk\nchar *strrchr(const char *s, int c)\n{\n  return strrchr(s, c);\n}\n"], [4200160, ".lseek", "// attributes: thunk\n__off_t lseek(int fd, __off_t offset, int whence)\n{\n  return lseek(fd, offset, whence);\n}\n"], [4200176, ".__assert_fail", "// attributes: thunk\nvoid __noreturn __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function)\n{\n  _assert_fail(assertion, file, line, function);\n}\n"], [4200192, ".memset", "// attributes: thunk\nvoid *memset(void *s, int c, size_t n)\n{\n  return memset(s, c, n);\n}\n"], [4200208, ".close", "// attributes: thunk\nint close(int fd)\n{\n  return close(fd);\n}\n"], [4200224, ".memchr", "// attributes: thunk\nvoid *memchr(const void *s, int c, size_t n)\n{\n  return memchr(s, c, n);\n}\n"], [4200240, ".read", "// attributes: thunk\nssize_t read(int fd, void *buf, size_t nbytes)\n{\n  return read(fd, buf, nbytes);\n}\n"], [4200256, ".__libc_start_main", "// attributes: thunk\nint __fastcall __libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end)\n{\n  return _libc_start_main(main, argc, ubp_av, init, fini, rtld_fini, stack_end);\n}\n"], [4200272, ".memcmp", "// attributes: thunk\nint memcmp(const void *s1, const void *s2, size_t n)\n{\n  return memcmp(s1, s2, n);\n}\n"], [4200288, ".fputs_unlocked", "// attributes: thunk\nint fputs_unlocked(const char *s, FILE *stream)\n{\n  return fputs_unlocked(s, stream);\n}\n"], [4200304, ".ferror_unlocked", "// attributes: thunk\nint ferror_unlocked(FILE *stream)\n{\n  return ferror_unlocked(stream);\n}\n"], [4200320, ".calloc", "// attributes: thunk\nvoid *calloc(size_t nmemb, size_t size)\n{\n  return calloc(nmemb, size);\n}\n"], [4200336, ".strcmp", "// attributes: thunk\nint strcmp(const char *s1, const char *s2)\n{\n  return strcmp(s1, s2);\n}\n"], [4200352, ".fprintf", "// attributes: thunk\nint fprintf(FILE *stream, const char *format, ...)\n{\n  return fprintf(stream, format);\n}\n"], [4200368, ".__gmon_start__", "// attributes: thunk\n__int64 __gmon_start__(void)\n{\n  return _gmon_start__();\n}\n"], [4200384, ".strtol", "// attributes: thunk\n__int64 strtol(const char *nptr, char **endptr, int base)\n{\n  return strtol(nptr, endptr, base);\n}\n"], [4200400, ".memcpy", "// attributes: thunk\nvoid *memcpy(void *dest, const void *src, size_t n)\n{\n  return memcpy(dest, src, n);\n}\n"], [4200416, ".kill", "// attributes: thunk\nint kill(__pid_t pid, int sig)\n{\n  return kill(pid, sig);\n}\n"], [4200432, ".inotify_init", "// attributes: thunk\nint inotify_init(void)\n{\n  return inotify_init();\n}\n"], [4200448, ".fileno", "// attributes: thunk\nint fileno(FILE *stream)\n{\n  return fileno(stream);\n}\n"], [4200464, ".select", "// attributes: thunk\nint select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)\n{\n  return select(nfds, readfds, writefds, exceptfds, timeout);\n}\n"], [4200480, ".putc_unlocked", "// attributes: thunk\nint putc_unlocked(int c, FILE *stream)\n{\n  return putc_unlocked(c, stream);\n}\n"], [4200496, ".malloc", "// attributes: thunk\nvoid *malloc(size_t size)\n{\n  return malloc(size);\n}\n"], [4200512, ".fflush", "// attributes: thunk\nint fflush(FILE *stream)\n{\n  return fflush(stream);\n}\n"], [4200528, ".inotify_add_watch", "// attributes: thunk\nint inotify_add_watch(int fd, const char *name, uint32_t mask)\n{\n  return inotify_add_watch(fd, name, mask);\n}\n"], [4200544, ".__fxstat", "// attributes: thunk\nint __fxstat(int ver, int fildes, struct stat *stat_buf)\n{\n  return _fxstat(ver, fildes, stat_buf);\n}\n"], [4200560, ".__freading", "// attributes: thunk\nint __freading(FILE *fp)\n{\n  return _freading(fp);\n}\n"], [4200576, ".fwrite_unlocked", "// attributes: thunk\nsize_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)\n{\n  return fwrite_unlocked(ptr, size, n, stream);\n}\n"], [4200592, ".realloc", "// attributes: thunk\nvoid *realloc(void *ptr, size_t size)\n{\n  return realloc(ptr, size);\n}\n"], [4200608, ".setlocale", "// attributes: thunk\nchar *setlocale(int category, const char *locale)\n{\n  return setlocale(category, locale);\n}\n"], [4200624, ".error", "// attributes: thunk\nvoid error(int status, int errnum, const char *format, ...)\n{\n  error(status, errnum, format);\n}\n"], [4200640, ".memrchr", "// attributes: thunk\nvoid *memrchr(const void *s, int c, size_t n)\n{\n  return memrchr(s, c, n);\n}\n"], [4200656, ".open", "// attributes: thunk\nint open(const char *file, int oflag, ...)\n{\n  return open(file, oflag);\n}\n"], [4200672, ".fseeko", "// attributes: thunk\nint fseeko(FILE *stream, __off_t off, int whence)\n{\n  return fseeko(stream, off, whence);\n}\n"], [4200688, ".strtoumax", "// attributes: thunk\nuintmax_t strtoumax(const char *nptr, char **endptr, int base)\n{\n  return strtoumax(nptr, endptr, base);\n}\n"], [4200704, ".strtoul", "// attributes: thunk\nunsigned __int64 strtoul(const char *nptr, char **endptr, int base)\n{\n  return strtoul(nptr, endptr, base);\n}\n"], [4200720, ".fstatfs", "// attributes: thunk\nint fstatfs(int fildes, struct statfs *buf)\n{\n  return fstatfs(fildes, buf);\n}\n"], [4200736, ".__cxa_atexit", "// attributes: thunk\nint __fastcall __cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle)\n{\n  return _cxa_atexit(lpfunc, obj, lpdso_handle);\n}\n"], [4200752, ".exit", "// attributes: thunk\nvoid __noreturn exit(int status)\n{\n  exit(status);\n}\n"], [4200768, ".fwrite", "// attributes: thunk\nsize_t fwrite(const void *ptr, size_t size, size_t n, FILE *s)\n{\n  return fwrite(ptr, size, n, s);\n}\n"], [4200784, ".fflush_unlocked", "// attributes: thunk\nint fflush_unlocked(FILE *stream)\n{\n  return fflush_unlocked(stream);\n}\n"], [4200800, ".mbsinit", "// attributes: thunk\nint mbsinit(const mbstate_t *ps)\n{\n  return mbsinit(ps);\n}\n"], [4200816, ".iswprint", "// attributes: thunk\nint iswprint(wint_t wc)\n{\n  return iswprint(wc);\n}\n"], [4200832, ".inotify_rm_watch", "// attributes: thunk\nint inotify_rm_watch(int fd, int wd)\n{\n  return inotify_rm_watch(fd, wd);\n}\n"], [4200848, ".__ctype_b_loc", "// attributes: thunk\nconst unsigned __int16 **__ctype_b_loc(void)\n{\n  return _ctype_b_loc();\n}\n"], [4200864, "start", "// positive sp value has been detected, the output may be wrong!\nvoid __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))\n{\n  __int64 v3; // rax\n  int v4; // esi\n  __int64 v5; // [rsp-8h] [rbp-8h] BYREF\n  char *retaddr; // [rsp+0h] [rbp+0h] BYREF\n\n  v4 = v5;\n  v5 = v3;\n  __libc_start_main(main, v4, &retaddr, init, fini, a3, &v5);\n  __halt();\n}\n"], [4200912, "sub_4019D0", "signed __int64 sub_4019D0()\n{\n  signed __int64 result; // rax\n\n  result = &unk_6102BF - &unk_6102B8;\n  if ( (unsigned __int64)(&unk_6102BF - &unk_6102B8) > 0xE )\n    result = 0LL;\n  return result;\n}\n"], [4200960, "sub_401A00", "__int64 sub_401A00()\n{\n  return 0LL;\n}\n"], [4201024, "sub_401A40", "signed __int64 sub_401A40()\n{\n  signed __int64 result; // rax\n\n  if ( !byte_610318 )\n  {\n    result = sub_4019D0();\n    byte_610318 = 1;\n  }\n  return result;\n}\n"], [4201056, "sub_401A60", "__int64 sub_401A60()\n{\n  return sub_401A00();\n}\n"], [4201101, "sub_401A8D", "__int64 __fastcall sub_401A8D(__int64 a1, int a2, __int64 a3, int a4)\n{\n  if ( a1 < a3 )\n    return 0xFFFFFFFFLL;\n  if ( a1 > a3 )\n    return 1LL;\n  return (unsigned int)(a2 - a4);\n}\n"], [4201192, "sub_401AE8", "int sub_401AE8()\n{\n  __int64 v0; // rbx\n  char *v1; // rax\n  char *v2; // rax\n  FILE *v3; // rbx\n  char *v4; // rax\n  __int64 v5; // rbx\n  char *v6; // rax\n  __int64 v7; // rbx\n  char *v8; // rax\n  const char *s1; // [rsp+8h] [rbp-18h]\n\n  v0 = sub_407277(qword_610348);\n  v1 = gettext(\"\\nReport %s bugs to %s\\n\");\n  printf(v1, v0, \"bug-coreutils@gnu.org\");\n  v2 = gettext(\"%s home page: <%s>\\n\");\n  printf(v2, \"GNU coreutils\", \"http://www.gnu.org/software/coreutils/\");\n  v3 = stdout;\n  v4 = gettext(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\");\n  fputs_unlocked(v4, v3);\n  s1 = setlocale(5, 0LL);\n  if ( s1 && strncmp(s1, \"en_\", 3uLL) )\n  {\n    v5 = sub_407277(qword_610348);\n    v6 = gettext(\"Report %s translation bugs to <http://translationproject.org/team/>\\n\");\n    printf(v6, v5);\n  }\n  v7 = sub_407277(qword_610348);\n  v8 = gettext(\"For complete documentation, run: info coreutils '%s invocation'\\n\");\n  return printf(v8, v7);\n}\n"], [4201458, "sub_401BF2", "__int64 __fastcall sub_401BF2(__int64 a1)\n{\n  return *(_QWORD *)(a1 + 88);\n}\n"], [4201480, "sub_401C08", "void __fastcall __noreturn sub_401C08(int a1)\n{\n  __int64 v1; // rbx\n  char *v2; // rax\n  char *v3; // rax\n  char *v4; // rax\n  FILE *v5; // rbx\n  char *v6; // rax\n  FILE *v7; // rbx\n  char *v8; // rax\n  FILE *v9; // rbx\n  char *v10; // rax\n  char *v11; // rax\n  FILE *v12; // rbx\n  char *v13; // rax\n  FILE *v14; // rbx\n  char *v15; // rax\n  FILE *v16; // rbx\n  char *v17; // rax\n  FILE *v18; // rbx\n  char *v19; // rax\n  FILE *v20; // rbx\n  char *v21; // rax\n  FILE *v22; // rbx\n  char *v23; // rax\n\n  v1 = qword_610348;\n  if ( a1 )\n  {\n    v2 = gettext(\"Try `%s --help' for more information.\\n\");\n    fprintf(stderr, v2, v1);\n  }\n  else\n  {\n    v3 = gettext(\"Usage: %s [OPTION]... [FILE]...\\n\");\n    printf(v3, v1);\n    v4 = gettext(\n           \"Print the last %d lines of each FILE to standard output.\\n\"\n           \"With more than one FILE, precede each with a header giving the file name.\\n\"\n           \"With no FILE, or when FILE is -, read standard input.\\n\"\n           \"\\n\");\n    printf(v4, 10LL);\n    v5 = stdout;\n    v6 = gettext(\"Mandatory arguments to long options are mandatory for short options too.\\n\");\n    fputs_unlocked(v6, v5);\n    v7 = stdout;\n    v8 = gettext(\n           \"  -c, --bytes=K            output the last K bytes; alternatively, use -c +K\\n\"\n           \"                           to output bytes starting with the Kth of each file\\n\");\n    fputs_unlocked(v8, v7);\n    v9 = stdout;\n    v10 = gettext(\n            \"  -f, --follow[={name|descriptor}]\\n\"\n            \"                           output appended data as the file grows;\\n\"\n            \"                           -f, --follow, and --follow=descriptor are\\n\"\n            \"                           equivalent\\n\"\n            \"  -F                       same as --follow=name --retry\\n\");\n    fputs_unlocked(v10, v9);\n    v11 = gettext(\n            \"  -n, --lines=K            output the last K lines, instead of the last %d;\\n\"\n            \"                           or use -n +K to output lines starting with the Kth\\n\"\n            \"      --max-unchanged-stats=N\\n\"\n            \"                           with --follow=name, reopen a FILE which has not\\n\"\n            \"                           changed size after N (default %d) iterations\\n\"\n            \"                           to see if it has been unlinked or renamed\\n\"\n            \"                           (this is the usual case of rotated log files).\\n\"\n            \"                           With inotify, this option is rarely useful.\\n\");\n    printf(v11, 10LL, 5LL);\n    v12 = stdout;\n    v13 = gettext(\n            \"      --pid=PID            with -f, terminate after process ID, PID dies\\n\"\n            \"  -q, --quiet, --silent    never output headers giving file names\\n\"\n            \"      --retry              keep trying to open a file even when it is or\\n\"\n            \"                             becomes inaccessible; useful when following by\\n\"\n            \"                             name, i.e., with --follow=name\\n\");\n    fputs_unlocked(v13, v12);\n    v14 = stdout;\n    v15 = gettext(\n            \"  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\\n\"\n            \"                             (default 1.0) between iterations.\\n\"\n            \"                             With inotify and --pid=P, check process P at\\n\"\n            \"                             least once every N seconds.\\n\"\n            \"  -v, --verbose            always output headers giving file names\\n\");\n    fputs_unlocked(v15, v14);\n    v16 = stdout;\n    v17 = gettext(\"      --help     display this help and exit\\n\");\n    fputs_unlocked(v17, v16);\n    v18 = stdout;\n    v19 = gettext(\"      --version  output version information and exit\\n\");\n    fputs_unlocked(v19, v18);\n    v20 = stdout;\n    v21 = gettext(\n            \"\\n\"\n            \"If the first character of K (the number of bytes or lines) is a `+',\\n\"\n            \"print beginning with the Kth item from the start of each file, otherwise,\\n\"\n            \"print the last K items in the file.  K may have a multiplier suffix:\\n\"\n            \"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\\n\"\n            \"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\\n\"\n            \"\\n\");\n    fputs_unlocked(v21, v20);\n    v22 = stdout;\n    v23 = gettext(\n            \"With --follow (-f), tail defaults to following the file descriptor, which\\n\"\n            \"means that even if a tail'ed file is renamed, tail will continue to track\\n\"\n            \"its end.  This default behavior is not desirable when you really want to\\n\"\n            \"track the actual name of the file, not the file descriptor (e.g., log\\n\"\n            \"rotation).  Use --follow=name in that case.  That causes tail to track the\\n\"\n            \"named file in a way that accommodates renaming, removal and creation.\\n\");\n    fputs_unlocked(v23, v22);\n    sub_401AE8();\n  }\n  exit(a1);\n}\n"], [4201910, "sub_401DB6", "bool __fastcall sub_401DB6(__int64 a1)\n{\n  return (*(_DWORD *)(a1 + 56) == -1) != (*(_DWORD *)(a1 + 60) == 0);\n}\n"], [4201958, "sub_401DE6", "char *__fastcall sub_401DE6(const char **a1)\n{\n  char *result; // rax\n\n  if ( !strcmp(*a1, \"-\") )\n    result = gettext(\"standard input\");\n  else\n    result = (char *)*a1;\n  return result;\n}\n"], [4202015, "sub_401E1F", "void __fastcall sub_401E1F(const void *a1, size_t a2)\n{\n  char *v2; // rbx\n  int *v3; // rax\n\n  if ( a2 )\n  {\n    if ( !fwrite_unlocked(a1, 1uLL, a2, stdout) )\n    {\n      v2 = gettext(\"write error\");\n      v3 = __errno_location();\n      error(1, *v3, v2);\n    }\n  }\n}\n"], [4202119, "sub_401E87", "__int64 __fastcall sub_401E87(__int64 a1, int a2, __int64 a3, __int64 a4, int a5)\n{\n  __int64 v5; // rdx\n  __int64 result; // rax\n\n  *(_DWORD *)(a1 + 56) = a2;\n  *(_QWORD *)(a1 + 8) = a3;\n  *(_QWORD *)(a1 + 16) = sub_401BF2(a4);\n  *(_QWORD *)(a1 + 24) = v5;\n  *(_QWORD *)(a1 + 32) = *(_QWORD *)a4;\n  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a4 + 8);\n  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a4 + 24);\n  *(_DWORD *)(a1 + 64) = a5;\n  *(_QWORD *)(a1 + 88) = 0LL;\n  result = a1;\n  *(_BYTE *)(a1 + 52) = 0;\n  return result;\n}\n"], [4202275, "sub_401F23", "void __fastcall sub_401F23(unsigned int a1, __int64 a2)\n{\n  char *v2; // rbx\n  int *v3; // rax\n\n  if ( a1 != -1 && a1 )\n  {\n    if ( close(a1) )\n    {\n      v2 = gettext(\"closing %s (fd=%d)\");\n      v3 = __errno_location();\n      error(0, *v3, v2, a2, a1);\n    }\n  }\n}\n"], [4202377, "sub_401F89", "int __fastcall sub_401F89(const char *a1)\n{\n  const char *v1; // rax\n  int result; // eax\n\n  if ( byte_610260 )\n    v1 = &locale;\n  else\n    v1 = \"\\n\";\n  result = printf(\"%s==> %s <==\\n\", v1, a1);\n  byte_610260 = 0;\n  return result;\n}\n"], [4202443, "sub_401FCB", "__int64 __fastcall sub_401FCB(__int64 a1, unsigned int a2, unsigned __int64 a3)\n{\n  __int64 v3; // rax\n  __int64 v4; // r12\n  char *v5; // rbx\n  int *v6; // rax\n  unsigned __int64 v8; // [rsp+8h] [rbp-2058h]\n  __int64 v9; // [rsp+20h] [rbp-2040h]\n  unsigned __int64 v10; // [rsp+28h] [rbp-2038h]\n  size_t v11; // [rsp+38h] [rbp-2028h]\n  char v12[8200]; // [rsp+40h] [rbp-2020h] BYREF\n  unsigned __int64 v13; // [rsp+2048h] [rbp-18h]\n\n  v8 = a3;\n  v13 = __readfsqword(0x28u);\n  v10 = a3;\n  v9 = 0LL;\n  while ( 1 )\n  {\n    v3 = 0x2000LL;\n    if ( v10 <= 0x2000 )\n      v3 = v10;\n    v11 = sub_40A739(a2, v12, v3);\n    if ( v11 == -1LL )\n      break;\n    if ( v11 )\n    {\n      sub_401E1F(v12, v11);\n      v9 += v11;\n      if ( v8 == -1LL )\n        continue;\n      v10 -= v11;\n      if ( v10 )\n      {\n        if ( v8 != -2LL )\n          continue;\n      }\n    }\n    return v9;\n  }\n  if ( *__errno_location() != 11 )\n  {\n    v4 = sub_408FA1(a1);\n    v5 = gettext(\"error reading %s\");\n    v6 = __errno_location();\n    error(1, *v6, v5, v4);\n  }\n  return v9;\n}\n"], [4202811, "sub_40213B", "__off_t __fastcall sub_40213B(int a1, __off_t a2, int a3, __int64 a4)\n{\n  char *v5; // rbx\n  int *v6; // rax\n  char *v7; // rbx\n  int *v8; // rax\n  char *v9; // rbx\n  int *v10; // rax\n  __off_t v13; // [rsp+20h] [rbp-40h]\n  __int64 v14; // [rsp+28h] [rbp-38h]\n  char v15[24]; // [rsp+30h] [rbp-30h] BYREF\n  unsigned __int64 v16; // [rsp+48h] [rbp-18h]\n\n  v16 = __readfsqword(0x28u);\n  v13 = lseek(a1, a2, a3);\n  if ( v13 < 0 )\n  {\n    v14 = sub_408CE0(a2, v15);\n    if ( a3 == 1 )\n    {\n      v7 = gettext(\"%s: cannot seek to relative offset %s\");\n      v8 = __errno_location();\n      error(0, *v8, v7, a4, v14);\n    }\n    else if ( a3 == 2 )\n    {\n      v9 = gettext(\"%s: cannot seek to end-relative offset %s\");\n      v10 = __errno_location();\n      error(0, *v10, v9, a4, v14);\n    }\n    else\n    {\n      if ( a3 )\n        abort();\n      v5 = gettext(\"%s: cannot seek to offset %s\");\n      v6 = __errno_location();\n      error(0, *v6, v5, a4, v14);\n    }\n    exit(1);\n  }\n  return v13;\n}\n"], [4203147, "sub_40228B", "__int64 __fastcall sub_40228B(__int64 a1, unsigned int a2, __int64 a3, __off_t a4, unsigned __int64 a5, __int64 *a6)\n{\n  __int64 result; // rax\n  __int64 v7; // r12\n  char *v8; // rbx\n  int *v9; // rax\n  __int64 v11; // rbx\n  __int64 v12; // r12\n  char *v13; // rbx\n  int *v14; // rax\n  __int64 v18; // [rsp+18h] [rbp-2058h]\n  __int64 v19; // [rsp+30h] [rbp-2040h]\n  __int64 v20; // [rsp+30h] [rbp-2040h]\n  __off_t v21; // [rsp+38h] [rbp-2038h]\n  size_t n; // [rsp+40h] [rbp-2030h]\n  char *v23; // [rsp+48h] [rbp-2028h]\n  char s[8200]; // [rsp+50h] [rbp-2020h] BYREF\n  unsigned __int64 v25; // [rsp+2058h] [rbp-18h]\n\n  v18 = a3;\n  v25 = __readfsqword(0x28u);\n  if ( !a3 )\n    return 1LL;\n  v19 = (__int64)(a5 - a4) % 0x2000;\n  if ( !v19 )\n    v19 = 0x2000LL;\n  v21 = a5 - v19;\n  sub_40213B(a2, a5 - v19, 0, a1);\n  v20 = sub_40A739(a2, s, v19);\n  if ( v20 == -1 )\n  {\n    v7 = sub_408FA1(a1);\n    v8 = gettext(\"error reading %s\");\n    v9 = __errno_location();\n    error(0, *v9, v8, v7);\n    result = 0LL;\n  }\n  else\n  {\n    *a6 = v20 + v21;\n    if ( v20 && s[v20 - 1] != 10 )\n      --v18;\nLABEL_10:\n    n = v20;\n    do\n    {\n      if ( !n || (v23 = (char *)memrchr(s, 10, n)) == 0LL )\n      {\n        if ( v21 == a4 )\n        {\n          sub_40213B(a2, a4, 0, a1);\n          *a6 = sub_401FCB(a1, a2, a5) + a4;\n          return 1LL;\n        }\n        v21 -= 0x2000LL;\n        sub_40213B(a2, v21, 0, a1);\n        v20 = sub_40A739(a2, s, 0x2000LL);\n        if ( v20 == -1 )\n        {\n          v12 = sub_408FA1(a1);\n          v13 = gettext(\"error reading %s\");\n          v14 = __errno_location();\n          error(0, *v14, v13, v12);\n          return 0LL;\n        }\n        *a6 = v20 + v21;\n        if ( !v20 )\n          return 1LL;\n        goto LABEL_10;\n      }\n      n = v23 - s;\n    }\n    while ( v18-- );\n    if ( v20 - 1 != n )\n      sub_401E1F(v23 + 1, v20 - n - 1);\n    v11 = *a6;\n    *a6 = v11 + sub_401FCB(a1, a2, a5 - (v21 + v20));\n    result = 1LL;\n  }\n  return result;\n}\n"], [4204201, "sub_4026A9", "__int64 __fastcall sub_4026A9(__int64 a1, unsigned int a2, size_t a3, _QWORD *a4)\n{\n  __int64 v4; // rax\n  __int64 v5; // r12\n  char *v6; // rbx\n  int *v7; // rax\n  unsigned __int8 v11; // [rsp+2Fh] [rbp-61h]\n  size_t *ptr; // [rsp+30h] [rbp-60h]\n  size_t *v13; // [rsp+38h] [rbp-58h]\n  size_t *src; // [rsp+40h] [rbp-50h]\n  size_t *srca; // [rsp+40h] [rbp-50h]\n  size_t *srcb; // [rsp+40h] [rbp-50h]\n  size_t *srcc; // [rsp+40h] [rbp-50h]\n  unsigned __int64 v18; // [rsp+48h] [rbp-48h]\n  size_t *s; // [rsp+50h] [rbp-40h]\n  char *sa; // [rsp+50h] [rbp-40h]\n  size_t *v21; // [rsp+58h] [rbp-38h]\n  char *v22; // [rsp+58h] [rbp-38h]\n  __int64 i; // [rsp+60h] [rbp-30h]\n  __int64 v24; // [rsp+68h] [rbp-28h]\n  char *v25; // [rsp+70h] [rbp-20h]\n  char *v26; // [rsp+78h] [rbp-18h]\n\n  v18 = 0LL;\n  v11 = 1;\n  v13 = (size_t *)sub_40B191(8216LL);\n  ptr = v13;\n  v13[1025] = 0LL;\n  v13[1024] = v13[1025];\n  v13[1026] = 0LL;\n  src = (size_t *)sub_40B191(8216LL);\n  while ( 1 )\n  {\n    v4 = sub_40A739(a2, src, 0x2000LL);\n    v24 = v4;\n    if ( !v4 || v4 == -1 )\n      break;\n    src[1024] = v4;\n    *a4 += v4;\n    src[1025] = 0LL;\n    src[1026] = 0LL;\n    v25 = (char *)src + v4;\n    s = src;\n    while ( 1 )\n    {\n      sa = (char *)memchr(s, 10, v25 - (char *)s);\n      if ( !sa )\n        break;\n      s = (size_t *)(sa + 1);\n      ++src[1025];\n    }\n    v18 += src[1025];\n    if ( src[1024] + v13[1024] > 0x1FFF )\n    {\n      v13[1026] = (size_t)src;\n      v13 = (size_t *)v13[1026];\n      if ( v18 - ptr[1025] <= a3 )\n      {\n        src = (size_t *)sub_40B191(8216LL);\n      }\n      else\n      {\n        src = ptr;\n        v18 -= ptr[1025];\n        ptr = (size_t *)ptr[1026];\n      }\n    }\n    else\n    {\n      memcpy((char *)v13 + v13[1024], src, src[1024]);\n      v13[1024] += src[1024];\n      v13[1025] += src[1025];\n    }\n  }\n  free(src);\n  if ( v24 == -1 )\n  {\n    v5 = sub_408FA1(a1);\n    v6 = gettext(\"error reading %s\");\n    v7 = __errno_location();\n    error(0, *v7, v6, v5);\n    v11 = 0;\n  }\n  else if ( v13[1024] && a3 )\n  {\n    if ( *((_BYTE *)v13 + v13[1024] - 1) != 10 )\n    {\n      ++v13[1025];\n      ++v18;\n    }\n    for ( srca = ptr; v18 - srca[1025] > a3; srca = (size_t *)srca[1026] )\n      v18 -= srca[1025];\n    v21 = srca;\n    v26 = (char *)srca + srca[1024];\n    if ( v18 > a3 )\n    {\n      for ( i = v18 - a3; i; --i )\n      {\n        v22 = (char *)memchr(v21, 10, v26 - (char *)v21);\n        if ( !v22 )\n          __assert_fail(\"beg\", \"../../src/src/tail.c\", 0x2A7u, \"pipe_lines\");\n        v21 = (size_t *)(v22 + 1);\n      }\n    }\n    sub_401E1F(v21, v26 - (char *)v21);\n    for ( srcb = (size_t *)srca[1026]; srcb; srcb = (size_t *)srcb[1026] )\n      sub_401E1F(srcb, srcb[1024]);\n  }\n  while ( ptr )\n  {\n    srcc = (size_t *)ptr[1026];\n    free(ptr);\n    ptr = srcc;\n  }\n  return v11;\n}\n"], [4205401, "sub_402B59", "__int64 __fastcall sub_402B59(__int64 a1, unsigned int a2, size_t a3, _QWORD *a4)\n{\n  __int64 v4; // rax\n  __int64 v5; // r12\n  char *v6; // rbx\n  int *v7; // rax\n  unsigned __int8 v11; // [rsp+2Fh] [rbp-41h]\n  size_t *ptr; // [rsp+30h] [rbp-40h]\n  __int64 v13; // [rsp+38h] [rbp-38h]\n  size_t *src; // [rsp+40h] [rbp-30h]\n  size_t *srca; // [rsp+40h] [rbp-30h]\n  size_t *srcb; // [rsp+40h] [rbp-30h]\n  size_t *srcc; // [rsp+40h] [rbp-30h]\n  __int64 v18; // [rsp+48h] [rbp-28h]\n  unsigned __int64 v19; // [rsp+50h] [rbp-20h]\n  __int64 v20; // [rsp+58h] [rbp-18h]\n\n  v19 = 0LL;\n  v11 = 1;\n  v13 = sub_40B191(8208LL);\n  ptr = (size_t *)v13;\n  *(_QWORD *)(v13 + 0x2000) = 0LL;\n  *(_QWORD *)(v13 + 8200) = 0LL;\n  src = (size_t *)sub_40B191(8208LL);\n  while ( 1 )\n  {\n    v4 = sub_40A739(a2, src, 0x2000LL);\n    v20 = v4;\n    if ( !v4 || v4 == -1 )\n      break;\n    *a4 += v4;\n    src[1024] = v4;\n    src[1025] = 0LL;\n    v19 += src[1024];\n    if ( src[1024] + *(_QWORD *)(v13 + 0x2000) > 0x1FFF )\n    {\n      *(_QWORD *)(v13 + 8200) = src;\n      v13 = *(_QWORD *)(v13 + 8200);\n      if ( v19 - ptr[1024] <= a3 )\n      {\n        src = (size_t *)sub_40B191(8208LL);\n      }\n      else\n      {\n        src = ptr;\n        v19 -= ptr[1024];\n        ptr = (size_t *)ptr[1025];\n      }\n    }\n    else\n    {\n      memcpy((void *)(*(_QWORD *)(v13 + 0x2000) + v13), src, src[1024]);\n      *(_QWORD *)(v13 + 0x2000) += src[1024];\n    }\n  }\n  free(src);\n  if ( v20 == -1 )\n  {\n    v5 = sub_408FA1(a1);\n    v6 = gettext(\"error reading %s\");\n    v7 = __errno_location();\n    error(0, *v7, v6, v5);\n    v11 = 0;\n  }\n  else\n  {\n    for ( srca = ptr; v19 - srca[1024] > a3; srca = (size_t *)srca[1025] )\n      v19 -= srca[1024];\n    if ( v19 <= a3 )\n      v18 = 0LL;\n    else\n      v18 = v19 - a3;\n    sub_401E1F((char *)srca + v18, srca[1024] - v18);\n    for ( srcb = (size_t *)srca[1025]; srcb; srcb = (size_t *)srcb[1025] )\n      sub_401E1F(srcb, srcb[1024]);\n  }\n  while ( ptr )\n  {\n    srcc = (size_t *)ptr[1025];\n    free(ptr);\n    ptr = srcc;\n  }\n  return v11;\n}\n"], [4206205, "sub_402E7D", "__int64 __fastcall sub_402E7D(__int64 a1, unsigned int a2, unsigned __int64 a3, _QWORD *a4)\n{\n  __int64 v5; // r12\n  char *v6; // rbx\n  int *v7; // rax\n  unsigned __int64 v10; // [rsp+20h] [rbp-2030h]\n  char v11[8200]; // [rsp+30h] [rbp-2020h] BYREF\n  unsigned __int64 v12; // [rsp+2038h] [rbp-18h]\n\n  v12 = __readfsqword(0x28u);\n  while ( a3 )\n  {\n    v10 = sub_40A739(a2, v11, 0x2000LL);\n    if ( !v10 )\n      return 0xFFFFFFFFLL;\n    if ( v10 == -1LL )\n    {\n      v5 = sub_408FA1(a1);\n      v6 = gettext(\"error reading %s\");\n      v7 = __errno_location();\n      error(0, *v7, v6, v5);\n      return 1LL;\n    }\n    *a4 += v10;\n    if ( v10 > a3 )\n    {\n      if ( v10 != a3 )\n        sub_401E1F(&v11[a3], v10 - a3);\n      return 0LL;\n    }\n    a3 -= v10;\n  }\n  return 0LL;\n}\n"], [4206591, "sub_402FFF", "__int64 __fastcall sub_402FFF(__int64 a1, unsigned int a2, __int64 a3, _QWORD *a4)\n{\n  __int64 v5; // r12\n  char *v6; // rbx\n  int *v7; // rax\n  __int64 v9; // [rsp+8h] [rbp-2058h]\n  char *s; // [rsp+28h] [rbp-2038h]\n  char *sa; // [rsp+28h] [rbp-2038h]\n  __int64 v12; // [rsp+30h] [rbp-2030h]\n  char *v13; // [rsp+38h] [rbp-2028h]\n  char v14[8200]; // [rsp+40h] [rbp-2020h] BYREF\n  unsigned __int64 v15; // [rsp+2048h] [rbp-18h]\n\n  v9 = a3;\n  v15 = __readfsqword(0x28u);\n  if ( !a3 )\n    return 0LL;\n  while ( 1 )\n  {\n    s = v14;\n    v12 = sub_40A739(a2, v14, 0x2000LL);\n    v13 = &v14[v12];\n    if ( !v12 )\n      return 0xFFFFFFFFLL;\n    if ( v12 == -1 )\n      break;\n    *a4 += v12;\n    while ( 1 )\n    {\n      sa = (char *)memchr(s, 10, v13 - s);\n      if ( !sa )\n        break;\n      s = sa + 1;\n      if ( !--v9 )\n      {\n        if ( s < v13 )\n          sub_401E1F(s, v13 - s);\n        return 0LL;\n      }\n    }\n  }\n  v5 = sub_408FA1(a1);\n  v6 = gettext(\"error reading %s\");\n  v7 = __errno_location();\n  error(0, *v7, v6, v5);\n  return 1LL;\n}\n"], [4207064, "sub_4031D8", "__int64 __fastcall sub_4031D8(int a1, __int64 a2)\n{\n  __int64 v2; // r12\n  char *v3; // rbx\n  int *v4; // rax\n  unsigned __int8 v6; // [rsp+1Bh] [rbp-95h]\n  struct statfs buf; // [rsp+20h] [rbp-90h] BYREF\n\n  v6 = 1;\n  if ( !fstatfs(a1, &buf) )\n  {\n    if ( buf.f_type == 1702057283 )\n      return v6;\n    if ( buf.f_type > 1702057283 )\n    {\n      if ( buf.f_type == 1852207972 )\n        return v6;\n      if ( buf.f_type > 1852207972 )\n      {\n        if ( buf.f_type == 1952539503 || buf.f_type == 4283649346LL || buf.f_type == 1937076805 )\n          return v6;\n      }\n      else if ( buf.f_type == 1702057286 || buf.f_type == 1799439955 )\n      {\n        return v6;\n      }\n    }\n    else\n    {\n      if ( buf.f_type == 26985 )\n        return v6;\n      if ( buf.f_type > 26985 )\n      {\n        if ( buf.f_type == 198183888 || buf.f_type == 1397113167 || buf.f_type == 18225520 )\n          return v6;\n      }\n      else if ( buf.f_type == 20859 || buf.f_type == 22092 )\n      {\n        return v6;\n      }\n    }\n    return 0;\n  }\n  if ( *__errno_location() != 38 )\n  {\n    v2 = sub_408FA1(a2);\n    v3 = gettext(\"cannot determine location of %s. reverting to polling\");\n    v4 = __errno_location();\n    error(0, *v4, v3, v2);\n  }\n  return v6;\n}\n"], [4207394, "sub_403322", "void __fastcall sub_403322(__int64 a1, unsigned __int8 a2)\n{\n  int v2; // eax\n  int v3; // ecx\n  int v4; // er8\n  int v5; // er9\n  int v6; // eax\n  int v7; // eax\n  bool v8; // al\n  char *v9; // rax\n  __int64 v10; // rbx\n  char *v11; // rax\n  char *v12; // rbx\n  int *v13; // rax\n  char *v14; // rax\n  __int64 v15; // rbx\n  char *v16; // rax\n  char *v17; // rax\n  char *v18; // rax\n  __int64 v19; // rbx\n  char *v20; // rax\n  char *v21; // rax\n  char *v22; // rax\n  char *v23; // rax\n  __int64 v24; // rbx\n  char *v25; // rax\n  char *v26; // rax\n  __int64 v27; // rbx\n  char *v28; // rax\n  char *v29; // rax\n  char *v30; // rax\n  char *v31; // rax\n  int v32; // eax\n  char *v33; // rax\n  char v34; // [rsp+14h] [rbp-ACh]\n  char v35; // [rsp+15h] [rbp-ABh]\n  bool v36; // [rsp+16h] [rbp-AAh]\n  char v37; // [rsp+17h] [rbp-A9h]\n  int v38; // [rsp+18h] [rbp-A8h]\n  int fildes; // [rsp+1Ch] [rbp-A4h]\n  struct stat stat_buf; // [rsp+20h] [rbp-A0h] BYREF\n\n  v34 = 1;\n  v2 = strcmp(*(const char **)a1, \"-\");\n  v36 = v2 == 0;\n  v37 = *(_BYTE *)(a1 + 54);\n  v38 = *(_DWORD *)(a1 + 60);\n  if ( v2 )\n  {\n    if ( a2 )\n      v7 = 0;\n    else\n      v7 = 2048;\n    v6 = sub_40732E(*(_QWORD *)a1, v7, *(_QWORD *)a1, v3, v4, v5);\n  }\n  else\n  {\n    v6 = 0;\n  }\n  fildes = v6;\n  if ( !sub_401DB6(a1) )\n    __assert_fail(\"valid_file_spec (f)\", \"../../src/src/tail.c\", 0x3B1u, \"recheck\");\n  v8 = byte_61031C != 1 || fildes != -1;\n  *(_BYTE *)(a1 + 54) = v8;\n  if ( fildes == -1 || (int)sub_40C6D0(fildes, &stat_buf) < 0 )\n  {\n    v34 = 0;\n    *(_DWORD *)(a1 + 60) = *__errno_location();\n    if ( *(_BYTE *)(a1 + 54) != 1 )\n    {\n      if ( v37 )\n      {\n        v9 = sub_401DE6((const char **)a1);\n        v10 = sub_408FA1(v9);\n        v11 = gettext(\"%s has become inaccessible\");\n        error(0, *(_DWORD *)(a1 + 60), v11, v10);\n      }\n    }\n    else if ( *__errno_location() != v38 )\n    {\n      v12 = sub_401DE6((const char **)a1);\n      v13 = __errno_location();\n      error(0, *v13, \"%s\", v12);\n    }\n  }\n  else if ( (stat_buf.st_mode & 0xF000) == 0x8000\n         || (stat_buf.st_mode & 0xF000) == 4096\n         || (stat_buf.st_mode & 0xF000) == 49152\n         || (stat_buf.st_mode & 0xF000) == 0x2000 )\n  {\n    if ( byte_61032A != 1 && (v17 = sub_401DE6((const char **)a1), (unsigned __int8)sub_4031D8(fildes, (__int64)v17)) )\n    {\n      v34 = 0;\n      *(_DWORD *)(a1 + 60) = -1;\n      v18 = sub_401DE6((const char **)a1);\n      v19 = sub_408FA1(v18);\n      v20 = gettext(\"%s has been replaced with a remote file. giving up on this name\");\n      error(0, 0, v20, v19);\n      *(_BYTE *)(a1 + 52) = 1;\n      *(_BYTE *)(a1 + 53) = 1;\n    }\n    else\n    {\n      *(_DWORD *)(a1 + 60) = 0;\n    }\n  }\n  else\n  {\n    v34 = 0;\n    *(_DWORD *)(a1 + 60) = -1;\n    v14 = sub_401DE6((const char **)a1);\n    v15 = sub_408FA1(v14);\n    v16 = gettext(\"%s has been replaced with an untailable file; giving up on this name\");\n    error(0, 0, v16, v15);\n    *(_BYTE *)(a1 + 52) = 1;\n  }\n  v35 = 0;\n  if ( v34 != 1 )\n  {\n    v21 = sub_401DE6((const char **)a1);\n    sub_401F23(fildes, (__int64)v21);\n    v22 = sub_401DE6((const char **)a1);\n    sub_401F23(*(_DWORD *)(a1 + 56), (__int64)v22);\n    *(_DWORD *)(a1 + 56) = -1;\n  }\n  else if ( !v38 || v38 == 2 )\n  {\n    if ( *(_QWORD *)(a1 + 40) == stat_buf.st_ino && *(_QWORD *)(a1 + 32) == stat_buf.st_dev )\n    {\n      if ( *(_DWORD *)(a1 + 56) == -1 )\n      {\n        v35 = 1;\n      }\n      else\n      {\n        v31 = sub_401DE6((const char **)a1);\n        sub_401F23(fildes, (__int64)v31);\n      }\n    }\n    else\n    {\n      v35 = 1;\n      if ( *(_DWORD *)(a1 + 56) == -1 )\n      {\n        v26 = sub_401DE6((const char **)a1);\n        v27 = sub_408FA1(v26);\n        v28 = gettext(\"%s has appeared;  following end of new file\");\n      }\n      else\n      {\n        v29 = sub_401DE6((const char **)a1);\n        sub_401F23(*(_DWORD *)(a1 + 56), (__int64)v29);\n        v30 = sub_401DE6((const char **)a1);\n        v27 = sub_408FA1(v30);\n        v28 = gettext(\"%s has been replaced;  following end of new file\");\n      }\n      error(0, 0, v28, v27);\n    }\n  }\n  else\n  {\n    v35 = 1;\n    if ( *(_DWORD *)(a1 + 56) != -1 )\n      __assert_fail(\"f->fd == -1\", \"../../src/src/tail.c\", 0x3F1u, \"recheck\");\n    v23 = sub_401DE6((const char **)a1);\n    v24 = sub_408FA1(v23);\n    v25 = gettext(\"%s has become accessible\");\n    error(0, 0, v25, v24);\n  }\n  if ( v35 )\n  {\n    if ( v36 )\n      v32 = -1;\n    else\n      v32 = a2;\n    sub_401E87(a1, fildes, 0LL, (__int64)&stat_buf, v32);\n    v33 = sub_401DE6((const char **)a1);\n    sub_40213B(fildes, 0LL, 0, (__int64)v33);\n  }\n}\n"], [4208917, "sub_403915", "__int64 __fastcall sub_403915(__int64 a1, unsigned __int64 a2)\n{\n  unsigned __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 0LL; i < a2; ++i )\n  {\n    if ( *(int *)(96 * i + a1 + 56) >= 0 )\n      return 1LL;\n  }\n  return 0LL;\n}\n"], [4209002, "sub_40396A", "void __fastcall sub_40396A(__int64 a1, unsigned __int64 a2, double a3)\n{\n  bool v3; // al\n  int v4; // ecx\n  int v5; // er8\n  int v6; // er9\n  int v7; // edx\n  int v8; // ecx\n  int v9; // er8\n  int v10; // er9\n  int v11; // eax\n  char *v12; // rbx\n  int *v13; // rax\n  int *v14; // rax\n  __int64 v15; // rax\n  int v16; // edx\n  __int64 v17; // rdx\n  unsigned __int64 v18; // rax\n  __int64 v19; // rbx\n  __int64 v20; // rdx\n  char *v21; // rax\n  unsigned __int64 v22; // rax\n  char *v23; // rax\n  char *v24; // rbx\n  int *v25; // rax\n  bool v26; // al\n  char *v27; // rbx\n  int *v28; // rax\n  char v29; // [rsp+0h] [rbp-100h]\n  bool v30; // [rsp+2Dh] [rbp-D3h]\n  bool v31; // [rsp+2Eh] [rbp-D2h]\n  unsigned __int8 v32; // [rsp+2Fh] [rbp-D1h]\n  int fildes; // [rsp+30h] [rbp-D0h]\n  int v34; // [rsp+34h] [rbp-CCh]\n  int v35; // [rsp+38h] [rbp-C8h]\n  int v36; // [rsp+3Ch] [rbp-C4h]\n  unsigned __int64 v37; // [rsp+40h] [rbp-C0h]\n  unsigned __int64 i; // [rsp+48h] [rbp-B8h]\n  char *v39; // [rsp+50h] [rbp-B0h]\n  __int64 v40; // [rsp+58h] [rbp-A8h]\n  struct stat stat_buf; // [rsp+60h] [rbp-A0h] BYREF\n\n  v3 = !pid && dword_610250 == 2 && a2 == 1 && (*(_DWORD *)(a1 + 48) & 0xF000) != 0x8000;\n  v32 = v3;\n  v30 = 0;\n  v37 = a2 - 1;\n  do\n  {\nLABEL_8:\n    v31 = 0;\n    for ( i = 0LL; i < a2; ++i )\n    {\n      if ( *(_BYTE *)(96 * i + a1 + 52) )\n        continue;\n      if ( *(int *)(96 * i + a1 + 56) < 0 )\n      {\n        sub_403322(96 * i + a1, v32);\n        continue;\n      }\n      fildes = *(_DWORD *)(96 * i + a1 + 56);\n      v39 = sub_401DE6((const char **)(96 * i + a1));\n      v34 = *(_DWORD *)(96 * i + a1 + 48);\n      v7 = *(_DWORD *)(96 * i + a1 + 64);\n      if ( v7 != v32 )\n      {\n        v35 = sub_40BE84(fildes, 3, v7, v4, v5, v6, v29);\n        if ( v32 )\n          v11 = 0;\n        else\n          v11 = 2048;\n        v36 = v35 | v11;\n        if ( v35 >= 0 && (v36 == v35 || (unsigned int)sub_40BE84(fildes, 4, v36, v8, v9, v10, v29) != -1) )\n        {\n          *(_DWORD *)(a1 + 96 * i + 64) = v32;\n        }\n        else if ( (*(_DWORD *)(96 * i + a1 + 48) & 0xF000) != 0x8000 || *__errno_location() != 1 )\n        {\n          v12 = gettext(\"%s: cannot change nonblocking mode\");\n          v13 = __errno_location();\n          error(1, *v13, v12, v39);\n        }\n      }\n      if ( *(_DWORD *)(96 * i + a1 + 64) )\n        goto LABEL_41;\n      if ( (unsigned int)sub_40C6D0(fildes, &stat_buf) )\n      {\n        *(_DWORD *)(96 * i + a1 + 56) = -1;\n        *(_DWORD *)(96 * i + a1 + 60) = *__errno_location();\n        v14 = __errno_location();\n        error(0, *v14, \"%s\", v39);\n        continue;\n      }\n      if ( *(_DWORD *)(96 * i + a1 + 48) != stat_buf.st_mode\n        || (stat_buf.st_mode & 0xF000) == 0x8000 && *(_QWORD *)(96 * i + a1 + 8) != stat_buf.st_size\n        || (v15 = sub_401BF2((__int64)&stat_buf),\n            (unsigned int)sub_401A8D(*(_QWORD *)(96 * i + a1 + 16), *(_QWORD *)(96 * i + a1 + 24), v15, v16)) )\n      {\n        v19 = 96 * i + a1;\n        *(_QWORD *)(v19 + 16) = sub_401BF2((__int64)&stat_buf);\n        *(_QWORD *)(v19 + 24) = v20;\n        *(_DWORD *)(v19 + 48) = stat_buf.st_mode;\n        *(_QWORD *)(v19 + 88) = 0LL;\n        if ( (v34 & 0xF000) == 0x8000 && stat_buf.st_size < *(_QWORD *)(96 * i + a1 + 8) )\n        {\n          v21 = gettext(\"%s: file truncated\");\n          error(0, 0, v21, v39);\n          v37 = i;\n          sub_40213B(fildes, stat_buf.st_size, 0, (__int64)v39);\n          *(_QWORD *)(a1 + 96 * i + 8) = stat_buf.st_size;\n          continue;\n        }\n        if ( i != v37 )\n        {\n          if ( byte_610320 )\n            sub_401F89(v39);\n          v37 = i;\n        }\nLABEL_41:\n        if ( *(_DWORD *)(96 * i + a1 + 64) )\n          v22 = -2LL;\n        else\n          v22 = -1LL;\n        v40 = sub_401FCB((__int64)v39, fildes, v22);\n        v31 = v31 || v40 != 0;\n        *(_QWORD *)(96 * i + a1 + 8) += v40;\n        continue;\n      }\n      v17 = a1 + 96 * i;\n      v18 = *(_QWORD *)(v17 + 88);\n      *(_QWORD *)(v17 + 88) = v18 + 1;\n      if ( v18 >= qword_610258 && dword_610250 == 1 )\n      {\n        sub_403322(96 * i + a1, *(_DWORD *)(96 * i + a1 + 64) != 0);\n        *(_QWORD *)(96 * i + a1 + 88) = 0LL;\n      }\n    }\n    if ( (unsigned __int8)sub_403915(a1, a2) != 1 && byte_61031C != 1 )\n    {\n      v23 = gettext(\"no files remaining\");\n      error(0, 0, v23);\n      return;\n    }\n    if ( (!v31 || v32) && fflush_unlocked(stdout) )\n    {\n      v24 = gettext(\"write error\");\n      v25 = __errno_location();\n      error(1, *v25, v24);\n    }\n  }\n  while ( v31 );\n  if ( !v30 )\n  {\n    v26 = pid && kill(pid, 0) && *__errno_location() != 1;\n    v30 = v26;\n    if ( !v26 )\n    {\n      v29 = LOBYTE(a3);\n      if ( (unsigned int)sub_40B348(a3) )\n      {\n        v27 = gettext(\"cannot read realtime clock\");\n        v28 = __errno_location();\n        error(1, *v28, v27);\n      }\n    }\n    goto LABEL_8;\n  }\n}\n"], [4211395, "sub_4042C3", "__int64 __fastcall sub_4042C3(__int64 a1, unsigned __int64 a2)\n{\n  unsigned __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 0LL; i < a2; ++i )\n  {\n    if ( *(int *)(96 * i + a1 + 56) >= 0 && *(_BYTE *)(96 * i + a1 + 53) )\n      return 1LL;\n  }\n  return 0LL;\n}\n"], [4211515, "sub_40433B", "__int64 __fastcall sub_40433B(__int64 a1, unsigned __int64 a2)\n{\n  unsigned __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 0LL; i < a2; ++i )\n  {\n    if ( *(_BYTE *)(96 * i + a1 + 52) != 1 && !strcmp(*(const char **)(96 * i + a1), \"-\") )\n      return 1LL;\n  }\n  return 0LL;\n}\n"], [4211655, "sub_4043C7", "unsigned __int64 __fastcall sub_4043C7(__int64 a1, unsigned __int64 a2)\n{\n  return *(int *)(a1 + 68) % a2;\n}\n"], [4211698, "sub_4043F2", "bool __fastcall sub_4043F2(__int64 a1, __int64 a2)\n{\n  return *(_DWORD *)(a1 + 68) == *(_DWORD *)(a2 + 68);\n}\n"], [4211747, "sub_404423", "void __fastcall sub_404423(__int64 a1, int a2, _DWORD *a3)\n{\n  char *v3; // rax\n  __int64 v4; // rax\n  int v5; // edx\n  char *v6; // rbx\n  int *v7; // rax\n  char *v9; // [rsp+20h] [rbp-B0h]\n  struct stat stat_buf; // [rsp+30h] [rbp-A0h] BYREF\n\n  v9 = sub_401DE6((const char **)a1);\n  if ( (unsigned int)sub_40C6D0(*(_DWORD *)(a1 + 56), &stat_buf) )\n  {\n    sub_401F23(*(_DWORD *)(a1 + 56), (__int64)v9);\n    *(_DWORD *)(a1 + 56) = -1;\n    *(_DWORD *)(a1 + 60) = *__errno_location();\n    return;\n  }\n  if ( (*(_DWORD *)(a1 + 48) & 0xF000) == 0x8000 && stat_buf.st_size < *(_QWORD *)(a1 + 8) )\n  {\n    v3 = gettext(\"%s: file truncated\");\n    error(0, 0, v3, v9);\n    *a3 = a2;\n    sub_40213B(*(_DWORD *)(a1 + 56), stat_buf.st_size, 0, (__int64)v9);\n    *(_QWORD *)(a1 + 8) = stat_buf.st_size;\n  }\n  else if ( (*(_DWORD *)(a1 + 48) & 0xF000) == 0x8000 && stat_buf.st_size == *(_QWORD *)(a1 + 8) )\n  {\n    v4 = sub_401BF2((__int64)&stat_buf);\n    if ( !(unsigned int)sub_401A8D(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), v4, v5) )\n      return;\n  }\n  if ( *a3 != a2 )\n  {\n    if ( byte_610320 )\n      sub_401F89(v9);\n    *a3 = a2;\n  }\n  *(_QWORD *)(a1 + 8) += sub_401FCB((__int64)v9, *(_DWORD *)(a1 + 56), 0xFFFFFFFFFFFFFFFFLL);\n  if ( fflush_unlocked(stdout) )\n  {\n    v6 = gettext(\"write error\");\n    v7 = __errno_location();\n    error(1, *v7, v6);\n  }\n}\n"], [4212350, "sub_40467E", "__int64 __fastcall sub_40467E(int a1, __int64 a2, unsigned __int64 a3, double a4)\n{\n  const char *v4; // rax\n  __int64 v5; // r12\n  char *v6; // rbx\n  int *v7; // rax\n  char *v8; // rax\n  char *v9; // rax\n  __int64 v10; // r12\n  char *v11; // rbx\n  int *v12; // rax\n  char *v14; // rax\n  bool v15; // al\n  char *v16; // rbx\n  int *v17; // rax\n  int v18; // eax\n  char *v19; // rbx\n  int *v20; // rax\n  __int64 v21; // r12\n  char *v22; // rbx\n  int *v23; // rax\n  char *v24; // rax\n  char v26; // [rsp+23h] [rbp-11Dh]\n  char v27; // [rsp+24h] [rbp-11Ch]\n  char v28; // [rsp+25h] [rbp-11Bh]\n  bool v29; // [rsp+26h] [rbp-11Ah]\n  char v30; // [rsp+27h] [rbp-119h]\n  int v31; // [rsp+28h] [rbp-118h] BYREF\n  int v32; // [rsp+2Ch] [rbp-114h]\n  int v33; // [rsp+30h] [rbp-110h]\n  unsigned int v34; // [rsp+34h] [rbp-10Ch]\n  int v35; // [rsp+38h] [rbp-108h]\n  int v36; // [rsp+3Ch] [rbp-104h]\n  unsigned __int64 v37; // [rsp+40h] [rbp-100h]\n  __int64 v38; // [rsp+48h] [rbp-F8h]\n  unsigned __int64 v39; // [rsp+50h] [rbp-F0h]\n  unsigned __int64 v40; // [rsp+58h] [rbp-E8h]\n  unsigned __int64 i; // [rsp+60h] [rbp-E0h]\n  __int64 v42; // [rsp+68h] [rbp-D8h]\n  unsigned __int64 j; // [rsp+70h] [rbp-D0h]\n  __int64 v44; // [rsp+78h] [rbp-C8h]\n  size_t v45; // [rsp+80h] [rbp-C0h]\n  __int64 v46; // [rsp+88h] [rbp-B8h]\n  __int64 v47; // [rsp+90h] [rbp-B0h]\n  const char **v48; // [rsp+98h] [rbp-A8h]\n  struct timeval timeout; // [rsp+A0h] [rbp-A0h] BYREF\n  fd_set readfds; // [rsp+B0h] [rbp-90h] BYREF\n  __int64 v51; // [rsp+130h] [rbp-10h] BYREF\n\n  v32 = 3;\n  v26 = 0;\n  v27 = 0;\n  v28 = 0;\n  v29 = 0;\n  v37 = 0LL;\n  v39 = 0LL;\n  v40 = 0LL;\n  v44 = sub_407D52(a3, 0LL, sub_4043C7, sub_4043F2, 0LL);\n  if ( !v44 )\n    sub_40B313();\n  for ( i = 0LL; i < a3; ++i )\n  {\n    if ( *(_BYTE *)(96 * i + a2 + 52) != 1 )\n    {\n      v45 = strlen(*(const char **)(96 * i + a2));\n      if ( v37 < v45 )\n        v37 = v45;\n      *(_DWORD *)(96 * i + a2 + 68) = -1;\n      if ( dword_610250 == 1 )\n      {\n        v46 = sub_407157(*(_QWORD *)(96 * i + a2));\n        v30 = *(_BYTE *)(*(_QWORD *)(96 * i + a2) + v46);\n        *(_QWORD *)(96 * i + a2 + 80) = sub_407277(*(_QWORD *)(96 * i + a2)) - *(_QWORD *)(96 * i + a2);\n        *(_BYTE *)(*(_QWORD *)(96 * i + a2) + v46) = 0;\n        v4 = v46 ? *(_QWORD *)(96 * i + a2) : \".\";\n        *(_DWORD *)(96 * i + a2 + 72) = inotify_add_watch(a1, v4, 0x184u);\n        *(_BYTE *)(v46 + *(_QWORD *)(96 * i + a2)) = v30;\n        if ( *(int *)(96 * i + a2 + 72) < 0 )\n        {\n          if ( *__errno_location() == 28 )\n          {\n            v8 = gettext(\"inotify resources exhausted\");\n            error(0, 0, v8);\n          }\n          else\n          {\n            v5 = sub_408FA1(*(_QWORD *)(96 * i + a2));\n            v6 = gettext(\"cannot watch parent directory of %s\");\n            v7 = __errno_location();\n            error(0, *v7, v6, v5);\n          }\n          v27 = 1;\n          break;\n        }\n      }\n      *(_DWORD *)(96 * i + a2 + 68) = inotify_add_watch(a1, *(const char **)(96 * i + a2), 0xC06u);\n      if ( *(int *)(96 * i + a2 + 68) >= 0 )\n      {\n        if ( !sub_4089E8(v44, a2 + 96 * i) )\n          sub_40B313();\n        v26 = 1;\n      }\n      else if ( *__errno_location() == 28 )\n      {\n        v28 = 1;\n        v9 = gettext(\"inotify resources exhausted\");\n        error(0, 0, v9);\n      }\n      else if ( *__errno_location() != *(_DWORD *)(96 * i + a2 + 60) )\n      {\n        v10 = sub_408FA1(*(_QWORD *)(96 * i + a2));\n        v11 = gettext(\"cannot watch %s\");\n        v12 = __errno_location();\n        error(0, *v12, v11, v10);\n      }\n    }\n  }\n  if ( v28 || v27 )\n  {\n    *__errno_location() = 0;\n    return 1LL;\n  }\n  if ( dword_610250 == 2 && v26 != 1 )\n    return 0LL;\n  v31 = *(_DWORD *)(96 * a3 - 96 + a2 + 68);\n  for ( i = 0LL; i < a3; ++i )\n  {\n    if ( *(_BYTE *)(96 * i + a2 + 52) != 1 )\n      sub_404423(96 * i + a2, *(_DWORD *)(96 * i + a2 + 68), &v31);\n  }\n  v37 += 17LL;\n  v38 = sub_40B191(v37);\n  while ( dword_610250 != 1 || byte_61031C == 1 || sub_407480(v44) )\n  {\n    if ( !pid )\n      goto LABEL_56;\n    if ( v29 )\n      exit(0);\n    v15 = kill(pid, 0) && *__errno_location() != 1;\n    v29 = v15;\n    if ( v15 )\n    {\n      timeout.tv_usec = 0LL;\n      timeout.tv_sec = 0LL;\n    }\n    else\n    {\n      timeout.tv_sec = (unsigned int)(int)a4;\n      timeout.tv_usec = (unsigned int)(int)((a4 - (double)(int)a4) * 1000000.0);\n    }\n    memset(&readfds, 0, sizeof(readfds));\n    v33 = 0;\n    v34 = (unsigned int)&v51;\n    readfds.fds_bits[a1 / 64] |= 1LL << (a1 % 64);\n    v35 = select(a1 + 1, &readfds, 0LL, 0LL, &timeout);\n    if ( v35 )\n    {\n      if ( v35 == -1 )\n      {\n        v16 = gettext(\"error monitoring inotify event\");\n        v17 = __errno_location();\n        error(1, *v17, v16);\n      }\nLABEL_56:\n      if ( v40 > v39 )\n        goto LABEL_65;\n      v40 = sub_40A739((unsigned int)a1, v38, v37);\n      v39 = 0LL;\n      if ( (!v40 || v40 == -1LL && *__errno_location() == 22) && (v18 = v32, --v32, v18) )\n      {\n        v40 = 0LL;\n        v37 *= 2LL;\n        v38 = sub_40B1C6(v38, v37);\n      }\n      else\n      {\n        if ( !v40 || v40 == -1LL )\n        {\n          v19 = gettext(\"error reading inotify event\");\n          v20 = __errno_location();\n          error(1, *v20, v19);\n        }\nLABEL_65:\n        v47 = v38 + v39;\n        v39 += *(unsigned int *)(v38 + v39 + 12) + 16LL;\n        if ( !*(_DWORD *)(v47 + 12) )\n        {\n          HIDWORD(readfds.fds_bits[8]) = *(_DWORD *)v47;\n          v42 = sub_407719(v44, &readfds);\n          goto LABEL_85;\n        }\n        for ( j = 0LL;\n              j < a3\n           && (*(_DWORD *)(96 * j + a2 + 72) != *(_DWORD *)v47\n            || strcmp(\n                 (const char *)(v47 + 16),\n                 (const char *)(*(_QWORD *)(96 * j + a2) + *(_QWORD *)(96 * j + a2 + 80))));\n              ++j )\n        {\n          ;\n        }\n        if ( j != a3 )\n        {\n          v36 = inotify_add_watch(a1, *(const char **)(96 * j + a2), 0xC06u);\n          if ( v36 >= 0 )\n          {\n            v42 = 96 * j + a2;\n            sub_408A31(v44, v42);\n            *(_DWORD *)(v42 + 68) = v36;\n            v48 = (const char **)sub_408A31(v44, v42);\n            if ( v48 && v48 != (const char **)v42 )\n            {\n              if ( dword_610250 == 1 )\n                sub_403322((__int64)v48, 0);\n              *((_DWORD *)v48 + 17) = -1;\n              v24 = sub_401DE6(v48);\n              sub_401F23(*((_DWORD *)v48 + 14), (__int64)v24);\n            }\n            if ( !sub_4089E8(v44, v42) )\n              sub_40B313();\n            if ( dword_610250 == 1 )\n              sub_403322(v42, 0);\nLABEL_85:\n            if ( v42 )\n            {\n              if ( (*(_DWORD *)(v47 + 4) & 0xC04) != 0 )\n              {\n                if ( (*(_DWORD *)(v47 + 4) & 0x400) != 0 || (*(_DWORD *)(v47 + 4) & 0x800) != 0 && dword_610250 == 2 )\n                {\n                  inotify_rm_watch(a1, *(_DWORD *)(v42 + 68));\n                  sub_408A31(v44, v42);\n                }\n                if ( dword_610250 == 1 )\n                  sub_403322(v42, 0);\n              }\n              else\n              {\n                sub_404423(v42, *(_DWORD *)v47, &v31);\n              }\n            }\n          }\n          else\n          {\n            v21 = sub_408FA1(*(_QWORD *)(96 * j + a2));\n            v22 = gettext(\"cannot watch %s\");\n            v23 = __errno_location();\n            error(0, *v23, v22, v21);\n          }\n        }\n      }\n    }\n  }\n  v14 = gettext(\"no files remaining\");\n  error(0, 0, v14);\n  return 0LL;\n}\n"], [4215897, "sub_405459", "__int64 __fastcall sub_405459(__int64 a1, unsigned int a2, __int64 a3, __off_t *a4)\n{\n  __int64 v4; // r12\n  char *v5; // rbx\n  int *v6; // rax\n  __off_t v8; // rbx\n  __int64 v9; // rax\n  __off_t v10; // rdx\n  __off_t v11; // rbx\n  unsigned int v14; // [rsp+24h] [rbp-CCh]\n  __off_t v15; // [rsp+28h] [rbp-C8h]\n  __int64 v16; // [rsp+38h] [rbp-B8h]\n  struct stat stat_buf; // [rsp+50h] [rbp-A0h] BYREF\n\n  if ( (unsigned int)sub_40C6D0(a2, &stat_buf) )\n  {\n    v4 = sub_408FA1(a1);\n    v5 = gettext(\"cannot fstat %s\");\n    v6 = __errno_location();\n    error(0, *v6, v5, v4);\n    return 0LL;\n  }\n  if ( byte_61031F )\n  {\n    if ( byte_610329 != 1 && (stat_buf.st_mode & 0xF000) == 0x8000 && a3 >= 0 )\n    {\n      sub_40213B(a2, a3, 1, a1);\n      *a4 += a3;\n    }\n    else\n    {\n      v14 = sub_402E7D(a1, a2, a3, a4);\n      if ( v14 )\n        return v14 >> 31;\n    }\n    v8 = *a4;\n    *a4 = v8 + sub_401FCB(a1, a2, 0xFFFFFFFFFFFFFFFFLL);\n  }\n  else\n  {\n    if ( byte_610329 == 1 || (stat_buf.st_mode & 0xF000) != 0x8000 || a3 < 0 )\n      return sub_402B59(a1, a2, a3, a4);\n    v15 = sub_40213B(a2, 0LL, 1, a1);\n    v16 = sub_40213B(a2, 0LL, 2, a1) - v15;\n    v9 = 0LL;\n    if ( v16 >= 0 )\n      v9 = v16;\n    if ( v9 > a3 )\n      v10 = sub_40213B(a2, -a3, 2, a1);\n    else\n      v10 = sub_40213B(a2, v15, 0, a1);\n    *a4 = v10;\n    v11 = *a4;\n    *a4 = v11 + sub_401FCB(a1, a2, a3);\n  }\n  return 1LL;\n}\n"], [4216720, "sub_405790", "__int64 __fastcall sub_405790(__int64 a1, unsigned int a2, size_t a3, signed __int64 *a4)\n{\n  __int64 v4; // r12\n  char *v5; // rbx\n  int *v6; // rax\n  __int64 v8; // rbx\n  unsigned int v11; // [rsp+2Ch] [rbp-B4h]\n  __off_t v12; // [rsp+30h] [rbp-B0h]\n  signed __int64 v13; // [rsp+38h] [rbp-A8h]\n  struct stat stat_buf; // [rsp+40h] [rbp-A0h] BYREF\n\n  if ( (unsigned int)sub_40C6D0(a2, &stat_buf) )\n  {\n    v4 = sub_408FA1(a1);\n    v5 = gettext(\"cannot fstat %s\");\n    v6 = __errno_location();\n    error(0, *v6, v5, v4);\n    return 0LL;\n  }\n  if ( byte_61031F )\n  {\n    v11 = sub_402FFF(a1, a2, a3, a4);\n    if ( v11 )\n      return v11 >> 31;\n    v8 = *a4;\n    *a4 = v8 + sub_401FCB(a1, a2, 0xFFFFFFFFFFFFFFFFLL);\n    return 1LL;\n  }\n  v12 = -1LL;\n  if ( byte_610329 != 1 && (stat_buf.st_mode & 0xF000) == 0x8000 )\n  {\n    v12 = lseek(a2, 0LL, 1);\n    if ( v12 != -1 )\n    {\n      v13 = lseek(a2, 0LL, 2);\n      if ( v13 > v12 )\n      {\n        *a4 = v13;\n        return !v13 || (unsigned __int8)sub_40228B(a1, a2, a3, v12, v13, a4) == 1;\n      }\n    }\n  }\n  if ( v12 != -1 )\n    sub_40213B(a2, v12, 0, a1);\n  return sub_4026A9(a1, a2, a3, a4);\n}\n"], [4217331, "sub_4059F3", "__int64 __fastcall sub_4059F3(__int64 a1, unsigned int a2, size_t a3, signed __int64 *a4)\n{\n  __int64 result; // rax\n\n  *a4 = 0LL;\n  if ( byte_61031D )\n    result = sub_405790(a1, a2, a3, a4);\n  else\n    result = sub_405459(a1, a2, a3, a4);\n  return result;\n}\n"], [4217426, "sub_405A52", "__int64 __fastcall sub_405A52(__int64 a1, size_t a2)\n{\n  int v2; // eax\n  int v3; // edx\n  int v4; // ecx\n  int v5; // er8\n  int v6; // er9\n  bool v7; // al\n  char *v8; // rax\n  __int64 v9; // r12\n  char *v10; // rbx\n  int *v11; // rax\n  char *v12; // rax\n  char *v13; // rax\n  char *v14; // rax\n  __int64 v15; // r12\n  char *v16; // rbx\n  int *v17; // rax\n  char *v18; // rbx\n  char *v19; // rax\n  char *v20; // rax\n  int v21; // eax\n  char *v22; // rax\n  char *v23; // rax\n  __int64 v24; // r12\n  char *v25; // rbx\n  int *v26; // rax\n  unsigned __int8 v28; // [rsp+12h] [rbp-AEh]\n  bool v29; // [rsp+13h] [rbp-ADh]\n  int fd; // [rsp+14h] [rbp-ACh]\n  signed __int64 v31; // [rsp+18h] [rbp-A8h] BYREF\n  struct stat stat_buf; // [rsp+20h] [rbp-A0h] BYREF\n\n  v2 = strcmp(*(const char **)a1, \"-\");\n  v29 = v2 == 0;\n  if ( v2 )\n  {\n    fd = sub_40732E(*(_QWORD *)a1, 0, v3, v4, v5, v6);\n  }\n  else\n  {\n    byte_610328 = 1;\n    fd = 0;\n  }\n  v7 = byte_61031C != 1 || fd != -1;\n  *(_BYTE *)(a1 + 54) = v7;\n  if ( fd == -1 )\n  {\n    if ( byte_61031E )\n    {\n      *(_DWORD *)(a1 + 56) = -1;\n      *(_DWORD *)(a1 + 60) = *__errno_location();\n      *(_BYTE *)(a1 + 52) = 0;\n      *(_QWORD *)(a1 + 40) = 0LL;\n      *(_QWORD *)(a1 + 32) = 0LL;\n    }\n    v8 = sub_401DE6((const char **)a1);\n    v9 = sub_408FA1(v8);\n    v10 = gettext(\"cannot open %s for reading\");\n    v11 = __errno_location();\n    error(0, *v11, v10, v9);\n    v28 = 0;\n  }\n  else\n  {\n    if ( byte_610320 )\n    {\n      v12 = sub_401DE6((const char **)a1);\n      sub_401F89(v12);\n    }\n    v13 = sub_401DE6((const char **)a1);\n    v28 = sub_4059F3((__int64)v13, fd, a2, &v31);\n    if ( byte_61031E )\n    {\n      *(_DWORD *)(a1 + 60) = v28 - 1;\n      if ( (int)sub_40C6D0(fd, &stat_buf) >= 0 )\n      {\n        if ( (stat_buf.st_mode & 0xF000) != 0x8000\n          && (stat_buf.st_mode & 0xF000) != 4096\n          && (stat_buf.st_mode & 0xF000) != 49152\n          && (stat_buf.st_mode & 0xF000) != 0x2000 )\n        {\n          v18 = sub_401DE6((const char **)a1);\n          v19 = gettext(\"%s: cannot follow end of this type of file; giving up on this name\");\n          error(0, 0, v19, v18);\n          v28 = 0;\n          *(_DWORD *)(a1 + 60) = -1;\n          *(_BYTE *)(a1 + 52) = 1;\n        }\n      }\n      else\n      {\n        v28 = 0;\n        *(_DWORD *)(a1 + 60) = *__errno_location();\n        v14 = sub_401DE6((const char **)a1);\n        v15 = sub_408FA1(v14);\n        v16 = gettext(\"error reading %s\");\n        v17 = __errno_location();\n        error(0, *v17, v16, v15);\n      }\n      if ( v28 != 1 )\n      {\n        v20 = sub_401DE6((const char **)a1);\n        sub_401F23(fd, (__int64)v20);\n        *(_DWORD *)(a1 + 56) = -1;\n      }\n      else\n      {\n        if ( v29 )\n          v21 = -1;\n        else\n          v21 = 1;\n        sub_401E87(a1, fd, v31, (__int64)&stat_buf, v21);\n        v22 = sub_401DE6((const char **)a1);\n        *(_BYTE *)(a1 + 53) = sub_4031D8(fd, (__int64)v22);\n      }\n    }\n    else if ( !v29 && close(fd) )\n    {\n      v23 = sub_401DE6((const char **)a1);\n      v24 = sub_408FA1(v23);\n      v25 = gettext(\"error reading %s\");\n      v26 = __errno_location();\n      error(0, *v26, v25, v24);\n      v28 = 0;\n    }\n  }\n  return v28;\n}\n"], [4218475, "sub_405E6B", "__int64 __fastcall sub_405E6B(int a1, __int64 a2, _QWORD *a3)\n{\n  char *v4; // rax\n  int v5; // eax\n  int v6; // eax\n  __int64 v7; // rbx\n  char *v8; // rax\n  char v10; // [rsp+20h] [rbp-30h]\n  char v11; // [rsp+21h] [rbp-2Fh]\n  char v12; // [rsp+22h] [rbp-2Eh]\n  bool v13; // [rsp+23h] [rbp-2Dh]\n  int v14; // [rsp+24h] [rbp-2Ch]\n  _BYTE *v15; // [rsp+28h] [rbp-28h]\n  _BYTE *v16; // [rsp+30h] [rbp-20h]\n  _BYTE *v17; // [rsp+38h] [rbp-18h]\n\n  v14 = 10;\n  v11 = 1;\n  v12 = 0;\n  if ( a1 != 2\n    && (a1 != 3 || **(_BYTE **)(a2 + 16) == 45 && *(_BYTE *)(*(_QWORD *)(a2 + 16) + 1LL))\n    && (a1 <= 2 || a1 > 4 || strcmp(*(const char **)(a2 + 16), \"--\")) )\n  {\n    return 0LL;\n  }\n  v13 = (int)sub_408E12() <= 200111;\n  v4 = *(char **)(a2 + 8);\n  v15 = v4 + 1;\n  v5 = *v4;\n  if ( v5 == 43 )\n  {\n    if ( !v13 )\n      return 0LL;\n    v10 = 1;\n  }\n  else\n  {\n    if ( v5 != 45 )\n      return 0LL;\n    if ( !v13 && !v15[*v15 == 99] )\n      return 0LL;\n    v10 = 0;\n  }\n  v16 = v15;\n  while ( (unsigned int)((char)*v15 - 48) <= 9 )\n    ++v15;\n  v17 = v15;\n  v6 = (char)*v15;\n  switch ( v6 )\n  {\n    case 'c':\n      goto LABEL_26;\n    case 'l':\nLABEL_27:\n      ++v15;\n      break;\n    case 'b':\n      v14 = 5120;\nLABEL_26:\n      v11 = 0;\n      goto LABEL_27;\n  }\n  if ( *v15 == 102 )\n  {\n    v12 = 1;\n    ++v15;\n  }\n  if ( *v15 )\n    return 0LL;\n  if ( v16 == v17 )\n  {\n    *a3 = v14;\n  }\n  else if ( (sub_40BA18(v16, 0LL, 10LL, a3, \"b\") & 0xFFFFFFFD) != 0 )\n  {\n    v7 = sub_408FA1(*(_QWORD *)(a2 + 8));\n    v8 = gettext(\"number in %s is too large\");\n    error(1, 0, v8, v7);\n  }\n  byte_61031F = v10;\n  byte_61031D = v11;\n  byte_61031E = v12;\n  return 1LL;\n}\n"], [4219048, "sub_4060A8", "void __fastcall sub_4060A8(int a1, char *const *a2, __int64 a3, _DWORD *a4, _QWORD *a5)\n{\n  int i; // eax\n  char *v6; // rax\n  __int64 v7; // rbx\n  char *v8; // rax\n  __int64 v9; // rbx\n  char *v10; // rax\n  __int64 v11; // rbx\n  char *v12; // rax\n  char *v13; // rax\n  char *v14; // rax\n  char *v15; // rax\n  char *v16; // rax\n  unsigned int v20; // [rsp+4Ch] [rbp-24h]\n  __int64 v21[3]; // [rsp+58h] [rbp-18h] BYREF\n\n  for ( i = getopt_long(a1, a2, \"c:n:fFqs:v0123456789\", &longopts, 0LL);\n        ;\n        i = getopt_long(a1, a2, \"c:n:fFqs:v0123456789\", &longopts, 0LL) )\n  {\n    v20 = i;\n    if ( i == -1 )\n      break;\n    if ( i == 113 )\n    {\n      *a4 = 2;\n      continue;\n    }\n    if ( i > 113 )\n    {\n      if ( i == 129 )\n      {\n        if ( (unsigned int)sub_40BA18(optarg, 0LL, 10LL, &qword_610258, &locale) )\n        {\n          v7 = optarg;\n          v8 = gettext(\"%s: invalid maximum number of unchanged stats between opens\");\n          error(1, 0, v8, v7);\n        }\n      }\n      else if ( i > 129 )\n      {\n        if ( i == 131 )\n        {\n          byte_610329 = 1;\n          continue;\n        }\n        if ( i < 131 )\n        {\n          if ( (unsigned int)sub_40B50C(optarg, 0LL, 10LL, v21, &locale) || v21[0] > 0x7FFFFFFFuLL )\n          {\n            v9 = optarg;\n            v10 = gettext(\"%s: invalid PID\");\n            error(1, 0, v10, v9);\n          }\n          pid = v21[0];\n        }\n        else\n        {\n          if ( i == 132 )\n          {\nLABEL_38:\n            byte_61031E = 1;\n            if ( optarg )\n              dword_610250 = dword_40C8A8[sub_406E90(\"--follow\", optarg, off_40C890, dword_40C8A8, 4LL, off_610278)];\n            else\n              dword_610250 = 2;\n            continue;\n          }\n          if ( i != 133 )\n            goto LABEL_60;\n          byte_61032A = 1;\n        }\n      }\n      else\n      {\n        switch ( i )\n        {\n          case 118:\n            *a4 = 1;\n            break;\n          case 128:\n            byte_61031C = 1;\n            break;\n          case 115:\n            if ( (unsigned __int8)sub_40B3B9(optarg, 0LL, v21, sub_406FD6) != 1 || *(double *)v21 < 0.0 )\n            {\n              v11 = optarg;\n              v12 = gettext(\"%s: invalid number of seconds\");\n              error(1, 0, v12, v11);\n            }\n            *a5 = v21[0];\n            break;\n          default:\n            goto LABEL_60;\n        }\n      }\n    }\n    else\n    {\n      if ( i <= 57 )\n      {\n        if ( i >= 48 )\n        {\n          v13 = gettext(\"option used in invalid context -- %c\");\n          error(1, 0, v13, v20);\n        }\n        else\n        {\n          if ( i == -131 )\n          {\n            sub_40AF29(\n              (_DWORD)stdout,\n              (unsigned int)\"tail\",\n              (unsigned int)\"GNU coreutils\",\n              (_DWORD)off_610270,\n              (unsigned int)\"Paul Rubin\",\n              (unsigned int)\"David MacKenzie\",\n              \"Ian Lance Taylor\",\n              \"Jim Meyering\",\n              0LL);\n            exit(0);\n          }\n          if ( i == -130 )\n            sub_401C08(0);\n        }\nLABEL_60:\n        sub_401C08(1);\n      }\n      if ( i == 99 )\n        goto LABEL_28;\n      if ( i > 99 )\n      {\n        if ( i == 102 )\n          goto LABEL_38;\n        if ( i != 110 )\n          goto LABEL_60;\nLABEL_28:\n        byte_61031D = i == 110;\n        if ( *(_BYTE *)optarg == 43 )\n        {\n          byte_61031F = 1;\n        }\n        else if ( *(_BYTE *)optarg == 45 )\n        {\n          ++optarg;\n        }\n        if ( (unsigned int)sub_40BA18(optarg, 0LL, 10LL, a3, \"bkKmMGTPEZY0\") )\n        {\n          if ( v20 == 110 )\n            v6 = gettext(\"invalid number of lines\");\n          else\n            v6 = gettext(\"invalid number of bytes\");\n          error(1, 0, \"%s: %s\", (const char *)optarg, v6);\n        }\n        continue;\n      }\n      if ( i != 70 )\n        goto LABEL_60;\n      byte_61031E = 1;\n      dword_610250 = 1;\n      byte_61031C = 1;\n    }\n  }\n  if ( byte_61031C && dword_610250 != 1 )\n  {\n    v14 = gettext(\"warning: --retry is useful mainly when following by name\");\n    error(0, 0, v14);\n  }\n  if ( pid && byte_61031E != 1 )\n  {\n    v15 = gettext(\"warning: PID ignored; --pid=PID is useful only when following\");\n    error(0, 0, v15);\n  }\n  else if ( pid && kill(pid, 0) && *__errno_location() == 38 )\n  {\n    v16 = gettext(\"warning: --pid=PID is not supported on this system\");\n    error(0, 0, v16);\n    pid = 0;\n  }\n}\n"], [4220400, "sub_4065F0", "__int64 __fastcall sub_4065F0(__int64 a1, unsigned __int64 a2)\n{\n  __int64 v4; // [rsp+20h] [rbp-10h]\n  unsigned __int64 i; // [rsp+28h] [rbp-8h]\n\n  v4 = 0LL;\n  for ( i = 0LL; i < a2; ++i )\n  {\n    if ( !strcmp(*(const char **)(96 * i + a1), \"-\")\n      && *(_BYTE *)(96 * i + a1 + 52) != 1\n      && *(int *)(96 * i + a1 + 56) >= 0\n      && (*(_DWORD *)(96 * i + a1 + 48) & 0xF000) == 4096 )\n    {\n      *(_BYTE *)(96 * i + a1 + 52) = 1;\n    }\n    else\n    {\n      ++v4;\n    }\n  }\n  return v4;\n}\n"], [4220686, "main", "void __fastcall __noreturn main(int a1, char **a2, char **a3)\n{\n  __int64 v3; // rbx\n  char *v4; // rax\n  char *v5; // rax\n  char *v6; // rbx\n  int *v7; // rax\n  char *v8; // rbx\n  int *v9; // rax\n  int *v10; // rax\n  char *const *v11; // [rsp+10h] [rbp-60h]\n  int v12; // [rsp+1Ch] [rbp-54h]\n  bool v13; // [rsp+25h] [rbp-4Bh]\n  char v14; // [rsp+26h] [rbp-4Ah]\n  _BYTE v15[5]; // [rsp+27h] [rbp-49h] BYREF\n  int v16; // [rsp+2Ch] [rbp-44h]\n  size_t v17; // [rsp+30h] [rbp-40h] BYREF\n  __int64 v18; // [rsp+38h] [rbp-38h] BYREF\n  unsigned __int64 v19; // [rsp+40h] [rbp-30h]\n  char **v20; // [rsp+48h] [rbp-28h]\n  unsigned __int64 i; // [rsp+50h] [rbp-20h]\n  __int64 v22; // [rsp+58h] [rbp-18h]\n\n  *(_DWORD *)&v15[1] = 0;\n  v13 = 1;\n  v17 = 10LL;\n  v18 = 0x3FF0000000000000LL;\n  sub_408E96(*a2, a2, a3);\n  setlocale(6, &locale);\n  bindtextdomain(\"coreutils\", \"/root/Product/coreutils/exe/share/locale\");\n  textdomain(\"coreutils\");\n  sub_40C6B0(sub_40706C);\n  byte_610328 = 0;\n  byte_61031D = 1;\n  byte_610320 = 0;\n  byte_61031F = 0;\n  byte_61031E = 0;\n  *(_DWORD *)v15 = (unsigned __int8)sub_405E6B(a1, (__int64)a2, &v17);\n  v12 = a1 - v15[0];\n  v11 = &a2[v15[0]];\n  sub_4060A8(v12, v11, (__int64)&v17, &v15[1], &v18);\n  if ( byte_61031F && v17 )\n    --v17;\n  if ( optind >= v12 )\n  {\n    v19 = 1LL;\n    v20 = off_610268;\n  }\n  else\n  {\n    v19 = v12 - optind;\n    v20 = (char **)&v11[optind];\n  }\n  v14 = 0;\n  for ( i = 0LL; i < v19; ++i )\n  {\n    if ( !strcmp(v20[i], \"-\") )\n      v14 = 1;\n  }\n  if ( v14 && dword_610250 == 1 )\n  {\n    v3 = sub_408FA1(\"-\");\n    v4 = gettext(\"cannot follow %s by name\");\n    error(1, 0, v4, v3);\n  }\n  if ( byte_61031E && v14 && isatty(0) )\n  {\n    v5 = gettext(\"warning: following standard input indefinitely is ineffective\");\n    error(0, 0, v5);\n  }\n  v22 = sub_40B048(v19, 96LL);\n  for ( i = 0LL; i < v19; ++i )\n    *(_QWORD *)(v22 + 96 * i) = v20[i];\n  if ( *(_DWORD *)&v15[1] == 1 || !*(_DWORD *)&v15[1] && v19 > 1 )\n    byte_610320 = 1;\n  for ( i = 0LL; i < v19; ++i )\n    v13 = (v13 & (unsigned __int8)sub_405A52(96 * i + v22, v17)) != 0;\n  if ( byte_61031E && sub_4065F0(v22, v19) )\n  {\n    if ( byte_61032A != 1 && ((unsigned __int8)sub_40433B(v22, v19) || (unsigned __int8)sub_4042C3(v22, v19)) )\n      byte_61032A = 1;\n    if ( byte_61032A != 1 )\n    {\n      v16 = inotify_init();\n      if ( v16 >= 0 )\n      {\n        if ( fflush_unlocked(stdout) )\n        {\n          v6 = gettext(\"write error\");\n          v7 = __errno_location();\n          error(1, *v7, v6);\n        }\n        if ( (unsigned __int8)sub_40467E(v16, v22, v19, *(double *)&v18) != 1 )\n          exit(1);\n      }\n      v8 = gettext(\"inotify cannot be used, reverting to polling\");\n      v9 = __errno_location();\n      error(0, *v9, v8);\n    }\n    byte_61032A = 1;\n    sub_40396A(v22, v19, *(double *)&v18);\n  }\n  if ( byte_610328 )\n  {\n    if ( close(0) < 0 )\n    {\n      v10 = __errno_location();\n      error(1, *v10, \"-\");\n    }\n  }\n  exit(!v13);\n}\n"], [4221846, "sub_406B96", "void __noreturn sub_406B96()\n{\n  sub_401C08(1);\n}\n"], [4221862, "sub_406BA6", "__int64 __fastcall sub_406BA6(const char *a1, __int64 a2, __int64 a3, size_t a4)\n{\n  __int64 result; // rax\n  char v7; // [rsp+27h] [rbp-19h]\n  __int64 i; // [rsp+28h] [rbp-18h]\n  __int64 v9; // [rsp+30h] [rbp-10h]\n  size_t n; // [rsp+38h] [rbp-8h]\n\n  v9 = -1LL;\n  v7 = 0;\n  n = strlen(a1);\n  for ( i = 0LL; *(_QWORD *)(8 * i + a2); ++i )\n  {\n    if ( !strncmp(*(const char **)(8 * i + a2), a1, n) )\n    {\n      if ( strlen(*(const char **)(8 * i + a2)) == n )\n        return i;\n      if ( v9 == -1 )\n      {\n        v9 = i;\n      }\n      else if ( !a3 || memcmp((const void *)(a4 * v9 + a3), (const void *)(i * a4 + a3), a4) )\n      {\n        v7 = 1;\n      }\n    }\n  }\n  if ( v7 )\n    result = -2LL;\n  else\n    result = v9;\n  return result;\n}\n"], [4222165, "sub_406CD5", "void __fastcall sub_406CD5(__int64 a1, __int64 a2, __int64 a3)\n{\n  char *v3; // rax\n  __int64 v4; // rbx\n  __int64 v5; // rax\n  char *format; // [rsp+28h] [rbp-18h]\n\n  if ( a3 == -1 )\n    v3 = gettext(\"invalid argument %s for %s\");\n  else\n    v3 = gettext(\"ambiguous argument %s for %s\");\n  format = v3;\n  v4 = sub_408F7D(1LL, a1);\n  v5 = sub_40A42C(0LL, 6LL, a2);\n  error(0, 0, format, v5, v4);\n}\n"], [4222304, "sub_406D60", "int __fastcall sub_406D60(__int64 a1, __int64 a2, size_t a3)\n{\n  char *v3; // rax\n  __int64 i; // [rsp+20h] [rbp-10h]\n  void *s1; // [rsp+28h] [rbp-8h]\n\n  s1 = 0LL;\n  v3 = gettext(\"Valid arguments are:\");\n  fprintf(stderr, v3);\n  for ( i = 0LL; *(_QWORD *)(8 * i + a1); ++i )\n  {\n    if ( i && !memcmp(s1, (const void *)(i * a3 + a2), a3) )\n    {\n      fprintf(stderr, \", `%s'\", *(const char **)(8 * i + a1));\n    }\n    else\n    {\n      fprintf(stderr, \"\\n  - `%s'\", *(const char **)(8 * i + a1));\n      s1 = (void *)(i * a3 + a2);\n    }\n  }\n  return putc_unlocked(10, stderr);\n}\n"], [4222608, "sub_406E90", "__int64 __fastcall sub_406E90(__int64 a1, const char *a2, __int64 a3, __int64 a4, size_t a5, void (*a6)(void))\n{\n  __int64 v11; // [rsp+38h] [rbp-8h]\n\n  v11 = sub_406BA6(a2, a3, a4, a5);\n  if ( v11 >= 0 )\n    return v11;\n  sub_406CD5(a1, (__int64)a2, v11);\n  sub_406D60(a3, a4, a5);\n  a6();\n  return -1LL;\n}\n"], [4222742, "sub_406F16", "__int64 __fastcall sub_406F16(const void *a1, __int64 a2, __int64 a3, size_t a4)\n{\n  __int64 i; // [rsp+28h] [rbp-8h]\n\n  for ( i = 0LL; *(_QWORD *)(8 * i + a2); ++i )\n  {\n    if ( !memcmp(a1, (const void *)(i * a4 + a3), a4) )\n      return *(_QWORD *)(8 * i + a2);\n  }\n  return 0LL;\n}\n"], [4222882, "sub_406FA2", "__int64 sub_406FA2()\n{\n  if ( !qword_610330 )\n    qword_610330 = (__int64)newlocale(8127, \"C\", 0LL);\n  return qword_610330;\n}\n"], [4222934, "sub_406FD6", "double __fastcall sub_406FD6(const char *a1, char **a2)\n{\n  struct __locale_struct *loc; // [rsp+20h] [rbp-10h]\n\n  loc = (struct __locale_struct *)sub_406FA2();\n  if ( loc )\n    return strtod_l(a1, a2, loc);\n  if ( a2 )\n    *a2 = (char *)a1;\n  return 0.0;\n}\n"], [4223042, "sub_407042", "__int64 __fastcall sub_407042(__int64 a1)\n{\n  __int64 result; // rax\n\n  result = a1;\n  qword_610338 = a1;\n  return result;\n}\n"], [4223063, "sub_407057", "__int64 __fastcall sub_407057(unsigned __int8 a1)\n{\n  __int64 result; // rax\n\n  result = a1;\n  byte_610340 = a1;\n  return result;\n}\n"], [4223084, "sub_40706C", "__int64 sub_40706C()\n{\n  const char *v0; // rbx\n  int *v1; // rax\n  int *v2; // rax\n  __int64 result; // rax\n  char *v4; // [rsp+8h] [rbp-18h]\n\n  if ( (unsigned int)sub_40C21D(stdout) && (byte_610340 != 1 || *__errno_location() != 32) )\n  {\n    v4 = gettext(\"write error\");\n    if ( qword_610338 )\n    {\n      v0 = (const char *)sub_40A5BA(qword_610338);\n      v1 = __errno_location();\n      error(0, *v1, \"%s: %s\", v0, v4);\n    }\n    else\n    {\n      v2 = __errno_location();\n      error(0, *v2, \"%s\", v4);\n    }\n    _exit(status);\n  }\n  result = sub_40C21D(stderr);\n  if ( (_DWORD)result )\n    _exit(status);\n  return result;\n}\n"], [4223319, "sub_407157", "unsigned __int64 __fastcall sub_407157(_BYTE *a1)\n{\n  unsigned __int64 i; // [rsp+10h] [rbp-10h]\n  unsigned __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = *a1 == 47;\n  for ( i = sub_407277(a1) - (_QWORD)a1; v3 < i && a1[i - 1] == 47; --i )\n    ;\n  return i;\n}\n"], [4223456, "sub_4071E0", "_BYTE *__fastcall sub_4071E0(_BYTE *a1)\n{\n  unsigned __int64 n; // [rsp+20h] [rbp-10h]\n  _BYTE *dest; // [rsp+28h] [rbp-8h]\n\n  n = sub_407157(a1);\n  dest = malloc((n == 0) + n + 1);\n  if ( !dest )\n    return 0LL;\n  memcpy(dest, a1, n);\n  if ( !n )\n  {\n    n = 1LL;\n    *dest = 46;\n  }\n  dest[n] = 0;\n  return dest;\n}\n"], [4223607, "sub_407277", "_BYTE *__fastcall sub_407277(_BYTE *a1)\n{\n  char v2; // [rsp+17h] [rbp-11h]\n  _BYTE *i; // [rsp+20h] [rbp-8h]\n\n  v2 = 0;\n  while ( *a1 == 47 )\n    ++a1;\n  for ( i = a1; *i; ++i )\n  {\n    if ( *i == 47 )\n    {\n      v2 = 1;\n    }\n    else if ( v2 )\n    {\n      a1 = i;\n      v2 = 0;\n    }\n  }\n  return a1;\n}\n"], [4223712, "sub_4072E0", "size_t __fastcall sub_4072E0(const char *a1)\n{\n  size_t i; // [rsp+10h] [rbp-10h]\n\n  for ( i = strlen(a1); i > 1 && a1[i - 1] == 47; --i )\n    ;\n  return i;\n}\n"], [4223790, "sub_40732E", "__int64 __fastcall sub_40732E(const char *a1, char a2, unsigned int a3)\n{\n  unsigned int v3; // eax\n  unsigned int v5; // [rsp+14h] [rbp-CCh]\n\n  v5 = 0;\n  if ( (a2 & 0x40) != 0 )\n    v5 = a3;\n  v3 = open(a1, a2, v5);\n  return sub_40A7AA(v3);\n}\n"], [4224064, "sub_407440", "__int64 __fastcall sub_407440(__int64 a1, char a2)\n{\n  return __ROR8__(a1, a2);\n}\n"], [4224092, "sub_40745C", "__int64 __fastcall sub_40745C(__int64 a1)\n{\n  return *(_QWORD *)(a1 + 16);\n}\n"], [4224110, "sub_40746E", "__int64 __fastcall sub_40746E(__int64 a1)\n{\n  return *(_QWORD *)(a1 + 24);\n}\n"], [4224128, "sub_407480", "__int64 __fastcall sub_407480(__int64 a1)\n{\n  return *(_QWORD *)(a1 + 32);\n}\n"], [4224146, "sub_407492", "unsigned __int64 __fastcall sub_407492(__int64 a1)\n{\n  _QWORD *i; // [rsp+8h] [rbp-20h]\n  unsigned __int64 v3; // [rsp+10h] [rbp-18h]\n  _QWORD *v4; // [rsp+18h] [rbp-10h]\n  unsigned __int64 j; // [rsp+20h] [rbp-8h]\n\n  v3 = 0LL;\n  for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      v4 = i;\n      for ( j = 1LL; ; ++j )\n      {\n        v4 = (_QWORD *)v4[1];\n        if ( !v4 )\n          break;\n      }\n      if ( j > v3 )\n        v3 = j;\n    }\n  }\n  return v3;\n}\n"], [4224272, "sub_407510", "_BOOL8 __fastcall sub_407510(__int64 a1)\n{\n  _QWORD *i; // [rsp+8h] [rbp-20h]\n  __int64 v3; // [rsp+10h] [rbp-18h]\n  __int64 v4; // [rsp+18h] [rbp-10h]\n  _QWORD *v5; // [rsp+20h] [rbp-8h]\n\n  v3 = 0LL;\n  v4 = 0LL;\n  for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      v5 = i;\n      ++v3;\n      ++v4;\n      while ( 1 )\n      {\n        v5 = (_QWORD *)v5[1];\n        if ( !v5 )\n          break;\n        ++v4;\n      }\n    }\n  }\n  return *(_QWORD *)(a1 + 24) == v3 && *(_QWORD *)(a1 + 32) == v4;\n}\n"], [4224426, "sub_4075AA", "int __fastcall sub_4075AA(__int64 a1, FILE *a2)\n{\n  double v2; // xmm0_8\n  double v3; // xmm1_8\n  double v4; // xmm0_8\n  __int64 v6; // [rsp+10h] [rbp-20h]\n  __int64 v7; // [rsp+18h] [rbp-18h]\n  __int64 v8; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v9; // [rsp+28h] [rbp-8h]\n\n  v6 = sub_407480(a1);\n  v7 = sub_40745C(a1);\n  v8 = sub_40746E(a1);\n  v9 = sub_407492(a1);\n  fprintf(a2, \"# entries:         %lu\\n\", v6);\n  fprintf(a2, \"# buckets:         %lu\\n\", v7);\n  if ( v8 < 0 )\n    v2 = (double)(int)(v8 & 1 | ((unsigned __int64)v8 >> 1)) + (double)(int)(v8 & 1 | ((unsigned __int64)v8 >> 1));\n  else\n    v2 = (double)(int)v8;\n  v3 = 100.0 * v2;\n  if ( v7 < 0 )\n    v4 = (double)(int)(v7 & 1 | ((unsigned __int64)v7 >> 1)) + (double)(int)(v7 & 1 | ((unsigned __int64)v7 >> 1));\n  else\n    v4 = (double)(int)v7;\n  fprintf(a2, \"# buckets used:    %lu (%.2f%%)\\n\", v8, v3 / v4);\n  return fprintf(a2, \"max bucket length: %lu\\n\", v9);\n}\n"], [4224706, "sub_4076C2", "__int64 __fastcall sub_4076C2(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 48))(a2, *(_QWORD *)(a1 + 16));\n  if ( *(_QWORD *)(a1 + 16) <= v3 )\n    abort();\n  return 16 * v3 + *(_QWORD *)a1;\n}\n"], [4224793, "sub_407719", "__int64 __fastcall sub_407719(__int64 a1, __int64 a2)\n{\n  _QWORD *i; // [rsp+10h] [rbp-10h]\n  _QWORD *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = (_QWORD *)sub_4076C2(a1, a2);\n  if ( !*v4 )\n    return 0LL;\n  for ( i = v4; i; i = (_QWORD *)i[1] )\n  {\n    if ( *i == a2 || (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(a1 + 56))(a2, *i) )\n      return *i;\n  }\n  return 0LL;\n}\n"], [4224940, "sub_4077AC", "__int64 __fastcall sub_4077AC(unsigned __int64 *a1)\n{\n  unsigned __int64 i; // [rsp+18h] [rbp-8h]\n\n  if ( !a1[4] )\n    return 0LL;\n  for ( i = *a1; ; i += 16LL )\n  {\n    if ( a1[1] <= i )\n      abort();\n    if ( *(_QWORD *)i )\n      break;\n  }\n  return *(_QWORD *)i;\n}\n"], [4225032, "sub_407808", "__int64 __fastcall sub_407808(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v3; // [rsp+10h] [rbp-10h]\n  unsigned __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_4076C2(a1, a2);\n  v4 = v3;\n  do\n  {\n    if ( *(_QWORD *)v4 == a2 && *(_QWORD *)(v4 + 8) )\n      return **(_QWORD **)(v4 + 8);\n    v4 = *(_QWORD *)(v4 + 8);\n  }\n  while ( v4 );\n  while ( 1 )\n  {\n    v3 += 16LL;\n    if ( v3 >= *(_QWORD *)(a1 + 8) )\n      break;\n    if ( *(_QWORD *)v3 )\n      return *(_QWORD *)v3;\n  }\n  return 0LL;\n}\n"], [4225186, "sub_4078A2", "unsigned __int64 __fastcall sub_4078A2(__int64 a1, __int64 a2, unsigned __int64 a3)\n{\n  __int64 v4; // rax\n  unsigned __int64 v5; // [rsp+20h] [rbp-18h]\n  _QWORD *i; // [rsp+28h] [rbp-10h]\n  _QWORD *j; // [rsp+30h] [rbp-8h]\n\n  v5 = 0LL;\n  for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      for ( j = i; j; j = (_QWORD *)j[1] )\n      {\n        if ( v5 >= a3 )\n          return v5;\n        v4 = v5++;\n        *(_QWORD *)(a2 + 8 * v4) = *j;\n      }\n    }\n  }\n  return v5;\n}\n"], [4225342, "sub_40793E", "__int64 __fastcall sub_40793E(__int64 a1, unsigned __int8 (__fastcall *a2)(_QWORD, __int64), __int64 a3)\n{\n  __int64 v5; // [rsp+28h] [rbp-18h]\n  _QWORD *i; // [rsp+30h] [rbp-10h]\n  _QWORD *j; // [rsp+38h] [rbp-8h]\n\n  v5 = 0LL;\n  for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      for ( j = i; j; j = (_QWORD *)j[1] )\n      {\n        if ( a2(*j, a3) != 1 )\n          return v5;\n        ++v5;\n      }\n    }\n  }\n  return v5;\n}\n"], [4225490, "sub_4079D2", "unsigned __int64 __fastcall sub_4079D2(_BYTE *a1, unsigned __int64 a2)\n{\n  unsigned __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v4 = 0LL;\n  while ( *a1 )\n    v4 = (31 * v4 + (unsigned __int8)*a1++) % a2;\n  return v4;\n}\n"], [4225576, "sub_407A28", "bool __fastcall sub_407A28(unsigned __int64 a1)\n{\n  unsigned __int64 v2; // [rsp+8h] [rbp-10h]\n  unsigned __int64 v3; // [rsp+8h] [rbp-10h]\n  unsigned __int64 v4; // [rsp+10h] [rbp-8h]\n\n  v2 = 3LL;\n  v4 = 9LL;\n  while ( v4 < a1 && a1 % v2 )\n  {\n    v3 = v2 + 1;\n    v4 += 4 * v3;\n    v2 = v3 + 1;\n  }\n  return a1 % v2 != 0;\n}\n"], [4225684, "sub_407A94", "__int64 __fastcall sub_407A94(unsigned __int64 a1)\n{\n  __int64 v2; // [rsp+0h] [rbp-8h]\n  __int64 i; // [rsp+0h] [rbp-8h]\n\n  v2 = a1;\n  if ( a1 <= 9 )\n    v2 = 10LL;\n  for ( i = v2 | 1; i != -1 && !sub_407A28(i); i += 2LL )\n    ;\n  return i;\n}\n"], [4225755, "sub_407ADB", "__int64 __fastcall sub_407ADB(__int64 a1)\n{\n  __int64 result; // rax\n\n  *(_DWORD *)a1 = 0;\n  *(_DWORD *)(a1 + 4) = 1065353216;\n  *(_DWORD *)(a1 + 8) = 1061997773;\n  *(_DWORD *)(a1 + 12) = 1068826100;\n  result = a1;\n  *(_BYTE *)(a1 + 16) = 0;\n  return result;\n}\n"], [4225824, "sub_407B20", "unsigned __int64 __fastcall sub_407B20(__int64 a1, unsigned __int64 a2)\n{\n  return sub_407440(a1, 3) % a2;\n}\n"], [4225879, "sub_407B57", "bool __fastcall sub_407B57(__int64 a1, __int64 a2)\n{\n  return a1 == a2;\n}\n"], [4225904, "sub_407B70", "__int64 __fastcall sub_407B70(__int64 a1)\n{\n  __int64 v2; // [rsp+10h] [rbp-8h]\n\n  v2 = *(_QWORD *)(a1 + 40);\n  if ( (_UNKNOWN *)v2 == &unk_40DDA0 )\n    return 1LL;\n  if ( *(float *)(v2 + 8) > 0.1\n    && (float)(1.0 - 0.1) > *(float *)(v2 + 8)\n    && *(float *)(v2 + 12) > (float)(0.1 + 1.0)\n    && *(float *)v2 >= 0.0\n    && *(float *)(v2 + 4) > (float)(*(float *)v2 + 0.1)\n    && *(float *)(v2 + 4) <= 1.0\n    && *(float *)(v2 + 8) > (float)(*(float *)v2 + 0.1) )\n  {\n    return 1LL;\n  }\n  *(_QWORD *)(a1 + 40) = &unk_40DDA0;\n  return 0LL;\n}\n"], [4226152, "sub_407C68", "unsigned __int64 __fastcall sub_407C68(__int64 a1, __int64 a2)\n{\n  float v2; // xmm0_4\n  unsigned __int64 result; // rax\n  unsigned __int64 v4; // [rsp+8h] [rbp-18h]\n  unsigned __int64 v5; // [rsp+8h] [rbp-18h]\n  float v6; // [rsp+1Ch] [rbp-4h]\n\n  v4 = a1;\n  if ( *(_BYTE *)(a2 + 16) != 1 )\n  {\n    if ( a1 < 0 )\n      v2 = (float)(a1 & 1 | (unsigned int)((unsigned __int64)a1 >> 1))\n         + (float)(a1 & 1 | (unsigned int)((unsigned __int64)a1 >> 1));\n    else\n      v2 = (float)(int)a1;\n    v6 = v2 / *(float *)(a2 + 8);\n    if ( v6 >= 1.8446744e19 )\n      return 0LL;\n    if ( v6 >= 9.223372e18 )\n      v4 = (unsigned int)(int)(float)(v6 - 9.223372e18) ^ 0x8000000000000000LL;\n    else\n      v4 = (unsigned int)(int)v6;\n  }\n  v5 = sub_407A94(v4);\n  if ( v5 <= 0x1FFFFFFFFFFFFFFFLL )\n    result = v5;\n  else\n    result = 0LL;\n  return result;\n}\n"], [4226386, "sub_407D52", "size_t *__fastcall sub_407D52(__int64 a1, void *a2, unsigned __int64 (__fastcall *a3)(__int64 a1, unsigned __int64 a2), bool (__fastcall *a4)(__int64 a1, __int64 a2), size_t a5)\n{\n  size_t *result; // rax\n  bool (__fastcall *v7)(__int64, __int64); // [rsp+10h] [rbp-30h]\n  unsigned __int64 (__fastcall *v8)(__int64, unsigned __int64); // [rsp+18h] [rbp-28h]\n  void *v9; // [rsp+20h] [rbp-20h]\n  size_t *ptr; // [rsp+38h] [rbp-8h]\n\n  v9 = a2;\n  v8 = a3;\n  v7 = a4;\n  if ( !a3 )\n    v8 = sub_407B20;\n  if ( !a4 )\n    v7 = sub_407B57;\n  ptr = (size_t *)malloc(0x50uLL);\n  if ( !ptr )\n    return 0LL;\n  if ( !a2 )\n    v9 = &unk_40DDA0;\n  ptr[5] = (size_t)v9;\n  if ( (unsigned __int8)sub_407B70((__int64)ptr) == 1\n    && (ptr[2] = sub_407C68(a1, (__int64)v9)) != 0\n    && (*ptr = (size_t)calloc(ptr[2], 0x10uLL)) != 0 )\n  {\n    ptr[1] = 16 * ptr[2] + *ptr;\n    ptr[3] = 0LL;\n    ptr[4] = 0LL;\n    ptr[6] = (size_t)v8;\n    ptr[7] = (size_t)v7;\n    ptr[8] = a5;\n    ptr[9] = 0LL;\n    result = ptr;\n  }\n  else\n  {\n    free(ptr);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4226743, "sub_407EB7", "__int64 __fastcall sub_407EB7(__int64 a1)\n{\n  __int64 result; // rax\n  _QWORD *i; // [rsp+18h] [rbp-18h]\n  _QWORD *j; // [rsp+20h] [rbp-10h]\n  _QWORD *v4; // [rsp+28h] [rbp-8h]\n\n  for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      for ( j = (_QWORD *)i[1]; j; j = v4 )\n      {\n        if ( *(_QWORD *)(a1 + 64) )\n          (*(void (__fastcall **)(_QWORD))(a1 + 64))(*j);\n        *j = 0LL;\n        v4 = (_QWORD *)j[1];\n        j[1] = *(_QWORD *)(a1 + 72);\n        *(_QWORD *)(a1 + 72) = j;\n      }\n      if ( *(_QWORD *)(a1 + 64) )\n        (*(void (__fastcall **)(_QWORD))(a1 + 64))(*i);\n      *i = 0LL;\n      i[1] = 0LL;\n    }\n  }\n  *(_QWORD *)(a1 + 24) = 0LL;\n  result = a1;\n  *(_QWORD *)(a1 + 32) = 0LL;\n  return result;\n}\n"], [4227005, "sub_407FBD", "void __fastcall sub_407FBD(__int64 a1)\n{\n  _QWORD *i; // [rsp+18h] [rbp-18h]\n  _QWORD *j; // [rsp+18h] [rbp-18h]\n  _QWORD *ptr; // [rsp+20h] [rbp-10h]\n  _QWORD *ptra; // [rsp+20h] [rbp-10h]\n  _QWORD *ptrb; // [rsp+20h] [rbp-10h]\n  _QWORD *v6; // [rsp+28h] [rbp-8h]\n  _QWORD *v7; // [rsp+28h] [rbp-8h]\n\n  if ( *(_QWORD *)(a1 + 64) && *(_QWORD *)(a1 + 32) )\n  {\n    for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n    {\n      if ( *i )\n      {\n        for ( ptr = i; ptr; ptr = (_QWORD *)ptr[1] )\n          (*(void (__fastcall **)(_QWORD))(a1 + 64))(*ptr);\n      }\n    }\n  }\n  for ( j = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)j; j += 2 )\n  {\n    for ( ptra = (_QWORD *)j[1]; ptra; ptra = v6 )\n    {\n      v6 = (_QWORD *)ptra[1];\n      free(ptra);\n    }\n  }\n  for ( ptrb = *(_QWORD **)(a1 + 72); ptrb; ptrb = v7 )\n  {\n    v7 = (_QWORD *)ptrb[1];\n    free(ptrb);\n  }\n  free(*(void **)a1);\n  free((void *)a1);\n}\n"], [4227303, "sub_4080E7", "void *__fastcall sub_4080E7(__int64 a1)\n{\n  __int64 v2; // [rsp+18h] [rbp-8h]\n\n  if ( !*(_QWORD *)(a1 + 72) )\n    return malloc(0x10uLL);\n  v2 = *(_QWORD *)(a1 + 72);\n  *(_QWORD *)(a1 + 72) = *(_QWORD *)(v2 + 8);\n  return (void *)v2;\n}\n"], [4227378, "sub_408132", "__int64 __fastcall sub_408132(__int64 a1, _QWORD *a2)\n{\n  __int64 result; // rax\n\n  *a2 = 0LL;\n  a2[1] = *(_QWORD *)(a1 + 72);\n  result = a1;\n  *(_QWORD *)(a1 + 72) = a2;\n  return result;\n}\n"], [4227431, "sub_408167", "__int64 __fastcall sub_408167(__int64 a1, __int64 a2, _QWORD *a3, char a4)\n{\n  __int64 result; // rax\n  __int64 v5; // rdx\n  _QWORD *i; // [rsp+20h] [rbp-30h]\n  _QWORD *v9; // [rsp+28h] [rbp-28h]\n  __int64 v10; // [rsp+30h] [rbp-20h]\n  _QWORD *v11; // [rsp+38h] [rbp-18h]\n  __int64 v12; // [rsp+40h] [rbp-10h]\n  _QWORD *v13; // [rsp+48h] [rbp-8h]\n\n  v9 = (_QWORD *)sub_4076C2(a1, a2);\n  *a3 = v9;\n  if ( !*v9 )\n    return 0LL;\n  if ( *v9 == a2 || (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(a1 + 56))(a2, *v9) )\n  {\n    v12 = *v9;\n    if ( a4 )\n    {\n      if ( v9[1] )\n      {\n        v13 = (_QWORD *)v9[1];\n        v5 = v13[1];\n        *v9 = *v13;\n        v9[1] = v5;\n        sub_408132(a1, v13);\n      }\n      else\n      {\n        *v9 = 0LL;\n      }\n    }\n    result = v12;\n  }\n  else\n  {\n    for ( i = v9; ; i = (_QWORD *)i[1] )\n    {\n      if ( !i[1] )\n        return 0LL;\n      if ( *(_QWORD *)i[1] == a2 || (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(a1 + 56))(a2, *(_QWORD *)i[1]) )\n        break;\n    }\n    v10 = *(_QWORD *)i[1];\n    if ( a4 )\n    {\n      v11 = (_QWORD *)i[1];\n      i[1] = v11[1];\n      sub_408132(a1, v11);\n    }\n    result = v10;\n  }\n  return result;\n}\n"], [4227836, "sub_4082FC", "__int64 __fastcall sub_4082FC(__int64 a1, __int64 a2, char a3)\n{\n  __int64 *i; // [rsp+20h] [rbp-30h]\n  __int64 *j; // [rsp+28h] [rbp-28h]\n  __int64 v7; // [rsp+30h] [rbp-20h]\n  __int64 v8; // [rsp+30h] [rbp-20h]\n  _QWORD *v9; // [rsp+38h] [rbp-18h]\n  _QWORD *v10; // [rsp+38h] [rbp-18h]\n  __int64 *v11; // [rsp+40h] [rbp-10h]\n  _QWORD *v12; // [rsp+48h] [rbp-8h]\n\n  for ( i = *(__int64 **)a2; *(_QWORD *)(a2 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      for ( j = (__int64 *)i[1]; j; j = v11 )\n      {\n        v7 = *j;\n        v9 = (_QWORD *)sub_4076C2(a1, *j);\n        v11 = (__int64 *)j[1];\n        if ( *v9 )\n        {\n          j[1] = v9[1];\n          v9[1] = j;\n        }\n        else\n        {\n          *v9 = v7;\n          ++*(_QWORD *)(a1 + 24);\n          sub_408132(a1, j);\n        }\n      }\n      v8 = *i;\n      i[1] = 0LL;\n      if ( !a3 )\n      {\n        v10 = (_QWORD *)sub_4076C2(a1, v8);\n        if ( *v10 )\n        {\n          v12 = sub_4080E7(a1);\n          if ( !v12 )\n            return 0LL;\n          *v12 = v8;\n          v12[1] = v10[1];\n          v10[1] = v12;\n        }\n        else\n        {\n          *v10 = v8;\n          ++*(_QWORD *)(a1 + 24);\n        }\n        *i = 0LL;\n        --*(_QWORD *)(a2 + 24);\n      }\n    }\n  }\n  return 1LL;\n}\n"], [4228298, "sub_4084CA", "__int64 __fastcall sub_4084CA(__int64 a1, __int64 a2)\n{\n  __int64 result; // rax\n  unsigned __int64 nmemb; // [rsp+10h] [rbp-60h]\n  void *v4; // [rsp+20h] [rbp-50h] BYREF\n  __int64 v5; // [rsp+28h] [rbp-48h]\n  unsigned __int64 v6; // [rsp+30h] [rbp-40h]\n  __int64 v7; // [rsp+38h] [rbp-38h]\n  __int64 v8; // [rsp+40h] [rbp-30h]\n  __int64 v9; // [rsp+48h] [rbp-28h]\n  __int64 v10; // [rsp+50h] [rbp-20h]\n  __int64 v11; // [rsp+58h] [rbp-18h]\n  __int64 v12; // [rsp+60h] [rbp-10h]\n  __int64 v13; // [rsp+68h] [rbp-8h]\n\n  nmemb = sub_407C68(a2, *(_QWORD *)(a1 + 40));\n  if ( !nmemb )\n    return 0LL;\n  if ( *(_QWORD *)(a1 + 16) == nmemb )\n    return 1LL;\n  v4 = calloc(nmemb, 0x10uLL);\n  if ( !v4 )\n    return 0LL;\n  v6 = nmemb;\n  v5 = (__int64)v4 + 16 * nmemb;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = *(_QWORD *)(a1 + 40);\n  v10 = *(_QWORD *)(a1 + 48);\n  v11 = *(_QWORD *)(a1 + 56);\n  v12 = *(_QWORD *)(a1 + 64);\n  v13 = *(_QWORD *)(a1 + 72);\n  if ( (unsigned __int8)sub_4082FC((__int64)&v4, a1, 0) )\n  {\n    free(*(void **)a1);\n    *(_QWORD *)a1 = v4;\n    *(_QWORD *)(a1 + 8) = v5;\n    *(_QWORD *)(a1 + 16) = v6;\n    *(_QWORD *)(a1 + 24) = v7;\n    *(_QWORD *)(a1 + 72) = v13;\n    result = 1LL;\n  }\n  else\n  {\n    *(_QWORD *)(a1 + 72) = v13;\n    if ( (unsigned __int8)sub_4082FC(a1, (__int64)&v4, 1) != 1 || (unsigned __int8)sub_4082FC(a1, (__int64)&v4, 0) != 1 )\n      abort();\n    free(v4);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4228814, "sub_4086CE", "__int64 __fastcall sub_4086CE(_QWORD *a1, __int64 a2, _QWORD *a3)\n{\n  __int64 result; // rax\n  __int64 v4; // rax\n  float v5; // xmm0_4\n  __int64 v6; // rdx\n  __int64 v7; // rax\n  float v8; // xmm1_4\n  __int64 v9; // rdx\n  __int64 v10; // rax\n  float v11; // xmm0_4\n  __int64 v12; // rdx\n  __int64 v13; // rax\n  float v14; // xmm1_4\n  __int64 v15; // rdx\n  __int64 v16; // rax\n  float v17; // xmm0_4\n  __int64 v18; // rdx\n  float v19; // xmm0_4\n  __int64 v20; // rax\n  float v21; // xmm0_4\n  __int64 v22; // rdx\n  __int64 v23; // rax\n  __int64 *v25; // [rsp+30h] [rbp-20h] BYREF\n  __int64 v26; // [rsp+38h] [rbp-18h]\n  __int64 v27; // [rsp+40h] [rbp-10h]\n  _QWORD *v28; // [rsp+48h] [rbp-8h]\n\n  if ( !a2 )\n    abort();\n  v26 = sub_408167((__int64)a1, a2, &v25, 0);\n  if ( v26 )\n  {\n    if ( a3 )\n      *a3 = v26;\n    result = 0LL;\n  }\n  else\n  {\n    v4 = a1[3];\n    if ( v4 < 0 )\n    {\n      v6 = a1[3] & 1LL | ((unsigned __int64)v4 >> 1);\n      v5 = (float)(int)v6 + (float)(int)v6;\n    }\n    else\n    {\n      v5 = (float)(int)v4;\n    }\n    v7 = a1[2];\n    if ( v7 < 0 )\n    {\n      v9 = a1[2] & 1LL | ((unsigned __int64)v7 >> 1);\n      v8 = (float)(int)v9 + (float)(int)v9;\n    }\n    else\n    {\n      v8 = (float)(int)v7;\n    }\n    if ( v5 > (float)(v8 * *(float *)(a1[5] + 8LL)) )\n    {\n      sub_407B70((__int64)a1);\n      v10 = a1[3];\n      if ( v10 < 0 )\n      {\n        v12 = a1[3] & 1LL | ((unsigned __int64)v10 >> 1);\n        v11 = (float)(int)v12 + (float)(int)v12;\n      }\n      else\n      {\n        v11 = (float)(int)v10;\n      }\n      v13 = a1[2];\n      if ( v13 < 0 )\n      {\n        v15 = a1[2] & 1LL | ((unsigned __int64)v13 >> 1);\n        v14 = (float)(int)v15 + (float)(int)v15;\n      }\n      else\n      {\n        v14 = (float)(int)v13;\n      }\n      if ( v11 > (float)(v14 * *(float *)(a1[5] + 8LL)) )\n      {\n        v27 = a1[5];\n        if ( *(_BYTE *)(v27 + 16) )\n        {\n          v16 = a1[2];\n          if ( v16 < 0 )\n          {\n            v18 = a1[2] & 1LL | ((unsigned __int64)v16 >> 1);\n            v17 = (float)(int)v18 + (float)(int)v18;\n          }\n          else\n          {\n            v17 = (float)(int)v16;\n          }\n          v19 = v17 * *(float *)(v27 + 12);\n        }\n        else\n        {\n          v20 = a1[2];\n          if ( v20 < 0 )\n          {\n            v22 = a1[2] & 1LL | ((unsigned __int64)v20 >> 1);\n            v21 = (float)(int)v22 + (float)(int)v22;\n          }\n          else\n          {\n            v21 = (float)(int)v20;\n          }\n          v19 = (float)(v21 * *(float *)(v27 + 12)) * *(float *)(v27 + 8);\n        }\n        if ( v19 >= 1.8446744e19 )\n          return 0xFFFFFFFFLL;\n        if ( v19 >= 9.223372e18 )\n          v23 = (unsigned int)(int)(float)(v19 - 9.223372e18) ^ 0x8000000000000000LL;\n        else\n          v23 = (unsigned int)(int)v19;\n        if ( (unsigned __int8)sub_4084CA((__int64)a1, v23) != 1 )\n          return 0xFFFFFFFFLL;\n        if ( sub_408167((__int64)a1, a2, &v25, 0) )\n          abort();\n      }\n    }\n    if ( *v25 )\n    {\n      v28 = sub_4080E7((__int64)a1);\n      if ( v28 )\n      {\n        *v28 = a2;\n        v28[1] = v25[1];\n        v25[1] = (__int64)v28;\n        ++a1[4];\n        result = 1LL;\n      }\n      else\n      {\n        result = 0xFFFFFFFFLL;\n      }\n    }\n    else\n    {\n      *v25 = a2;\n      ++a1[4];\n      ++a1[3];\n      result = 1LL;\n    }\n  }\n  return result;\n}\n"], [4229608, "sub_4089E8", "__int64 __fastcall sub_4089E8(_QWORD *a1, __int64 a2)\n{\n  int v3; // [rsp+14h] [rbp-Ch]\n  __int64 v4; // [rsp+18h] [rbp-8h] BYREF\n\n  v3 = sub_4086CE(a1, a2, &v4);\n  if ( v3 == -1 )\n    return 0LL;\n  if ( v3 )\n    return a2;\n  return v4;\n}\n"], [4229681, "sub_408A31", "__int64 __fastcall sub_408A31(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rax\n  float v4; // xmm0_4\n  __int64 v5; // rdx\n  __int64 v6; // rax\n  float v7; // xmm1_4\n  __int64 v8; // rdx\n  __int64 v9; // rax\n  float v10; // xmm0_4\n  __int64 v11; // rdx\n  __int64 v12; // rax\n  float v13; // xmm1_4\n  __int64 v14; // rdx\n  __int64 v15; // rax\n  float v16; // xmm0_4\n  __int64 v17; // rdx\n  float v18; // xmm0_4\n  __int64 v19; // rax\n  __int64 v20; // rax\n  float v21; // xmm0_4\n  __int64 v22; // rdx\n  float v23; // xmm0_4\n  _QWORD *v24; // [rsp+10h] [rbp-30h] BYREF\n  void *ptr; // [rsp+18h] [rbp-28h]\n  __int64 v26; // [rsp+20h] [rbp-20h]\n  __int64 v27; // [rsp+28h] [rbp-18h]\n  __int64 v28; // [rsp+30h] [rbp-10h]\n  void *v29; // [rsp+38h] [rbp-8h]\n\n  v26 = sub_408167(a1, a2, &v24, 1);\n  if ( !v26 )\n    return 0LL;\n  --*(_QWORD *)(a1 + 32);\n  if ( !*v24 )\n  {\n    v3 = --*(_QWORD *)(a1 + 24);\n    if ( v3 < 0 )\n    {\n      v5 = *(_QWORD *)(a1 + 24) & 1LL | ((unsigned __int64)v3 >> 1);\n      v4 = (float)(int)v5 + (float)(int)v5;\n    }\n    else\n    {\n      v4 = (float)(int)v3;\n    }\n    v6 = *(_QWORD *)(a1 + 16);\n    if ( v6 < 0 )\n    {\n      v8 = *(_QWORD *)(a1 + 16) & 1LL | ((unsigned __int64)v6 >> 1);\n      v7 = (float)(int)v8 + (float)(int)v8;\n    }\n    else\n    {\n      v7 = (float)(int)v6;\n    }\n    if ( (float)(v7 * **(float **)(a1 + 40)) > v4 )\n    {\n      sub_407B70(a1);\n      v9 = *(_QWORD *)(a1 + 24);\n      if ( v9 < 0 )\n      {\n        v11 = *(_QWORD *)(a1 + 24) & 1LL | ((unsigned __int64)v9 >> 1);\n        v10 = (float)(int)v11 + (float)(int)v11;\n      }\n      else\n      {\n        v10 = (float)(int)v9;\n      }\n      v12 = *(_QWORD *)(a1 + 16);\n      if ( v12 < 0 )\n      {\n        v14 = *(_QWORD *)(a1 + 16) & 1LL | ((unsigned __int64)v12 >> 1);\n        v13 = (float)(int)v14 + (float)(int)v14;\n      }\n      else\n      {\n        v13 = (float)(int)v12;\n      }\n      if ( (float)(v13 * **(float **)(a1 + 40)) > v10 )\n      {\n        v27 = *(_QWORD *)(a1 + 40);\n        if ( *(_BYTE *)(v27 + 16) )\n        {\n          v15 = *(_QWORD *)(a1 + 16);\n          if ( v15 < 0 )\n          {\n            v17 = *(_QWORD *)(a1 + 16) & 1LL | ((unsigned __int64)v15 >> 1);\n            v16 = (float)(int)v17 + (float)(int)v17;\n          }\n          else\n          {\n            v16 = (float)(int)v15;\n          }\n          v18 = v16 * *(float *)(v27 + 4);\n          if ( v18 >= 9.223372e18 )\n            v19 = (unsigned int)(int)(float)(v18 - 9.223372e18) ^ 0x8000000000000000LL;\n          else\n            v19 = (unsigned int)(int)v18;\n        }\n        else\n        {\n          v20 = *(_QWORD *)(a1 + 16);\n          if ( v20 < 0 )\n          {\n            v22 = *(_QWORD *)(a1 + 16) & 1LL | ((unsigned __int64)v20 >> 1);\n            v21 = (float)(int)v22 + (float)(int)v22;\n          }\n          else\n          {\n            v21 = (float)(int)v20;\n          }\n          v23 = (float)(v21 * *(float *)(v27 + 4)) * *(float *)(v27 + 8);\n          if ( v23 >= 9.223372e18 )\n            v19 = (unsigned int)(int)(float)(v23 - 9.223372e18) ^ 0x8000000000000000LL;\n          else\n            v19 = (unsigned int)(int)v23;\n        }\n        v28 = v19;\n        if ( (unsigned __int8)sub_4084CA(a1, v19) != 1 )\n        {\n          for ( ptr = *(void **)(a1 + 72); ptr; ptr = v29 )\n          {\n            v29 = (void *)*((_QWORD *)ptr + 1);\n            free(ptr);\n          }\n          *(_QWORD *)(a1 + 72) = 0LL;\n        }\n      }\n    }\n  }\n  return v26;\n}\n"], [4230368, "sub_408CE0", "__int64 __fastcall sub_408CE0(__int64 a1, __int64 a2)\n{\n  __int64 v3; // [rsp+8h] [rbp-18h]\n  __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v3 = a1;\n  v4 = a2 + 20;\n  *(_BYTE *)(a2 + 20) = 0;\n  if ( a1 >= 0 )\n  {\n    do\n    {\n      *(_BYTE *)--v4 = (char)v3 % 10 + 48;\n      v3 /= 10LL;\n    }\n    while ( v3 );\n  }\n  else\n  {\n    do\n    {\n      *(_BYTE *)--v4 = 48 - (char)v3 % 10;\n      v3 /= 10LL;\n    }\n    while ( v3 );\n    *(_BYTE *)--v4 = 45;\n  }\n  return v4;\n}\n"], [4230674, "sub_408E12", "__int64 sub_408E12()\n{\n  __int64 result; // rax\n  char *endptr; // [rsp+0h] [rbp-20h] BYREF\n  __int64 v2; // [rsp+8h] [rbp-18h]\n  char *nptr; // [rsp+10h] [rbp-10h]\n  __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v2 = 200809LL;\n  nptr = getenv(\"_POSIX2_VERSION\");\n  if ( nptr )\n  {\n    if ( *nptr )\n    {\n      v4 = strtol(nptr, &endptr, 10);\n      if ( !*endptr )\n        v2 = v4;\n    }\n  }\n  if ( v2 < (__int64)0xFFFFFFFF80000000LL )\n    return 0x80000000LL;\n  result = 0x7FFFFFFFLL;\n  if ( v2 <= 0x7FFFFFFF )\n    result = v2;\n  return result;\n}\n"], [4230806, "sub_408E96", "char *__fastcall sub_408E96(const char *a1)\n{\n  char *v1; // rax\n  char *result; // rax\n  char *s; // [rsp+8h] [rbp-18h]\n  char *v4; // [rsp+10h] [rbp-10h]\n  char *s1; // [rsp+18h] [rbp-8h]\n\n  s = (char *)a1;\n  if ( !a1 )\n  {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\", 1uLL, 0x37uLL, stderr);\n    abort();\n  }\n  v4 = strrchr(a1, 47);\n  if ( v4 )\n    v1 = v4 + 1;\n  else\n    v1 = (char *)a1;\n  s1 = v1;\n  if ( v1 - a1 > 6 && !strncmp(v1 - 7, \"/.libs/\", 7uLL) )\n  {\n    s = s1;\n    if ( !strncmp(s1, \"lt-\", 3uLL) )\n    {\n      s = s1 + 3;\n      program_invocation_short_name = (__int64)(s1 + 3);\n    }\n  }\n  qword_610348 = (__int64)s;\n  result = s;\n  program_invocation_name = (__int64)s;\n  return result;\n}\n"], [4231037, "sub_408F7D", "__int64 __fastcall sub_408F7D(unsigned int a1, __int64 a2)\n{\n  return sub_40A42C(a1, 6LL, a2);\n}\n"], [4231073, "sub_408FA1", "__int64 __fastcall sub_408FA1(__int64 a1)\n{\n  return sub_408F7D(0, a1);\n}\n"], [4231104, "sub_408FC0", "__int64 __fastcall sub_408FC0(__int64 *a1)\n{\n  __int64 *v1; // rax\n  int v3; // [rsp+14h] [rbp-Ch]\n  __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v3 = *__errno_location();\n  if ( a1 )\n    v1 = a1;\n  else\n    v1 = &qword_610360;\n  v4 = sub_40B2B5(v1, 56LL);\n  *__errno_location() = v3;\n  return v4;\n}\n"], [4231177, "sub_409009", "__int64 __fastcall sub_409009(__int64 *a1)\n{\n  __int64 *v1; // rax\n\n  if ( a1 )\n    v1 = a1;\n  else\n    v1 = &qword_610360;\n  return *(unsigned int *)v1;\n}\n"], [4231207, "sub_409027", "__int64 *__fastcall sub_409027(__int64 *a1, int a2)\n{\n  __int64 *result; // rax\n\n  if ( a1 )\n    result = a1;\n  else\n    result = &qword_610360;\n  *(_DWORD *)result = a2;\n  return result;\n}\n"], [4231243, "sub_40904B", "__int64 __fastcall sub_40904B(__int64 *a1, unsigned __int8 a2, char a3)\n{\n  __int64 *v3; // rax\n  unsigned int v5; // [rsp+24h] [rbp-Ch]\n\n  if ( a1 )\n    v3 = a1;\n  else\n    v3 = &qword_610360;\n  v5 = (*((_DWORD *)v3 + (a2 >> 5) + 2) >> (a2 & 0x1F)) & 1;\n  *((_DWORD *)v3 + (a2 >> 5) + 2) ^= (v5 ^ a3 & 1) << (a2 & 0x1F);\n  return v5;\n}\n"], [4231379, "sub_4090D3", "__int64 __fastcall sub_4090D3(__int64 *a1, int a2)\n{\n  __int64 *v3; // [rsp+4h] [rbp-18h]\n  unsigned int v4; // [rsp+18h] [rbp-4h]\n\n  v3 = a1;\n  if ( !a1 )\n    v3 = &qword_610360;\n  v4 = *((_DWORD *)v3 + 1);\n  *((_DWORD *)v3 + 1) = a2;\n  return v4;\n}\n"], [4231430, "sub_409106", "__int64 *__fastcall sub_409106(__int64 *a1, __int64 a2, __int64 a3)\n{\n  __int64 *result; // rax\n  __int64 *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = a1;\n  if ( !a1 )\n    v4 = &qword_610360;\n  *(_DWORD *)v4 = 8;\n  if ( !a2 || !a3 )\n    abort();\n  v4[5] = a2;\n  result = v4;\n  v4[6] = a3;\n  return result;\n}\n"], [4231520, "sub_409160", "_QWORD *__fastcall sub_409160(_QWORD *a1, int a2)\n{\n  __int64 v3[7]; // [rsp+10h] [rbp-40h] BYREF\n\n  memset(v3, 0, sizeof(v3));\n  if ( a2 == 8 )\n    abort();\n  LODWORD(v3[0]) = a2;\n  *a1 = v3[0];\n  a1[1] = v3[1];\n  a1[2] = v3[2];\n  a1[3] = v3[3];\n  a1[4] = v3[4];\n  a1[5] = v3[5];\n  a1[6] = v3[6];\n  return a1;\n}\n"], [4231640, "sub_4091D8", "char *__fastcall sub_4091D8(const char *a1, int a2)\n{\n  char *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = gettext(a1);\n  if ( v3 == a1 && a2 == 7 )\n    v3 = (char *)L\"\\\"`'\";\n  return v3;\n}\n"], [4231701, "sub_409215", "unsigned __int64 __fastcall sub_409215(__int64 a1, unsigned __int64 a2, __int64 a3, size_t a4, unsigned int a5, int a6, __int64 a7, char *a8, char *a9)\n{\n  int v9; // eax\n  bool v10; // al\n  int v11; // eax\n  char v20; // [rsp+65h] [rbp-6Bh]\n  bool v21; // [rsp+66h] [rbp-6Ah]\n  unsigned __int8 v22; // [rsp+67h] [rbp-69h]\n  char v23; // [rsp+68h] [rbp-68h]\n  char v24; // [rsp+69h] [rbp-67h]\n  bool v25; // [rsp+6Ah] [rbp-66h]\n  bool v26; // [rsp+6Bh] [rbp-65h]\n  wchar_t pwc; // [rsp+6Ch] [rbp-64h] BYREF\n  __int64 i; // [rsp+70h] [rbp-60h]\n  unsigned __int64 v29; // [rsp+78h] [rbp-58h]\n  char *s; // [rsp+80h] [rbp-50h]\n  size_t n; // [rsp+88h] [rbp-48h]\n  unsigned __int64 v32; // [rsp+90h] [rbp-40h]\n  unsigned __int64 j; // [rsp+98h] [rbp-38h]\n  size_t v34; // [rsp+A0h] [rbp-30h]\n  unsigned __int64 v35; // [rsp+A8h] [rbp-28h]\n  mbstate_t p; // [rsp+B0h] [rbp-20h] BYREF\n  unsigned __int64 v37; // [rsp+B8h] [rbp-18h]\n\n  v37 = __readfsqword(0x28u);\n  v29 = 0LL;\n  s = 0LL;\n  n = 0LL;\n  v20 = 0;\n  v26 = __ctype_get_mb_cur_max() == 1;\n  v21 = (a6 & 2) != 0;\n  if ( a5 == 3 )\n    goto LABEL_11;\n  if ( a5 > 3 )\n  {\n    if ( a5 == 5 )\n    {\n      v20 = 1;\n      v21 = 0;\n      goto LABEL_33;\n    }\n    if ( a5 >= 5 )\n    {\n      if ( a5 > 8 )\n        abort();\n      if ( a5 != 8 )\n      {\n        a8 = sub_4091D8((const char *)L\"`'\", a5);\n        a9 = sub_4091D8((const char *)L\"'\", a5);\n      }\n      if ( (a6 & 2) == 0 )\n      {\n        for ( s = a8; *s; ++s )\n        {\n          if ( v29 < a2 )\n            *(_BYTE *)(v29 + a1) = *s;\n          ++v29;\n        }\n      }\n      v20 = 1;\n      s = a9;\n      n = strlen(a9);\n      goto LABEL_33;\n    }\n    a5 = 3;\n    v21 = 1;\nLABEL_11:\n    if ( !v21 )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(a1 + v29) = 34;\n      ++v29;\n    }\n    v20 = 1;\n    s = (char *)L\"\\\"`'\";\n    n = 1LL;\n    goto LABEL_33;\n  }\n  if ( a5 == 1 )\n  {\n    a5 = 2;\n    v21 = 1;\n    goto LABEL_27;\n  }\n  if ( a5 > 1 )\n  {\nLABEL_27:\n    if ( !v21 )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(a1 + v29) = 39;\n      ++v29;\n    }\n    s = (_BYTE *)(L\"\\\"`'\" + 4);\n    n = 1LL;\n    goto LABEL_33;\n  }\n  v21 = 0;\nLABEL_33:\n  for ( i = 0LL; a4 == -1LL ? *(_BYTE *)(a3 + i) != 0 : i != a4; ++i )\n  {\n    v24 = 0;\n    if ( v20 && n && i + n <= a4 && !memcmp((const void *)(a3 + i), s, n) )\n    {\n      if ( v21 )\n        return sub_409215(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n      v24 = 1;\n    }\n    v22 = *(_BYTE *)(a3 + i);\n    if ( v22 > 0x3Au )\n    {\n      if ( v22 == 94 )\n        goto LABEL_144;\n      if ( v22 > 0x5Eu )\n      {\n        if ( v22 <= 0x7Au )\n        {\n          if ( v22 >= 0x61u || v22 == 95 )\n            goto LABEL_206;\n          goto LABEL_144;\n        }\n        if ( v22 != 124 )\n        {\n          if ( v22 < 0x7Cu || v22 == 125 )\n          {\n            if ( a4 == -1LL )\n              v10 = *(_BYTE *)(a3 + 1) != 0;\n            else\n              v10 = a4 != 1;\n            if ( v10 )\n              goto LABEL_206;\n          }\n          else if ( v22 != 126 )\n          {\nLABEL_157:\n            if ( v26 )\n            {\n              v32 = 1LL;\n              v25 = ((*__ctype_b_loc())[v22] & 0x4000) != 0;\n            }\n            else\n            {\n              memset(&p, 0, sizeof(p));\n              v32 = 0LL;\n              v25 = 1;\n              if ( a4 == -1LL )\n                a4 = strlen((const char *)a3);\n              do\n              {\n                v34 = mbrtowc(&pwc, (const char *)(v32 + i + a3), a4 - (v32 + i), &p);\n                if ( !v34 )\n                  break;\n                if ( v34 == -1LL )\n                {\n                  v25 = 0;\n                  break;\n                }\n                if ( v34 == -2LL )\n                {\n                  v25 = 0;\n                  while ( i + v32 < a4 && *(_BYTE *)(v32 + i + a3) )\n                    ++v32;\n                  break;\n                }\n                if ( v21 && a5 == 2 )\n                {\n                  for ( j = 1LL; j < v34; ++j )\n                  {\n                    v11 = *(char *)(j + v32 + i + a3);\n                    if ( v11 == 94 )\n                      return sub_409215(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    if ( v11 > 94 )\n                    {\n                      if ( v11 == 96 || v11 == 124 )\n                        return sub_409215(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    }\n                    else if ( (unsigned int)(v11 - 91) <= 1 )\n                    {\n                      return sub_409215(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    }\n                  }\n                }\n                if ( !iswprint(pwc) )\n                  v25 = 0;\n                v32 += v34;\n              }\n              while ( !mbsinit(&p) );\n            }\n            if ( v32 > 1 || v20 && !v25 )\n            {\n              v35 = i + v32;\n              while ( 1 )\n              {\n                if ( v20 && !v25 )\n                {\n                  if ( v21 )\n                    return sub_409215(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                  if ( v29 < a2 )\n                    *(_BYTE *)(a1 + v29) = 92;\n                  if ( ++v29 < a2 )\n                    *(_BYTE *)(v29 + a1) = (v22 >> 6) + 48;\n                  if ( ++v29 < a2 )\n                    *(_BYTE *)(v29 + a1) = ((v22 >> 3) & 7) + 48;\n                  ++v29;\n                  v22 = (v22 & 7) + 48;\n                }\n                else if ( v24 )\n                {\n                  if ( v29 < a2 )\n                    *(_BYTE *)(a1 + v29) = 92;\n                  ++v29;\n                  v24 = 0;\n                }\n                if ( i + 1 >= v35 )\n                  break;\n                if ( v29 < a2 )\n                  *(_BYTE *)(v29 + a1) = v22;\n                ++v29;\n                ++i;\n                v22 = *(_BYTE *)(a3 + i);\n              }\n              goto LABEL_215;\n            }\n            goto LABEL_206;\n          }\n          goto LABEL_143;\n        }\nLABEL_144:\n        if ( a5 == 2 && v21 )\n          return sub_409215(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        goto LABEL_206;\n      }\n      if ( v22 > 0x5Au )\n      {\n        if ( v22 == 92 )\n        {\n          v23 = *(_BYTE *)(a3 + i);\n          if ( v20 && v21 && n )\n            goto LABEL_215;\n          goto LABEL_134;\n        }\n        if ( v22 <= 0x5Cu )\n          goto LABEL_144;\n      }\n      else\n      {\n        if ( v22 >= 0x41u )\n          goto LABEL_206;\n        if ( v22 <= 0x3Eu )\n          goto LABEL_144;\n        if ( v22 != 63 )\n          goto LABEL_157;\n        if ( a5 == 2 )\n        {\n          if ( v21 )\n            return sub_409215(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        }\n        else if ( a5 == 3 && (a6 & 4) != 0 && i + 2 < a4 && *(_BYTE *)(i + 1 + a3) == 63 )\n        {\n          v9 = *(char *)(i + 2 + a3);\n          if ( v9 != 45 )\n          {\n            if ( v9 > 45 )\n            {\n              if ( v9 != 47 && (v9 < 47 || (unsigned int)(v9 - 60) > 2) )\n                goto LABEL_206;\n            }\n            else if ( v9 != 33 && (v9 < 33 || (unsigned int)(v9 - 39) > 2) )\n            {\n              goto LABEL_206;\n            }\n          }\n          if ( v21 )\n            return sub_409215(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          v22 = *(_BYTE *)(i + 2 + a3);\n          i += 2LL;\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 63;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 34;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 34;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 63;\n          ++v29;\n        }\n      }\n    }\n    else\n    {\n      if ( v22 >= 0x2Bu )\n        goto LABEL_206;\n      if ( v22 > 0x22u )\n      {\n        if ( v22 != 38 )\n        {\n          if ( v22 > 0x26u )\n          {\n            if ( v22 == 39 )\n            {\n              if ( a5 == 2 )\n              {\n                if ( v21 )\n                  return sub_409215(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                if ( v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 39;\n                if ( ++v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 92;\n                if ( ++v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 39;\n                ++v29;\n              }\n              goto LABEL_206;\n            }\n            goto LABEL_144;\n          }\n          if ( v22 != 36 )\n          {\n            if ( v22 > 0x24u )\n              goto LABEL_206;\nLABEL_143:\n            if ( i )\n              goto LABEL_206;\n          }\n        }\n        goto LABEL_144;\n      }\n      if ( v22 >= 0x20u )\n        goto LABEL_144;\n      if ( v22 == 9 )\n      {\n        v23 = 116;\n        goto LABEL_134;\n      }\n      if ( v22 > 9u )\n      {\n        if ( v22 == 11 )\n        {\n          v23 = 118;\n        }\n        else\n        {\n          if ( v22 < 0xBu )\n          {\n            v23 = 110;\n            goto LABEL_134;\n          }\n          if ( v22 == 12 )\n          {\n            v23 = 102;\n          }\n          else\n          {\n            if ( v22 != 13 )\n              goto LABEL_157;\n            v23 = 114;\nLABEL_134:\n            if ( a5 == 2 && v21 )\n              return sub_409215(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          }\n        }\nLABEL_136:\n        if ( v20 )\n        {\n          v22 = v23;\nLABEL_211:\n          if ( v21 )\n            return sub_409215(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 92;\n          ++v29;\n          goto LABEL_215;\n        }\n        goto LABEL_206;\n      }\n      if ( v22 == 7 )\n      {\n        v23 = 97;\n        goto LABEL_136;\n      }\n      if ( v22 > 7u )\n      {\n        v23 = 98;\n        goto LABEL_136;\n      }\n      if ( v22 )\n        goto LABEL_157;\n      if ( v20 )\n      {\n        if ( v21 )\n          return sub_409215(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        if ( v29 < a2 )\n          *(_BYTE *)(a1 + v29) = 92;\n        ++v29;\n        if ( i + 1 < a4 && *(char *)(i + 1 + a3) > 47 && *(char *)(i + 1 + a3) <= 57 )\n        {\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 48;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 48;\n          ++v29;\n        }\n        v22 = 48;\n      }\n      else if ( (a6 & 1) != 0 )\n      {\n        continue;\n      }\n    }\nLABEL_206:\n    if ( (v20 == 1 || v21) && a7 && (*(_DWORD *)(4LL * (v22 >> 5) + a7) & (1 << (v22 & 0x1F))) != 0 || v24 == 1 )\n      goto LABEL_211;\nLABEL_215:\n    if ( v29 < a2 )\n      *(_BYTE *)(v29 + a1) = v22;\n    ++v29;\n  }\n  if ( !v29 && a5 == 2 && v21 )\n    return sub_409215(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n  if ( s && !v21 )\n  {\n    while ( *s )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(v29 + a1) = *s;\n      ++v29;\n      ++s;\n    }\n  }\n  if ( v29 < a2 )\n    *(_BYTE *)(a1 + v29) = 0;\n  return v29;\n}\n"], [4234848, "sub_409E60", "unsigned __int64 __fastcall sub_409E60(__int64 a1, unsigned __int64 a2, __int64 a3, size_t a4, __int64 *a5)\n{\n  __int64 *v5; // rax\n  int v9; // [rsp+4Ch] [rbp-14h]\n  __int64 *v10; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+58h] [rbp-8h]\n\n  if ( a5 )\n    v5 = a5;\n  else\n    v5 = &qword_610360;\n  v10 = v5;\n  v9 = *__errno_location();\n  v11 = sub_409215(\n          a1,\n          a2,\n          a3,\n          a4,\n          *(_DWORD *)v10,\n          *((_DWORD *)v10 + 1),\n          (__int64)(v10 + 1),\n          (char *)v10[5],\n          (char *)v10[6]);\n  *__errno_location() = v9;\n  return v11;\n}\n"], [4235008, "sub_409F00", "__int64 __fastcall sub_409F00(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_409F32(a1, a2, 0LL, a3);\n}\n"], [4235058, "sub_409F32", "__int64 __fastcall sub_409F32(__int64 a1, size_t a2, _QWORD *a3, __int64 *a4)\n{\n  __int64 *v4; // rax\n  int v7; // [rsp+40h] [rbp-20h]\n  int v8; // [rsp+44h] [rbp-1Ch]\n  __int64 *v9; // [rsp+48h] [rbp-18h]\n  unsigned __int64 v10; // [rsp+50h] [rbp-10h]\n  __int64 v11; // [rsp+58h] [rbp-8h]\n\n  if ( a4 )\n    v4 = a4;\n  else\n    v4 = &qword_610360;\n  v9 = v4;\n  v7 = *__errno_location();\n  v8 = *((_DWORD *)v9 + 1) | (a3 == 0LL);\n  v10 = sub_409215(0LL, 0LL, a1, a2, *(_DWORD *)v9, v8, (__int64)(v9 + 1), (char *)v9[5], (char *)v9[6]) + 1;\n  v11 = sub_40B177(v10);\n  sub_409215(v11, v10, a1, a2, *(_DWORD *)v9, v8, (__int64)(v9 + 1), (char *)v9[5], (char *)v9[6]);\n  *__errno_location() = v7;\n  if ( a3 )\n    *a3 = v10 - 1;\n  return v11;\n}\n"], [4235358, "sub_40A05E", "void sub_40A05E()\n{\n  unsigned int i; // [rsp+4h] [rbp-Ch]\n  void **ptr; // [rsp+8h] [rbp-8h]\n\n  ptr = (void **)off_6102B0;\n  for ( i = 1; i < dword_610290; ++i )\n    free(ptr[2 * i + 1]);\n  if ( ptr[1] != &unk_6103A0 )\n  {\n    free(ptr[1]);\n    qword_6102A0 = 256LL;\n    off_6102A8 = &unk_6103A0;\n  }\n  if ( ptr != (void **)&qword_6102A0 )\n  {\n    free(ptr);\n    off_6102B0 = &qword_6102A0;\n  }\n  dword_610290 = 1;\n}\n"], [4235529, "sub_40A109", "void *__fastcall sub_40A109(int a1, __int64 a2, size_t a3, __int64 a4)\n{\n  __int64 *v4; // rax\n  void *v5; // rdx\n  bool v9; // [rsp+4Bh] [rbp-45h]\n  int v10; // [rsp+4Ch] [rbp-44h]\n  int v11; // [rsp+54h] [rbp-3Ch]\n  __int64 *v12; // [rsp+58h] [rbp-38h]\n  void *ptr; // [rsp+60h] [rbp-30h]\n  __int64 v14; // [rsp+68h] [rbp-28h]\n  unsigned __int64 v15; // [rsp+70h] [rbp-20h]\n  unsigned __int64 v16; // [rsp+70h] [rbp-20h]\n  unsigned __int64 v17; // [rsp+78h] [rbp-18h]\n\n  v10 = *__errno_location();\n  v12 = off_6102B0;\n  if ( a1 < 0 )\n    abort();\n  if ( dword_610290 <= (unsigned int)a1 )\n  {\n    v14 = (unsigned int)(a1 + 1);\n    v9 = off_6102B0 == &qword_6102A0;\n    if ( off_6102B0 == &qword_6102A0 )\n      v4 = 0LL;\n    else\n      v4 = off_6102B0;\n    v12 = (__int64 *)sub_40B1C6(v4, 16 * v14);\n    off_6102B0 = v12;\n    if ( v9 )\n    {\n      v5 = off_6102A8;\n      *v12 = qword_6102A0;\n      v12[1] = (__int64)v5;\n    }\n    memset(&v12[2 * (unsigned int)dword_610290], 0, 16 * (v14 - (unsigned int)dword_610290));\n    dword_610290 = a1 + 1;\n  }\n  v15 = v12[2 * a1];\n  ptr = (void *)v12[2 * a1 + 1];\n  v11 = *(_DWORD *)(a4 + 4) | 1;\n  v17 = sub_409215((__int64)ptr, v15, a2, a3, *(_DWORD *)a4, v11, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 48));\n  if ( v15 <= v17 )\n  {\n    v16 = v17 + 1;\n    v12[2 * a1] = v17 + 1;\n    if ( ptr != &unk_6103A0 )\n      free(ptr);\n    ptr = (void *)sub_40B177(v16);\n    v12[2 * a1 + 1] = (__int64)ptr;\n    sub_409215((__int64)ptr, v16, a2, a3, *(_DWORD *)a4, v11, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 48));\n  }\n  *__errno_location() = v10;\n  return ptr;\n}\n"], [4236175, "sub_40A38F", "void *__fastcall sub_40A38F(int a1, __int64 a2)\n{\n  return sub_40A109(a1, a2, 0xFFFFFFFFFFFFFFFFLL, (__int64)&qword_610360);\n}\n"], [4236218, "sub_40A3BA", "void *__fastcall sub_40A3BA(int a1, __int64 a2, size_t a3)\n{\n  return sub_40A109(a1, a2, a3, (__int64)&qword_610360);\n}\n"], [4236262, "sub_40A3E6", "void *__fastcall sub_40A3E6(__int64 a1)\n{\n  return sub_40A38F(0, a1);\n}\n"], [4236293, "sub_40A405", "void *__fastcall sub_40A405(__int64 a1, size_t a2)\n{\n  return sub_40A3BA(0, a1, a2);\n}\n"], [4236332, "sub_40A42C", "void *__fastcall sub_40A42C(int a1, int a2, __int64 a3)\n{\n  _QWORD v5[8]; // [rsp+10h] [rbp-40h] BYREF\n\n  sub_409160(v5, a2);\n  return sub_40A109(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)v5);\n}\n"], [4236397, "sub_40A46D", "void *__fastcall sub_40A46D(int a1, int a2, __int64 a3, size_t a4)\n{\n  _QWORD v7[8]; // [rsp+20h] [rbp-40h] BYREF\n\n  sub_409160(v7, a2);\n  return sub_40A109(a1, a3, a4, (__int64)v7);\n}\n"], [4236460, "sub_40A4AC", "void *__fastcall sub_40A4AC(int a1, __int64 a2)\n{\n  return sub_40A42C(0, a1, a2);\n}\n"], [4236496, "sub_40A4D0", "void *__fastcall sub_40A4D0(int a1, __int64 a2, size_t a3)\n{\n  return sub_40A46D(0, a1, a2, a3);\n}\n"], [4236540, "sub_40A4FC", "void *__fastcall sub_40A4FC(__int64 a1, size_t a2, unsigned __int8 a3)\n{\n  __int64 v4[8]; // [rsp+20h] [rbp-40h] BYREF\n\n  v4[0] = qword_610360;\n  v4[1] = qword_610368;\n  v4[2] = qword_610370;\n  v4[3] = qword_610378;\n  v4[4] = qword_610380;\n  v4[5] = qword_610388;\n  v4[6] = qword_610390;\n  sub_40904B(v4, a3, 1);\n  return sub_40A109(0, a1, a2, (__int64)v4);\n}\n"], [4236688, "sub_40A590", "void *__fastcall sub_40A590(__int64 a1, unsigned __int8 a2)\n{\n  return sub_40A4FC(a1, 0xFFFFFFFFFFFFFFFFLL, a2);\n}\n"], [4236730, "sub_40A5BA", "void *__fastcall sub_40A5BA(__int64 a1)\n{\n  return sub_40A590(a1, 0x3Au);\n}\n"], [4236761, "sub_40A5D9", "void *__fastcall sub_40A5D9(__int64 a1, size_t a2)\n{\n  return sub_40A4FC(a1, a2, 0x3Au);\n}\n"], [4236803, "sub_40A603", "__int64 __fastcall sub_40A603(unsigned int a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  return sub_40A639(a1, a2, a3, a4, -1LL);\n}\n"], [4236857, "sub_40A639", "void *__fastcall sub_40A639(int a1, __int64 a2, __int64 a3, __int64 a4, size_t a5)\n{\n  __int64 v8[8]; // [rsp+30h] [rbp-40h] BYREF\n\n  v8[0] = qword_610360;\n  v8[1] = qword_610368;\n  v8[2] = qword_610370;\n  v8[3] = qword_610378;\n  v8[4] = qword_610380;\n  v8[5] = qword_610388;\n  v8[6] = qword_610390;\n  sub_409106(v8, a2, a3);\n  return sub_40A109(a1, a4, a5, (__int64)v8);\n}\n"], [4237008, "sub_40A6D0", "__int64 __fastcall sub_40A6D0(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_40A603(0, a1, a2, a3);\n}\n"], [4237055, "sub_40A6FF", "void *__fastcall sub_40A6FF(__int64 a1, __int64 a2, __int64 a3, size_t a4)\n{\n  return sub_40A639(0, a1, a2, a3, a4);\n}\n"], [4237113, "sub_40A739", "ssize_t __fastcall sub_40A739(int a1, void *a2, size_t a3)\n{\n  ssize_t result; // rax\n  ssize_t v5; // [rsp+28h] [rbp-8h]\n\nLABEL_1:\n  for ( result = read(a1, a2, a3); ; result = read(a1, a2, 0x7FFFE000uLL) )\n  {\n    v5 = result;\n    if ( result >= 0 )\n      break;\n    if ( *__errno_location() == 4 )\n      goto LABEL_1;\n    if ( *__errno_location() != 22 || a3 <= 0x7FFFE000 )\n      return v5;\n    a3 = 2147475456LL;\n  }\n  return result;\n}\n"], [4237226, "sub_40A7AA", "__int64 __fastcall sub_40A7AA(int a1)\n{\n  unsigned int fd; // [rsp+Ch] [rbp-14h]\n  unsigned int v3; // [rsp+18h] [rbp-8h]\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  fd = a1;\n  if ( a1 >= 0 && a1 <= 2 )\n  {\n    v3 = sub_40C411((unsigned int)a1);\n    v4 = *__errno_location();\n    close(a1);\n    *__errno_location() = v4;\n    fd = v3;\n  }\n  return fd;\n}\n"], [4237303, "sub_40A7F7", "int __fastcall sub_40A7F7(FILE *a1, const char *a2, const char *a3, const char *a4, __int64 *a5, unsigned __int64 a6)\n{\n  char *v6; // rax\n  char *v7; // rax\n  __int64 v8; // rbx\n  char *v9; // rax\n  __int64 v10; // r12\n  __int64 v11; // rbx\n  char *v12; // rax\n  __int64 v13; // r13\n  __int64 v14; // r12\n  __int64 v15; // rbx\n  char *v16; // rax\n  int result; // eax\n  __int64 v18; // r14\n  __int64 v19; // r13\n  __int64 v20; // r12\n  __int64 v21; // rbx\n  char *v22; // rax\n  __int64 v23; // r13\n  __int64 v24; // r15\n  __int64 v25; // r14\n  __int64 v26; // r12\n  __int64 v27; // rbx\n  char *v28; // rax\n  __int64 v29; // r14\n  __int64 v30; // r13\n  __int64 v31; // r15\n  __int64 v32; // r12\n  __int64 v33; // rbx\n  char *v34; // rax\n  __int64 v35; // r15\n  __int64 v36; // r14\n  __int64 v37; // r13\n  __int64 v38; // r12\n  __int64 v39; // rbx\n  char *v40; // rax\n  __int64 v41; // r15\n  __int64 v42; // r14\n  __int64 v43; // r13\n  __int64 v44; // r12\n  __int64 v45; // rbx\n  char *v46; // rax\n  __int64 v47; // r15\n  __int64 v48; // r14\n  __int64 v49; // r13\n  __int64 v50; // r12\n  __int64 v51; // rbx\n  char *v52; // rax\n  __int64 v53; // [rsp+30h] [rbp-80h]\n  __int64 v54; // [rsp+38h] [rbp-78h]\n  __int64 v55; // [rsp+38h] [rbp-78h]\n  __int64 v56; // [rsp+40h] [rbp-70h]\n  __int64 v57; // [rsp+40h] [rbp-70h]\n  __int64 v58; // [rsp+40h] [rbp-70h]\n  __int64 v59; // [rsp+48h] [rbp-68h]\n  __int64 v60; // [rsp+48h] [rbp-68h]\n  __int64 v61; // [rsp+48h] [rbp-68h]\n  __int64 v62; // [rsp+48h] [rbp-68h]\n\n  if ( a2 )\n    fprintf(a1, \"%s (%s) %s\\n\", a2, a3, a4);\n  else\n    fprintf(a1, \"%s %s\\n\", a3, a4);\n  v6 = gettext(\"(C)\");\n  fprintf(a1, \"Copyright %s %d Free Software Foundation, Inc.\", v6, 2011LL);\n  v7 = gettext(\n         \"\\n\"\n         \"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n         \"\\n\");\n  fputs_unlocked(v7, a1);\n  if ( a6 == 4 )\n  {\n    v18 = a5[3];\n    v19 = a5[2];\n    v20 = a5[1];\n    v21 = *a5;\n    v22 = gettext(\"Written by %s, %s, %s,\\nand %s.\\n\");\n    result = fprintf(a1, v22, v21, v20, v19, v18);\n  }\n  else if ( a6 > 4 )\n  {\n    if ( a6 == 7 )\n    {\n      v35 = a5[6];\n      v36 = a5[5];\n      v37 = a5[4];\n      v60 = a5[3];\n      v56 = a5[2];\n      v38 = a5[1];\n      v39 = *a5;\n      v40 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\");\n      result = fprintf(a1, v40, v39, v38, v56, v60, v37, v36, v35);\n    }\n    else if ( a6 > 7 )\n    {\n      if ( a6 == 8 )\n      {\n        v61 = a5[7];\n        v41 = a5[6];\n        v42 = a5[5];\n        v43 = a5[4];\n        v57 = a5[3];\n        v54 = a5[2];\n        v44 = a5[1];\n        v45 = *a5;\n        v46 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\");\n        result = fprintf(a1, v46, v45, v44, v54, v57, v43, v42, v41, v61);\n      }\n      else\n      {\n        v62 = a5[8];\n        v58 = a5[7];\n        v47 = a5[6];\n        v48 = a5[5];\n        v49 = a5[4];\n        v55 = a5[3];\n        v53 = a5[2];\n        v50 = a5[1];\n        v51 = *a5;\n        if ( a6 == 9 )\n          v52 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\");\n        else\n          v52 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\");\n        result = fprintf(a1, v52, v51, v50, v53, v55, v49, v48, v47, v58, v62);\n      }\n    }\n    else if ( a6 == 5 )\n    {\n      v23 = a5[4];\n      v24 = a5[3];\n      v25 = a5[2];\n      v26 = a5[1];\n      v27 = *a5;\n      v28 = gettext(\"Written by %s, %s, %s,\\n%s, and %s.\\n\");\n      result = fprintf(a1, v28, v27, v26, v25, v24, v23);\n    }\n    else\n    {\n      v29 = a5[5];\n      v30 = a5[4];\n      v59 = a5[3];\n      v31 = a5[2];\n      v32 = a5[1];\n      v33 = *a5;\n      v34 = gettext(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\");\n      result = fprintf(a1, v34, v33, v32, v31, v59, v30, v29);\n    }\n  }\n  else\n  {\n    switch ( a6 )\n    {\n      case 1uLL:\n        v8 = *a5;\n        v9 = gettext(\"Written by %s.\\n\");\n        result = fprintf(a1, v9, v8);\n        break;\n      case 0uLL:\n        abort();\n      case 2uLL:\n        v10 = a5[1];\n        v11 = *a5;\n        v12 = gettext(\"Written by %s and %s.\\n\");\n        result = fprintf(a1, v12, v11, v10);\n        break;\n      default:\n        v13 = a5[2];\n        v14 = a5[1];\n        v15 = *a5;\n        v16 = gettext(\"Written by %s, %s, and %s.\\n\");\n        result = fprintf(a1, v16, v15, v14, v13);\n        break;\n    }\n  }\n  return result;\n}\n"], [4238818, "sub_40ADE2", "int __fastcall sub_40ADE2(FILE *a1, const char *a2, const char *a3, const char *a4, __int64 *a5)\n{\n  unsigned __int64 i; // [rsp+38h] [rbp-8h]\n\n  for ( i = 0LL; a5[i]; ++i )\n    ;\n  return sub_40A7F7(a1, a2, a3, a4, a5, i);\n}\n"], [4238928, "sub_40AE50", "int __fastcall sub_40AE50(FILE *a1, const char *a2, const char *a3, const char *a4, unsigned int *a5)\n{\n  __int64 *v5; // rax\n  unsigned __int64 i; // [rsp+38h] [rbp-58h]\n  __int64 v8[10]; // [rsp+40h] [rbp-50h] BYREF\n\n  for ( i = 0LL; i <= 9; ++i )\n  {\n    if ( *a5 >= 0x30 )\n    {\n      v5 = (__int64 *)*((_QWORD *)a5 + 1);\n      *((_QWORD *)a5 + 1) = v5 + 1;\n    }\n    else\n    {\n      v5 = (__int64 *)(*((_QWORD *)a5 + 2) + *a5);\n      *a5 += 8;\n    }\n    v8[i] = *v5;\n    if ( !v8[i] )\n      break;\n  }\n  return sub_40A7F7(a1, a2, a3, a4, v8, i);\n}\n"], [4239145, "sub_40AF29", "int sub_40AF29(FILE *a1, const char *a2, const char *a3, const char *a4, ...)\n{\n  gcc_va_list va; // [rsp+28h] [rbp-C8h] BYREF\n\n  va_start(va, a4);\n  return sub_40AE50(a1, a2, a3, a4, (unsigned int *)va);\n}\n"], [4239327, "sub_40AFDF", "int sub_40AFDF()\n{\n  char *v0; // rax\n  char *v1; // rax\n  FILE *v2; // rbx\n  char *v3; // rax\n\n  v0 = gettext(\"\\nReport bugs to: %s\\n\");\n  printf(v0, \"bug-coreutils@gnu.org\");\n  v1 = gettext(\"%s home page: <%s>\\n\");\n  printf(v1, \"GNU coreutils\", \"http://www.gnu.org/software/coreutils/\");\n  v2 = stdout;\n  v3 = gettext(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\");\n  return fputs_unlocked(v3, v2);\n}\n"], [4239432, "sub_40B048", "__int64 __fastcall sub_40B048(unsigned __int64 a1, unsigned __int64 a2)\n{\n  if ( 0xFFFFFFFFFFFFFFFFLL / a2 < a1 )\n    sub_40B313(a1, a2, 0xFFFFFFFFFFFFFFFFLL % a2);\n  return sub_40B191(a2 * a1);\n}\n"], [4239494, "sub_40B086", "__int64 __fastcall sub_40B086(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)\n{\n  unsigned __int64 v3; // rax\n  unsigned __int64 v4; // rdx\n\n  v3 = 0xFFFFFFFFFFFFFFFFLL / a3;\n  v4 = 0xFFFFFFFFFFFFFFFFLL % a3;\n  if ( v3 < a2 )\n    sub_40B313(a1, a2, v4);\n  return sub_40B1C6(a1, a3 * a2);\n}\n"], [4239570, "sub_40B0D2", "__int64 __fastcall sub_40B0D2(__int64 a1, unsigned __int64 *a2, unsigned __int64 a3)\n{\n  unsigned __int64 v3; // rdx\n  unsigned __int64 v6; // [rsp+28h] [rbp-8h]\n\n  v6 = *a2;\n  if ( a1 )\n  {\n    v3 = 0xAAAAAAAAAAAAAAAALL % a3;\n    if ( 0xAAAAAAAAAAAAAAAALL / a3 <= v6 )\n      sub_40B313(a1, a2, v3);\n    v6 += (v6 + 1) >> 1;\n  }\n  else if ( !v6 )\n  {\n    v6 = (0x80 / a3 == 0) + 0x80 / a3;\n  }\n  *a2 = v6;\n  return sub_40B1C6(a1, a3 * v6);\n}\n"], [4239735, "sub_40B177", "__int64 __fastcall sub_40B177(__int64 a1)\n{\n  return sub_40B191(a1);\n}\n"], [4239761, "sub_40B191", "void *__fastcall sub_40B191(size_t a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  void *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = malloc(a1);\n  if ( !v4 && a1 )\n    sub_40B313(a1, a2, v2);\n  return v4;\n}\n"], [4239814, "sub_40B1C6", "void *__fastcall sub_40B1C6(void *a1, size_t a2)\n{\n  void *result; // rax\n  __int64 v3; // rdx\n  void *ptr; // [rsp+8h] [rbp-8h]\n\n  if ( a2 || !a1 )\n  {\n    ptr = realloc(a1, a2);\n    if ( !ptr )\n    {\n      if ( a2 )\n        sub_40B313(a1, a2, v3);\n    }\n    result = ptr;\n  }\n  else\n  {\n    free(a1);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4239911, "sub_40B227", "__int64 __fastcall sub_40B227(__int64 a1, unsigned __int64 *a2)\n{\n  return sub_40B0D2(a1, a2, 1uLL);\n}\n"], [4239953, "sub_40B251", "void *__fastcall sub_40B251(size_t a1, __int64 a2)\n{\n  void *v2; // rax\n\n  v2 = sub_40B191(a1, a2);\n  return memset(v2, 0, a1);\n}\n"], [4239996, "sub_40B27C", "void *__fastcall sub_40B27C(size_t a1, size_t a2)\n{\n  __int64 v2; // rdx\n  void *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = calloc(a1, a2);\n  if ( !v4 )\n    sub_40B313(a1, a2, v2);\n  return v4;\n}\n"], [4240053, "sub_40B2B5", "void *__fastcall sub_40B2B5(const void *a1, size_t a2)\n{\n  void *v2; // rax\n\n  v2 = sub_40B191(a2, a2);\n  return memcpy(v2, a1, a2);\n}\n"], [4240102, "sub_40B2E6", "void *__fastcall sub_40B2E6(const char *a1)\n{\n  size_t v1; // rax\n\n  v1 = strlen(a1);\n  return sub_40B2B5(a1, v1 + 1);\n}\n"], [4240147, "sub_40B313", "void __noreturn sub_40B313()\n{\n  char *v0; // rax\n\n  v0 = gettext(\"memory exhausted\");\n  error(status, 0, \"%s\", v0);\n  abort();\n}\n"], [4240200, "sub_40B348", "__int64 __fastcall sub_40B348(double a1)\n{\n  __int64 v1; // rdx\n  __int64 v3[2]; // [rsp+10h] [rbp-10h] BYREF\n\n  v3[0] = sub_40C2A8(a1);\n  v3[1] = v1;\n  do\n  {\n    *__errno_location() = 0;\n    if ( !(unsigned int)sub_40C13E(v3, 0LL) )\n      return 0LL;\n  }\n  while ( *__errno_location() == 4 || !*__errno_location() );\n  return 0xFFFFFFFFLL;\n}\n"], [4240313, "sub_40B3B9", "__int64 __fastcall sub_40B3B9(_BYTE *a1, _QWORD *a2, double *a3, double (__fastcall *a4)(_BYTE *, _BYTE **))\n{\n  unsigned __int8 v7; // [rsp+3Fh] [rbp-11h]\n  _BYTE *v8; // [rsp+40h] [rbp-10h] BYREF\n  double v9; // [rsp+48h] [rbp-8h]\n\n  v7 = 1;\n  *__errno_location() = 0;\n  v9 = a4(a1, &v8);\n  if ( v8 == a1 || !a2 && *v8 )\n  {\n    v7 = 0;\n  }\n  else if ( v9 != 0.0 && *__errno_location() == 34 )\n  {\n    v7 = 0;\n  }\n  if ( a2 )\n    *a2 = v8;\n  *a3 = v9;\n  return v7;\n}\n"], [4240492, "sub_40B46C", "__int64 __fastcall sub_40B46C(unsigned __int64 *a1, int a2)\n{\n  __int64 result; // rax\n\n  if ( 0xFFFFFFFFFFFFFFFFLL / a2 >= *a1 )\n  {\n    *a1 *= a2;\n    result = 0LL;\n  }\n  else\n  {\n    *a1 = -1LL;\n    result = 1LL;\n  }\n  return result;\n}\n"], [4240587, "sub_40B4CB", "__int64 __fastcall sub_40B4CB(unsigned __int64 *a1, int a2, int a3)\n{\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; a3--; i |= sub_40B46C(a1, a2) )\n    ;\n  return i;\n}\n"], [4240652, "sub_40B50C", "__int64 __fastcall sub_40B50C(const char *a1, char **a2, int a3, _QWORD *a4, const char *a5)\n{\n  char **v5; // rax\n  int v7; // eax\n  int v8; // eax\n  unsigned __int8 i; // [rsp+3Fh] [rbp-31h]\n  unsigned int v13; // [rsp+40h] [rbp-30h]\n  int v14; // [rsp+44h] [rbp-2Ch]\n  int v15; // [rsp+48h] [rbp-28h]\n  int v16; // [rsp+4Ch] [rbp-24h]\n  char v17; // [rsp+50h] [rbp-20h] BYREF\n  unsigned __int64 v18; // [rsp+58h] [rbp-18h] BYREF\n  unsigned __int8 *v19; // [rsp+60h] [rbp-10h]\n  char **endptr; // [rsp+68h] [rbp-8h]\n\n  v13 = 0;\n  if ( a3 < 0 || a3 > 36 )\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\", \"../../src/lib/xstrtol.c\", 0x53u, \"xstrtoul\");\n  if ( a2 )\n    v5 = a2;\n  else\n    v5 = (char **)&v17;\n  endptr = v5;\n  v19 = (unsigned __int8 *)a1;\n  for ( i = *a1; ((*__ctype_b_loc())[i] & 0x2000) != 0; i = *v19 )\n    ++v19;\n  if ( i == 45 )\n    return 4LL;\n  *__errno_location() = 0;\n  v18 = strtoul(a1, endptr, a3);\n  if ( *endptr == a1 )\n  {\n    if ( !a5 || !**endptr || !strchr(a5, **endptr) )\n      return 4LL;\n    v18 = 1LL;\n  }\n  else if ( *__errno_location() )\n  {\n    if ( *__errno_location() != 34 )\n      return 4LL;\n    v13 = 1;\n  }\n  if ( !a5 )\n  {\n    *a4 = v18;\n    return v13;\n  }\n  if ( !**endptr )\n    goto LABEL_76;\n  v14 = 1024;\n  v15 = 1;\n  if ( !strchr(a5, **endptr) )\n  {\n    *a4 = v18;\n    return v13 | 2;\n  }\n  if ( strchr(a5, 48) )\n  {\n    v7 = (*endptr)[1];\n    if ( v7 == 68 )\n      goto LABEL_35;\n    if ( v7 != 105 )\n    {\n      if ( v7 != 66 )\n        goto LABEL_36;\nLABEL_35:\n      v14 = 1000;\n      v15 = 2;\n      goto LABEL_36;\n    }\n    if ( (*endptr)[2] == 66 )\n      v15 = 3;\n  }\nLABEL_36:\n  v8 = **endptr;\n  if ( v8 != 89 )\n  {\n    if ( v8 > 89 )\n    {\n      if ( v8 == 103 )\n      {\nLABEL_65:\n        v16 = sub_40B4CB(&v18, v14, 3);\n        goto LABEL_74;\n      }\n      if ( v8 <= 103 )\n      {\n        switch ( v8 )\n        {\n          case 'b':\n            v16 = sub_40B46C(&v18, 512);\n            break;\n          case 'c':\n            v16 = 0;\n            break;\n          case 'Z':\n            v16 = sub_40B4CB(&v18, v14, 7);\n            break;\n          default:\n            goto LABEL_73;\n        }\n        goto LABEL_74;\n      }\n      if ( v8 == 109 )\n        goto LABEL_67;\n      if ( v8 > 109 )\n      {\n        if ( v8 != 116 )\n        {\n          if ( v8 != 119 )\n            goto LABEL_73;\n          v16 = sub_40B46C(&v18, 2);\n          goto LABEL_74;\n        }\nLABEL_69:\n        v16 = sub_40B4CB(&v18, v14, 4);\n        goto LABEL_74;\n      }\n      if ( v8 != 107 )\n        goto LABEL_73;\n    }\n    else if ( v8 != 75 )\n    {\n      if ( v8 <= 75 )\n      {\n        if ( v8 == 69 )\n        {\n          v16 = sub_40B4CB(&v18, v14, 6);\n          goto LABEL_74;\n        }\n        if ( v8 != 71 )\n        {\n          if ( v8 != 66 )\n          {\nLABEL_73:\n            *a4 = v18;\n            return v13 | 2;\n          }\n          v16 = sub_40B46C(&v18, 1024);\n          goto LABEL_74;\n        }\n        goto LABEL_65;\n      }\n      if ( v8 == 80 )\n      {\n        v16 = sub_40B4CB(&v18, v14, 5);\n        goto LABEL_74;\n      }\n      if ( v8 != 84 )\n      {\n        if ( v8 != 77 )\n          goto LABEL_73;\nLABEL_67:\n        v16 = sub_40B4CB(&v18, v14, 2);\n        goto LABEL_74;\n      }\n      goto LABEL_69;\n    }\n    v16 = sub_40B4CB(&v18, v14, 1);\n    goto LABEL_74;\n  }\n  v16 = sub_40B4CB(&v18, v14, 8);\nLABEL_74:\n  v13 |= v16;\n  *endptr += v15;\n  if ( **endptr )\n    v13 |= 2u;\nLABEL_76:\n  *a4 = v18;\n  return v13;\n}\n"], [4241784, "sub_40B978", "__int64 __fastcall sub_40B978(unsigned __int64 *a1, int a2)\n{\n  __int64 result; // rax\n\n  if ( 0xFFFFFFFFFFFFFFFFLL / a2 >= *a1 )\n  {\n    *a1 *= a2;\n    result = 0LL;\n  }\n  else\n  {\n    *a1 = -1LL;\n    result = 1LL;\n  }\n  return result;\n}\n"], [4241879, "sub_40B9D7", "__int64 __fastcall sub_40B9D7(unsigned __int64 *a1, int a2, int a3)\n{\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; a3--; i |= sub_40B978(a1, a2) )\n    ;\n  return i;\n}\n"], [4241944, "sub_40BA18", "__int64 __fastcall sub_40BA18(const char *a1, char **a2, int a3, uintmax_t *a4, const char *a5)\n{\n  char **v5; // rax\n  int v7; // eax\n  int v8; // eax\n  unsigned __int8 i; // [rsp+3Fh] [rbp-31h]\n  unsigned int v13; // [rsp+40h] [rbp-30h]\n  int v14; // [rsp+44h] [rbp-2Ch]\n  int v15; // [rsp+48h] [rbp-28h]\n  int v16; // [rsp+4Ch] [rbp-24h]\n  char v17; // [rsp+50h] [rbp-20h] BYREF\n  uintmax_t v18; // [rsp+58h] [rbp-18h] BYREF\n  unsigned __int8 *v19; // [rsp+60h] [rbp-10h]\n  char **endptr; // [rsp+68h] [rbp-8h]\n\n  v13 = 0;\n  if ( a3 < 0 || a3 > 36 )\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\", \"../../src/lib/xstrtol.c\", 0x53u, \"xstrtoumax\");\n  if ( a2 )\n    v5 = a2;\n  else\n    v5 = (char **)&v17;\n  endptr = v5;\n  v19 = (unsigned __int8 *)a1;\n  for ( i = *a1; ((*__ctype_b_loc())[i] & 0x2000) != 0; i = *v19 )\n    ++v19;\n  if ( i == 45 )\n    return 4LL;\n  *__errno_location() = 0;\n  v18 = strtoumax(a1, endptr, a3);\n  if ( *endptr == a1 )\n  {\n    if ( !a5 || !**endptr || !strchr(a5, **endptr) )\n      return 4LL;\n    v18 = 1LL;\n  }\n  else if ( *__errno_location() )\n  {\n    if ( *__errno_location() != 34 )\n      return 4LL;\n    v13 = 1;\n  }\n  if ( !a5 )\n  {\n    *a4 = v18;\n    return v13;\n  }\n  if ( !**endptr )\n    goto LABEL_76;\n  v14 = 1024;\n  v15 = 1;\n  if ( !strchr(a5, **endptr) )\n  {\n    *a4 = v18;\n    return v13 | 2;\n  }\n  if ( strchr(a5, 48) )\n  {\n    v7 = (*endptr)[1];\n    if ( v7 == 68 )\n      goto LABEL_35;\n    if ( v7 != 105 )\n    {\n      if ( v7 != 66 )\n        goto LABEL_36;\nLABEL_35:\n      v14 = 1000;\n      v15 = 2;\n      goto LABEL_36;\n    }\n    if ( (*endptr)[2] == 66 )\n      v15 = 3;\n  }\nLABEL_36:\n  v8 = **endptr;\n  if ( v8 != 89 )\n  {\n    if ( v8 > 89 )\n    {\n      if ( v8 == 103 )\n      {\nLABEL_65:\n        v16 = sub_40B9D7(&v18, v14, 3);\n        goto LABEL_74;\n      }\n      if ( v8 <= 103 )\n      {\n        switch ( v8 )\n        {\n          case 'b':\n            v16 = sub_40B978(&v18, 512);\n            break;\n          case 'c':\n            v16 = 0;\n            break;\n          case 'Z':\n            v16 = sub_40B9D7(&v18, v14, 7);\n            break;\n          default:\n            goto LABEL_73;\n        }\n        goto LABEL_74;\n      }\n      if ( v8 == 109 )\n        goto LABEL_67;\n      if ( v8 > 109 )\n      {\n        if ( v8 != 116 )\n        {\n          if ( v8 != 119 )\n            goto LABEL_73;\n          v16 = sub_40B978(&v18, 2);\n          goto LABEL_74;\n        }\nLABEL_69:\n        v16 = sub_40B9D7(&v18, v14, 4);\n        goto LABEL_74;\n      }\n      if ( v8 != 107 )\n        goto LABEL_73;\n    }\n    else if ( v8 != 75 )\n    {\n      if ( v8 <= 75 )\n      {\n        if ( v8 == 69 )\n        {\n          v16 = sub_40B9D7(&v18, v14, 6);\n          goto LABEL_74;\n        }\n        if ( v8 != 71 )\n        {\n          if ( v8 != 66 )\n          {\nLABEL_73:\n            *a4 = v18;\n            return v13 | 2;\n          }\n          v16 = sub_40B978(&v18, 1024);\n          goto LABEL_74;\n        }\n        goto LABEL_65;\n      }\n      if ( v8 == 80 )\n      {\n        v16 = sub_40B9D7(&v18, v14, 5);\n        goto LABEL_74;\n      }\n      if ( v8 != 84 )\n      {\n        if ( v8 != 77 )\n          goto LABEL_73;\nLABEL_67:\n        v16 = sub_40B9D7(&v18, v14, 2);\n        goto LABEL_74;\n      }\n      goto LABEL_69;\n    }\n    v16 = sub_40B9D7(&v18, v14, 1);\n    goto LABEL_74;\n  }\n  v16 = sub_40B9D7(&v18, v14, 8);\nLABEL_74:\n  v13 |= v16;\n  *endptr += v15;\n  if ( **endptr )\n    v13 |= 2u;\nLABEL_76:\n  *a4 = v18;\n  return v13;\n}\n"], [4243076, "sub_40BE84", "__int64 __fastcall sub_40BE84(int a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __m128 a7, __m128 a8, __m128 a9, __m128 a10, __m128 a11, __m128 a12, __m128 a13, __m128 a14)\n{\n  int v14; // ecx\n  int v15; // er8\n  int v16; // er9\n  int v18; // [rsp+10h] [rbp-E0h]\n  int v19; // [rsp+14h] [rbp-DCh]\n  int v20; // [rsp+18h] [rbp-D8h]\n  int v21; // [rsp+1Ch] [rbp-D4h]\n  __int64 v22; // [rsp+50h] [rbp-A0h]\n  __int64 v23; // [rsp+58h] [rbp-98h]\n  __int64 v24; // [rsp+60h] [rbp-90h]\n  __int64 v25; // [rsp+68h] [rbp-88h]\n  __m128 v26; // [rsp+70h] [rbp-80h]\n  __m128 v27; // [rsp+80h] [rbp-70h]\n  __m128 v28; // [rsp+90h] [rbp-60h]\n  __m128 v29; // [rsp+A0h] [rbp-50h]\n  __m128 v30; // [rsp+B0h] [rbp-40h]\n  __m128 v31; // [rsp+C0h] [rbp-30h]\n  __m128 v32; // [rsp+D0h] [rbp-20h]\n  __m128 v33; // [rsp+E0h] [rbp-10h]\n\n  v22 = a3;\n  v23 = a4;\n  v24 = a5;\n  v25 = a6;\n  v26 = a7;\n  v27 = a8;\n  v28 = a9;\n  v29 = a10;\n  v30 = a11;\n  v31 = a12;\n  v32 = a13;\n  v33 = a14;\n  if ( a2 != 1030 )\n    return (unsigned int)fcntl(a1, a2, v22);\n  v19 = v22;\n  if ( dword_6104A0 < 0 )\n  {\n    v18 = sub_40BE84(a1, 0, v22, a4, a5, a6);\n  }\n  else\n  {\n    v18 = fcntl(a1, 1030, (unsigned int)v22);\n    if ( v18 < 0 && *__errno_location() == 22 )\n    {\n      v18 = sub_40BE84(a1, 0, v19, v14, v15, v16);\n      if ( v18 < 0 )\n        return (unsigned int)v18;\n      dword_6104A0 = -1;\n    }\n    else\n    {\n      dword_6104A0 = 1;\n    }\n  }\n  if ( v18 >= 0 && dword_6104A0 == -1 )\n  {\n    v20 = fcntl(v18, 1);\n    if ( v20 < 0 || fcntl(v18, 2, v20 | 1u) == -1 )\n    {\n      v21 = *__errno_location();\n      close(v18);\n      *__errno_location() = v21;\n      v18 = -1;\n    }\n  }\n  return (unsigned int)v18;\n}\n"], [4243774, "sub_40C13E", "int __fastcall sub_40C13E(__time_t *a1, struct timespec *a2)\n{\n  int result; // eax\n  int v3; // [rsp+1Ch] [rbp-24h]\n  __time_t v4; // [rsp+20h] [rbp-20h]\n  struct timespec requested_time; // [rsp+30h] [rbp-10h] BYREF\n\n  if ( a1[1] >= 0 && a1[1] <= 999999999 )\n  {\n    v4 = *a1;\n    for ( requested_time.tv_nsec = a1[1]; ; requested_time.tv_nsec = 0LL )\n    {\n      if ( v4 <= 2073600 )\n      {\n        requested_time.tv_sec = v4;\n        return nanosleep(&requested_time, a2);\n      }\n      requested_time.tv_sec = 2073600LL;\n      v3 = nanosleep(&requested_time, a2);\n      v4 -= 2073600LL;\n      if ( v3 )\n        break;\n    }\n    if ( a2 )\n      a2->tv_sec += v4;\n    result = v3;\n  }\n  else\n  {\n    *__errno_location() = 22;\n    result = -1;\n  }\n  return result;\n}\n"], [4243997, "sub_40C21D", "__int64 __fastcall sub_40C21D(FILE *a1)\n{\n  bool v2; // [rsp+1Dh] [rbp-3h]\n  bool v3; // [rsp+1Eh] [rbp-2h]\n  bool v4; // [rsp+1Fh] [rbp-1h]\n\n  v2 = __fpending(a1) != 0;\n  v3 = ferror_unlocked(a1) != 0;\n  v4 = (unsigned int)sub_40C437(a1) != 0;\n  if ( !v3 && (!v4 || !v2 && *__errno_location() == 9) )\n    return 0LL;\n  if ( !v4 )\n    *__errno_location() = 0;\n  return 0xFFFFFFFFLL;\n}\n"], [4244136, "sub_40C2A8", "__int64 __fastcall sub_40C2A8(double a1)\n{\n  __int64 v2; // [rsp+10h] [rbp-38h]\n  signed __int64 v3; // [rsp+18h] [rbp-30h]\n\n  if ( a1 <= -9.223372036854776e18 )\n    return 0x8000000000000000LL;\n  if ( a1 >= 9.223372036854776e18 )\n    return 0x7FFFFFFFFFFFFFFFLL;\n  v3 = ((a1 - (double)(int)a1) * 1000000000.0 > (double)(int)((a1 - (double)(int)a1) * 1000000000.0))\n     + (unsigned __int64)(unsigned int)(int)((a1 - (double)(int)a1) * 1000000000.0);\n  v2 = v3 / 1000000000 + (unsigned int)(int)a1;\n  if ( v3 % 1000000000 < 0 )\n    --v2;\n  return v2;\n}\n"], [4244497, "sub_40C411", "__int64 __fastcall sub_40C411(int a1, __m128 a2, __m128 a3, __m128 a4, __m128 a5, __m128 a6, __m128 a7, __m128 a8, __m128 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14)\n{\n  return sub_40BE84(a1, 0, 3LL, a12, a13, a14, a2, a3, a4, a5, a6, a7, a8, a9);\n}\n"], [4244535, "sub_40C437", "int __fastcall sub_40C437(FILE *a1)\n{\n  int v2; // eax\n  int v3; // [rsp+14h] [rbp-Ch]\n  int v4; // [rsp+18h] [rbp-8h]\n\n  v3 = 0;\n  if ( fileno(a1) < 0 )\n    return fclose(a1);\n  if ( !__freading(a1) || (v2 = fileno(a1), lseek(v2, 0LL, 1) != -1) )\n  {\n    if ( (unsigned int)sub_40C51F(a1) )\n      v3 = *__errno_location();\n  }\n  v4 = fclose(a1);\n  if ( v3 )\n  {\n    *__errno_location() = v3;\n    v4 = -1;\n  }\n  return v4;\n}\n"], [4244716, "sub_40C4EC", "__int64 __fastcall sub_40C4EC(_DWORD *a1)\n{\n  __int64 result; // rax\n\n  result = *a1 & 0x100;\n  if ( (_DWORD)result )\n    result = sub_40C56A(a1, 0LL, 1LL);\n  return result;\n}\n"], [4244767, "sub_40C51F", "int __fastcall sub_40C51F(FILE *a1)\n{\n  if ( !a1 || !__freading(a1) )\n    return fflush(a1);\n  sub_40C4EC(a1);\n  return fflush(a1);\n}\n"], [4244842, "sub_40C56A", "int __fastcall sub_40C56A(FILE *a1, __off_t a2, int a3)\n{\n  int v3; // eax\n  __off_t v6; // [rsp+28h] [rbp-8h]\n\n  if ( a1->_IO_read_end != a1->_IO_read_ptr || a1->_IO_write_ptr != a1->_IO_write_base || a1->_IO_save_base )\n    return fseeko(a1, a2, a3);\n  v3 = fileno(a1);\n  v6 = lseek(v3, a2, a3);\n  if ( v6 == -1 )\n    return -1;\n  a1->_flags &= 0xFFFFFFEF;\n  a1->_offset = v6;\n  return 0;\n}\n"], [4245040, "init", "void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)\n{\n  __int64 v4; // rbx\n  signed __int64 v5; // rbp\n\n  v4 = 0LL;\n  v5 = &off_60FE18 - off_60FE10;\n  init_proc();\n  if ( v5 )\n  {\n    do\n      ((void (__fastcall *)(_QWORD, __int64, __int64))off_60FE10[v4++])(a1, a2, a3);\n    while ( v4 != v5 );\n  }\n}\n"], [4245152, "fini", "void fini(void)\n{\n  ;\n}\n"], [4245168, "sub_40C6B0", "int __fastcall sub_40C6B0(void (__fastcall *a1)(void *))\n{\n  void *v1; // rdx\n\n  if ( &qword_610248 )\n    v1 = (void *)qword_610248;\n  else\n    v1 = 0LL;\n  return __cxa_atexit(a1, 0LL, v1);\n}\n"], [4245200, "sub_40C6D0", "int __fastcall sub_40C6D0(int fildes, struct stat *stat_buf)\n{\n  return __fxstat(1, fildes, stat_buf);\n}\n"], [4245216, ".term_proc", "void term_proc()\n{\n  ;\n}\n"]]