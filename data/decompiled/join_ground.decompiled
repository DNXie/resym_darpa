[[4199184, ".init_proc", "void *init_proc()\n{\n  void *result; // rax\n\n  result = &_gmon_start__;\n  if ( &_gmon_start__ )\n    result = (void *)__gmon_start__();\n  return result;\n}\n"], [4199216, "sub_401330", "__int64 sub_401330()\n{\n  return qword_60A010();\n}\n"], [4199232, ".free", "// attributes: thunk\nvoid free(void *ptr)\n{\n  free(ptr);\n}\n"], [4199248, ".abort", "// attributes: thunk\nvoid __noreturn abort(void)\n{\n  abort();\n}\n"], [4199264, ".__errno_location", "// attributes: thunk\nint *__errno_location(void)\n{\n  return _errno_location();\n}\n"], [4199280, ".strncmp", "// attributes: thunk\nint strncmp(const char *s1, const char *s2, size_t n)\n{\n  return strncmp(s1, s2, n);\n}\n"], [4199296, "._exit", "// attributes: thunk\nvoid __noreturn _exit(int status)\n{\n  exit(status);\n}\n"], [4199312, ".__fpending", "// attributes: thunk\nsize_t __fpending(FILE *fp)\n{\n  return _fpending(fp);\n}\n"], [4199328, ".toupper", "// attributes: thunk\nint toupper(int c)\n{\n  return toupper(c);\n}\n"], [4199344, ".getc_unlocked", "// attributes: thunk\nint getc_unlocked(FILE *stream)\n{\n  return getc_unlocked(stream);\n}\n"], [4199360, ".fcntl", "// attributes: thunk\nint fcntl(int fd, int cmd, ...)\n{\n  return fcntl(fd, cmd);\n}\n"], [4199376, ".textdomain", "// attributes: thunk\nchar *textdomain(const char *domainname)\n{\n  return textdomain(domainname);\n}\n"], [4199392, ".fclose", "// attributes: thunk\nint fclose(FILE *stream)\n{\n  return fclose(stream);\n}\n"], [4199408, ".bindtextdomain", "// attributes: thunk\nchar *bindtextdomain(const char *domainname, const char *dirname)\n{\n  return bindtextdomain(domainname, dirname);\n}\n"], [4199424, ".__ctype_get_mb_cur_max", "// attributes: thunk\nsize_t __ctype_get_mb_cur_max(void)\n{\n  return _ctype_get_mb_cur_max();\n}\n"], [4199440, ".strlen", "// attributes: thunk\nsize_t strlen(const char *s)\n{\n  return strlen(s);\n}\n"], [4199456, ".__stack_chk_fail", "// attributes: thunk\nvoid __noreturn __stack_chk_fail()\n{\n  _stack_chk_fail();\n}\n"], [4199472, ".getopt_long", "// attributes: thunk\nint getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind)\n{\n  return getopt_long(argc, argv, shortopts, longopts, longind);\n}\n"], [4199488, ".mbrtowc", "// attributes: thunk\nsize_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p)\n{\n  return mbrtowc(pwc, s, n, p);\n}\n"], [4199504, ".gettext", "// attributes: thunk\nchar *gettext(const char *msgid)\n{\n  return gettext(msgid);\n}\n"], [4199520, ".strchr", "// attributes: thunk\nchar *strchr(const char *s, int c)\n{\n  return strchr(s, c);\n}\n"], [4199536, ".printf", "// attributes: thunk\nint printf(const char *format, ...)\n{\n  return printf(format);\n}\n"], [4199552, ".strrchr", "// attributes: thunk\nchar *strrchr(const char *s, int c)\n{\n  return strrchr(s, c);\n}\n"], [4199568, ".lseek", "// attributes: thunk\n__off_t lseek(int fd, __off_t offset, int whence)\n{\n  return lseek(fd, offset, whence);\n}\n"], [4199584, ".__assert_fail", "// attributes: thunk\nvoid __noreturn __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function)\n{\n  _assert_fail(assertion, file, line, function);\n}\n"], [4199600, ".memset", "// attributes: thunk\nvoid *memset(void *s, int c, size_t n)\n{\n  return memset(s, c, n);\n}\n"], [4199616, ".close", "// attributes: thunk\nint close(int fd)\n{\n  return close(fd);\n}\n"], [4199632, ".posix_fadvise", "// attributes: thunk\nint posix_fadvise(int fd, off_t offset, off_t len, int advise)\n{\n  return posix_fadvise(fd, offset, len, advise);\n}\n"], [4199648, ".memchr", "// attributes: thunk\nvoid *memchr(const void *s, int c, size_t n)\n{\n  return memchr(s, c, n);\n}\n"], [4199664, ".__libc_start_main", "// attributes: thunk\nint __fastcall __libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end)\n{\n  return _libc_start_main(main, argc, ubp_av, init, fini, rtld_fini, stack_end);\n}\n"], [4199680, ".memcmp", "// attributes: thunk\nint memcmp(const void *s1, const void *s2, size_t n)\n{\n  return memcmp(s1, s2, n);\n}\n"], [4199696, ".fputs_unlocked", "// attributes: thunk\nint fputs_unlocked(const char *s, FILE *stream)\n{\n  return fputs_unlocked(s, stream);\n}\n"], [4199712, ".ferror_unlocked", "// attributes: thunk\nint ferror_unlocked(FILE *stream)\n{\n  return ferror_unlocked(stream);\n}\n"], [4199728, ".calloc", "// attributes: thunk\nvoid *calloc(size_t nmemb, size_t size)\n{\n  return calloc(nmemb, size);\n}\n"], [4199744, ".strcmp", "// attributes: thunk\nint strcmp(const char *s1, const char *s2)\n{\n  return strcmp(s1, s2);\n}\n"], [4199760, ".fprintf", "// attributes: thunk\nint fprintf(FILE *stream, const char *format, ...)\n{\n  return fprintf(stream, format);\n}\n"], [4199776, ".__gmon_start__", "// attributes: thunk\n__int64 __gmon_start__(void)\n{\n  return _gmon_start__();\n}\n"], [4199792, ".memcpy", "// attributes: thunk\nvoid *memcpy(void *dest, const void *src, size_t n)\n{\n  return memcpy(dest, src, n);\n}\n"], [4199808, ".putchar_unlocked", "// attributes: thunk\nint putchar_unlocked(int c)\n{\n  return putchar_unlocked(c);\n}\n"], [4199824, ".fileno", "// attributes: thunk\nint fileno(FILE *stream)\n{\n  return fileno(stream);\n}\n"], [4199840, ".malloc", "// attributes: thunk\nvoid *malloc(size_t size)\n{\n  return malloc(size);\n}\n"], [4199856, ".fflush", "// attributes: thunk\nint fflush(FILE *stream)\n{\n  return fflush(stream);\n}\n"], [4199872, ".strcoll", "// attributes: thunk\nint strcoll(const char *s1, const char *s2)\n{\n  return strcoll(s1, s2);\n}\n"], [4199888, ".strpbrk", "// attributes: thunk\nchar *strpbrk(const char *s, const char *accept)\n{\n  return strpbrk(s, accept);\n}\n"], [4199904, ".__freading", "// attributes: thunk\nint __freading(FILE *fp)\n{\n  return _freading(fp);\n}\n"], [4199920, ".fwrite_unlocked", "// attributes: thunk\nsize_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)\n{\n  return fwrite_unlocked(ptr, size, n, stream);\n}\n"], [4199936, ".realloc", "// attributes: thunk\nvoid *realloc(void *ptr, size_t size)\n{\n  return realloc(ptr, size);\n}\n"], [4199952, ".fdopen", "// attributes: thunk\nFILE *fdopen(int fd, const char *modes)\n{\n  return fdopen(fd, modes);\n}\n"], [4199968, ".setlocale", "// attributes: thunk\nchar *setlocale(int category, const char *locale)\n{\n  return setlocale(category, locale);\n}\n"], [4199984, ".error", "// attributes: thunk\nvoid error(int status, int errnum, const char *format, ...)\n{\n  error(status, errnum, format);\n}\n"], [4200000, ".fseeko", "// attributes: thunk\nint fseeko(FILE *stream, __off_t off, int whence)\n{\n  return fseeko(stream, off, whence);\n}\n"], [4200016, ".fopen", "// attributes: thunk\nFILE *fopen(const char *filename, const char *modes)\n{\n  return fopen(filename, modes);\n}\n"], [4200032, ".strtoul", "// attributes: thunk\nunsigned __int64 strtoul(const char *nptr, char **endptr, int base)\n{\n  return strtoul(nptr, endptr, base);\n}\n"], [4200048, ".__cxa_atexit", "// attributes: thunk\nint __fastcall __cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle)\n{\n  return _cxa_atexit(lpfunc, obj, lpdso_handle);\n}\n"], [4200064, ".exit", "// attributes: thunk\nvoid __noreturn exit(int status)\n{\n  exit(status);\n}\n"], [4200080, ".fwrite", "// attributes: thunk\nsize_t fwrite(const void *ptr, size_t size, size_t n, FILE *s)\n{\n  return fwrite(ptr, size, n, s);\n}\n"], [4200096, ".mbsinit", "// attributes: thunk\nint mbsinit(const mbstate_t *ps)\n{\n  return mbsinit(ps);\n}\n"], [4200112, ".iswprint", "// attributes: thunk\nint iswprint(wint_t wc)\n{\n  return iswprint(wc);\n}\n"], [4200128, ".feof_unlocked", "// attributes: thunk\nint feof_unlocked(FILE *stream)\n{\n  return feof_unlocked(stream);\n}\n"], [4200144, ".__ctype_b_loc", "// attributes: thunk\nconst unsigned __int16 **__ctype_b_loc(void)\n{\n  return _ctype_b_loc();\n}\n"], [4200160, "start", "// positive sp value has been detected, the output may be wrong!\nvoid __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))\n{\n  __int64 v3; // rax\n  int v4; // esi\n  __int64 v5; // [rsp-8h] [rbp-8h] BYREF\n  char *retaddr; // [rsp+0h] [rbp+0h] BYREF\n\n  v4 = v5;\n  v5 = v3;\n  __libc_start_main(main, v4, &retaddr, init, fini, a3, &v5);\n  __halt();\n}\n"], [4200208, "sub_401710", "signed __int64 sub_401710()\n{\n  signed __int64 result; // rax\n\n  result = &unk_60A25F - &unk_60A258;\n  if ( (unsigned __int64)(&unk_60A25F - &unk_60A258) > 0xE )\n    result = 0LL;\n  return result;\n}\n"], [4200256, "sub_401740", "__int64 sub_401740()\n{\n  return 0LL;\n}\n"], [4200320, "sub_401780", "signed __int64 sub_401780()\n{\n  signed __int64 result; // rax\n\n  if ( !byte_60A2B8 )\n  {\n    result = sub_401710();\n    byte_60A2B8 = 1;\n  }\n  return result;\n}\n"], [4200352, "sub_4017A0", "__int64 sub_4017A0()\n{\n  return sub_401740();\n}\n"], [4200397, "sub_4017CD", "__int64 __fastcall sub_4017CD(unsigned __int8 a1)\n{\n  return a1;\n}\n"], [4200412, "sub_4017DC", "int sub_4017DC()\n{\n  __int64 v0; // rbx\n  char *v1; // rax\n  char *v2; // rax\n  FILE *v3; // rbx\n  char *v4; // rax\n  __int64 v5; // rbx\n  char *v6; // rax\n  __int64 v7; // rbx\n  char *v8; // rax\n  const char *s1; // [rsp+8h] [rbp-18h]\n\n  v0 = sub_403BF8(qword_60A3A8);\n  v1 = gettext(\"\\nReport %s bugs to %s\\n\");\n  printf(v1, v0, \"bug-coreutils@gnu.org\");\n  v2 = gettext(\"%s home page: <%s>\\n\");\n  printf(v2, \"GNU coreutils\", \"http://www.gnu.org/software/coreutils/\");\n  v3 = stdout;\n  v4 = gettext(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\");\n  fputs_unlocked(v4, v3);\n  s1 = setlocale(5, 0LL);\n  if ( s1 && strncmp(s1, \"en_\", 3uLL) )\n  {\n    v5 = sub_403BF8(qword_60A3A8);\n    v6 = gettext(\"Report %s translation bugs to <http://translationproject.org/team/>\\n\");\n    printf(v6, v5);\n  }\n  v7 = sub_403BF8(qword_60A3A8);\n  v8 = gettext(\"For complete documentation, run: info coreutils '%s invocation'\\n\");\n  return printf(v8, v7);\n}\n"], [4200678, "sub_4018E6", "void __fastcall __noreturn sub_4018E6(int a1)\n{\n  __int64 v1; // rbx\n  char *v2; // rax\n  char *v3; // rax\n  FILE *v4; // rbx\n  char *v5; // rax\n  FILE *v6; // rbx\n  char *v7; // rax\n  FILE *v8; // rbx\n  char *v9; // rax\n  FILE *v10; // rbx\n  char *v11; // rax\n  FILE *v12; // rbx\n  char *v13; // rax\n  FILE *v14; // rbx\n  char *v15; // rax\n\n  v1 = qword_60A3A8;\n  if ( a1 )\n  {\n    v2 = gettext(\"Try `%s --help' for more information.\\n\");\n    fprintf(stderr, v2, v1);\n  }\n  else\n  {\n    v3 = gettext(\"Usage: %s [OPTION]... FILE1 FILE2\\n\");\n    printf(v3, v1);\n    v4 = stdout;\n    v5 = gettext(\n           \"For each pair of input lines with identical join fields, write a line to\\n\"\n           \"standard output.  The default join field is the first, delimited\\n\"\n           \"by whitespace.  When FILE1 or FILE2 (not both) is -, read standard input.\\n\"\n           \"\\n\"\n           \"  -a FILENUM        print unpairable lines coming from file FILENUM, where\\n\"\n           \"                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\\n\"\n           \"  -e EMPTY          replace missing input fields with EMPTY\\n\");\n    fputs_unlocked(v5, v4);\n    v6 = stdout;\n    v7 = gettext(\n           \"  -i, --ignore-case  ignore differences in case when comparing fields\\n\"\n           \"  -j FIELD          equivalent to `-1 FIELD -2 FIELD'\\n\"\n           \"  -o FORMAT         obey FORMAT while constructing output line\\n\"\n           \"  -t CHAR           use CHAR as input and output field separator\\n\");\n    fputs_unlocked(v7, v6);\n    v8 = stdout;\n    v9 = gettext(\n           \"  -v FILENUM        like -a FILENUM, but suppress joined output lines\\n\"\n           \"  -1 FIELD          join on this FIELD of file 1\\n\"\n           \"  -2 FIELD          join on this FIELD of file 2\\n\"\n           \"  --check-order     check that the input is correctly sorted, even\\n\"\n           \"                      if all input lines are pairable\\n\"\n           \"  --nocheck-order   do not check that the input is correctly sorted\\n\"\n           \"  --header          treat the first line in each file as field headers,\\n\"\n           \"                      print them without trying to pair them\\n\");\n    fputs_unlocked(v9, v8);\n    v10 = stdout;\n    v11 = gettext(\"      --help     display this help and exit\\n\");\n    fputs_unlocked(v11, v10);\n    v12 = stdout;\n    v13 = gettext(\"      --version  output version information and exit\\n\");\n    fputs_unlocked(v13, v12);\n    v14 = stdout;\n    v15 = gettext(\n            \"\\n\"\n            \"Unless -t CHAR is given, leading blanks separate fields and are ignored,\\n\"\n            \"else fields are separated by CHAR.  Any FIELD is a field number counted\\n\"\n            \"from 1.  FORMAT is one or more comma or blank separated specifications,\\n\"\n            \"each being `FILENUM.FIELD' or `0'.  Default FORMAT outputs the join field,\\n\"\n            \"the remaining fields from FILE1, the remaining fields from FILE2, all\\n\"\n            \"separated by CHAR.  If FORMAT is the keyword 'auto', then the first\\n\"\n            \"line of each file determines the number of fields output for each line.\\n\"\n            \"\\n\"\n            \"Important: FILE1 and FILE2 must be sorted on the join fields.\\n\"\n            \"E.g., use ` sort -k 1b,1 ' if `join' has no options,\\n\"\n            \"or use ` join -t '' ' if `sort' has no options.\\n\"\n            \"Note, comparisons honor the rules specified by `LC_COLLATE'.\\n\"\n            \"If the input is not sorted and some lines cannot be joined, a\\n\"\n            \"warning message will be given.\\n\");\n    fputs_unlocked(v15, v14);\n    sub_4017DC();\n  }\n  exit(a1);\n}\n"], [4200963, "sub_401A03", "_QWORD *__fastcall sub_401A03(_QWORD *a1, __int64 a2, __int64 a3)\n{\n  _QWORD *result; // rax\n\n  if ( a1[3] >= a1[4] )\n    a1[5] = sub_406247(a1[5], a1 + 4, 16LL);\n  *(_QWORD *)(16LL * a1[3] + a1[5]) = a2;\n  *(_QWORD *)(16LL * a1[3] + a1[5] + 8) = a3;\n  result = a1;\n  ++a1[3];\n  return result;\n}\n"], [4201127, "sub_401AA7", "unsigned __int8 *__fastcall sub_401AA7(_QWORD *a1)\n{\n  __int64 v1; // rdx\n  unsigned __int8 *result; // rax\n  const unsigned __int16 *v3; // rbx\n  const unsigned __int16 *v4; // rbx\n  const unsigned __int16 *v5; // rbx\n  unsigned __int8 *s; // [rsp+10h] [rbp-30h]\n  unsigned __int8 *i; // [rsp+18h] [rbp-28h]\n  unsigned __int8 *v8; // [rsp+20h] [rbp-20h]\n  char *v9; // [rsp+28h] [rbp-18h]\n\n  s = (unsigned __int8 *)a1[2];\n  v1 = a1[1] - 1LL;\n  v8 = &s[v1];\n  result = s;\n  if ( s != &s[v1] )\n  {\n    if ( c >= 0 && c != 10 )\n    {\n      while ( 1 )\n      {\n        v9 = (char *)memchr(s, c, v8 - s);\n        if ( !v9 )\n          break;\n        sub_401A03(a1, (__int64)s, v9 - (char *)s);\n        s = (unsigned __int8 *)(v9 + 1);\n      }\n      return (unsigned __int8 *)sub_401A03(a1, (__int64)s, v8 - s);\n    }\n    if ( c >= 0 )\n      return (unsigned __int8 *)sub_401A03(a1, (__int64)s, v8 - s);\n    while ( 1 )\n    {\n      v3 = *__ctype_b_loc();\n      if ( (v3[(unsigned __int8)sub_4017CD(*s)] & 1) == 0 )\n        break;\n      result = ++s;\n      if ( s == v8 )\n        return result;\n    }\n    while ( 1 )\n    {\n      for ( i = s + 1; i != v8; ++i )\n      {\n        v4 = *__ctype_b_loc();\n        if ( (v4[(unsigned __int8)sub_4017CD(*i)] & 1) != 0 )\n          break;\n      }\n      sub_401A03(a1, (__int64)s, i - s);\n      result = i;\n      if ( i == v8 )\n        break;\n      for ( s = i + 1; s != v8; ++s )\n      {\n        v5 = *__ctype_b_loc();\n        if ( (v5[(unsigned __int8)sub_4017CD(*s)] & 1) == 0 )\n          break;\n      }\n      if ( s == v8 )\n        return (unsigned __int8 *)sub_401A03(a1, (__int64)s, v8 - s);\n    }\n  }\n  return result;\n}\n"], [4201654, "sub_401CB6", "__int64 __fastcall sub_401CB6(__int64 a1)\n{\n  __int64 result; // rax\n\n  if ( a1 )\n  {\n    free(*(void **)(a1 + 40));\n    *(_QWORD *)(a1 + 40) = 0LL;\n    free(*(void **)(a1 + 16));\n    result = a1;\n    *(_QWORD *)(a1 + 16) = 0LL;\n  }\n  return result;\n}\n"], [4201733, "sub_401D05", "__int64 __fastcall sub_401D05(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)\n{\n  __int64 result; // rax\n  size_t v5; // rax\n  size_t v6; // rax\n  unsigned int v7; // [rsp+2Ch] [rbp-24h]\n  void *s1; // [rsp+30h] [rbp-20h]\n  void *s2; // [rsp+38h] [rbp-18h]\n  size_t v10; // [rsp+40h] [rbp-10h]\n  size_t n; // [rsp+48h] [rbp-8h]\n\n  if ( *(_QWORD *)(a1 + 24) <= a3 )\n  {\n    s1 = 0LL;\n    v10 = 0LL;\n  }\n  else\n  {\n    s1 = *(void **)(16 * a3 + *(_QWORD *)(a1 + 40));\n    v10 = *(_QWORD *)(16 * a3 + *(_QWORD *)(a1 + 40) + 8);\n  }\n  if ( *(_QWORD *)(a2 + 24) <= a4 )\n  {\n    s2 = 0LL;\n    n = 0LL;\n  }\n  else\n  {\n    s2 = *(void **)(16 * a4 + *(_QWORD *)(a2 + 40));\n    n = *(_QWORD *)(16 * a4 + *(_QWORD *)(a2 + 40) + 8);\n  }\n  if ( v10 )\n  {\n    if ( !n )\n      return 1LL;\n    if ( byte_60A390 )\n    {\n      v5 = v10;\n      if ( n <= v10 )\n        v5 = n;\n      v7 = sub_404009(s1, s2, v5);\n    }\n    else\n    {\n      if ( byte_60A300 )\n        return sub_406590(s1, v10, s2, n);\n      v6 = v10;\n      if ( n <= v10 )\n        v6 = n;\n      v7 = memcmp(s1, s2, v6);\n    }\n    if ( v7 )\n    {\n      result = v7;\n    }\n    else if ( v10 < n )\n    {\n      result = 0xFFFFFFFFLL;\n    }\n    else\n    {\n      result = v10 != n;\n    }\n  }\n  else if ( n )\n  {\n    result = 0xFFFFFFFFLL;\n  }\n  else\n  {\n    result = 0LL;\n  }\n  return result;\n}\n"], [4202145, "sub_401EA1", "__int64 __fastcall sub_401EA1(__int64 a1, __int64 a2, int a3)\n{\n  __int64 result; // rax\n  unsigned __int64 v4; // rax\n  int v5; // eax\n  __int64 v6; // r12\n  unsigned int v7; // er14\n  __int64 v8; // r13\n  char *v9; // rbx\n  char *v10; // rax\n  unsigned __int64 v12; // [rsp+20h] [rbp-30h]\n\n  result = (unsigned int)dword_60A348;\n  if ( dword_60A348 != 2 )\n  {\n    if ( dword_60A348 == 1 || (result = (unsigned __int8)byte_60A304, byte_60A304) )\n    {\n      result = (unsigned __int8)byte_60A305[a3 - 1] ^ 1u;\n      if ( byte_60A305[a3 - 1] != 1 )\n      {\n        v4 = a3 == 1 ? qword_60A200 : qword_60A208;\n        result = sub_401D05(a1, a2, v4, v4);\n        if ( (int)result > 0 )\n        {\n          v12 = *(_QWORD *)(a2 + 8);\n          if ( v12 && *(_BYTE *)(v12 - 1 + *(_QWORD *)(a2 + 16)) == 10 )\n            --v12;\n          v5 = 0x7FFFFFFF;\n          if ( v12 <= 0x7FFFFFFF )\n            v5 = v12;\n          v6 = *(_QWORD *)(a2 + 16);\n          v7 = v5;\n          v8 = qword_60A2D0[a3 - 1];\n          v9 = (&qword_60A2E0)[a3 - 1];\n          v10 = gettext(\"%s:%ju: is not sorted: %.*s\");\n          error(dword_60A348 == 1, 0, v10, v9, v8, v7, v6);\n          result = a3 - 1;\n          byte_60A305[result] = 1;\n        }\n      }\n    }\n  }\n  return result;\n}\n"], [4202501, "sub_402005", "__int64 __fastcall sub_402005(__int64 a1)\n{\n  __int64 result; // rax\n\n  result = a1;\n  *(_QWORD *)(a1 + 24) = 0LL;\n  return result;\n}\n"], [4202523, "sub_40201B", "__int64 __fastcall sub_40201B(__int64 *a1)\n{\n  __int64 result; // rax\n\n  result = sub_4063F1(1LL, 48LL);\n  *a1 = result;\n  return result;\n}\n"], [4202571, "sub_40204B", "__int64 __fastcall sub_40204B(FILE *a1, __int64 *a2, int a3)\n{\n  char *v3; // rbx\n  int *v4; // rax\n  __int64 result; // rax\n  _QWORD *v7; // [rsp+20h] [rbp-20h]\n\n  v7 = (_QWORD *)*a2;\n  if ( qword_60A2C0[a3 - 1] == *a2 )\n  {\n    v7 = *(&ptr + a3 - 1);\n    *(&ptr + a3 - 1) = (void *)*a2;\n    *a2 = (__int64)v7;\n  }\n  if ( v7 )\n    sub_402005((__int64)v7);\n  else\n    v7 = (_QWORD *)sub_40201B(a2);\n  if ( sub_403E80(v7, a1) )\n  {\n    ++qword_60A2D0[a3 - 1];\n    sub_401AA7(v7);\n    if ( qword_60A2C0[a3 - 1] )\n      sub_401EA1(qword_60A2C0[a3 - 1], (__int64)v7, a3);\n    qword_60A2C0[a3 - 1] = (__int64)v7;\n    result = 1LL;\n  }\n  else\n  {\n    if ( ferror_unlocked(a1) )\n    {\n      v3 = gettext(\"read error\");\n      v4 = __errno_location();\n      error(1, *v4, v3);\n    }\n    sub_401CB6((__int64)v7);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4202949, "sub_4021C5", "void sub_4021C5()\n{\n  unsigned __int64 i; // [rsp+8h] [rbp-8h]\n\n  for ( i = 0LL; i <= 1; ++i )\n  {\n    if ( *(&ptr + i) )\n    {\n      sub_401CB6((__int64)*(&ptr + i));\n      free(*(&ptr + i));\n    }\n  }\n}\n"], [4203038, "sub_40221E", "_QWORD *__fastcall sub_40221E(_QWORD *a1)\n{\n  _QWORD *result; // rax\n\n  *a1 = 0LL;\n  a1[1] = 0LL;\n  result = a1;\n  a1[2] = 0LL;\n  return result;\n}\n"], [4203083, "sub_40224B", "__int64 __fastcall sub_40224B(FILE *a1, unsigned __int64 *a2, int a3)\n{\n  unsigned __int64 i; // [rsp+28h] [rbp-8h]\n\n  if ( *a2 == a2[1] )\n  {\n    a2[2] = sub_406247(a2[2], a2 + 1, 8LL);\n    for ( i = *a2; a2[1] > i; ++i )\n      *(_QWORD *)(8 * i + a2[2]) = 0LL;\n  }\n  if ( !(unsigned __int8)sub_40204B(a1, (__int64 *)(a2[2] + 8 * *a2), a3) )\n    return 0LL;\n  ++*a2;\n  return 1LL;\n}\n"], [4203297, "sub_402321", "__int64 __fastcall sub_402321(FILE *a1, unsigned __int64 *a2, char a3, int a4)\n{\n  if ( a3 )\n    *a2 = 0LL;\n  return sub_40224B(a1, a2, a4);\n}\n"], [4203362, "sub_402362", "void __fastcall sub_402362(__int64 a1)\n{\n  unsigned __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 0LL; *(_QWORD *)(a1 + 8) > i; ++i )\n  {\n    sub_401CB6(*(_QWORD *)(8 * i + *(_QWORD *)(a1 + 16)));\n    free(*(void **)(8 * i + *(_QWORD *)(a1 + 16)));\n  }\n  free(*(void **)(a1 + 16));\n}\n"], [4203481, "sub_4023D9", "int __fastcall sub_4023D9(unsigned __int64 a1, __int64 a2)\n{\n  int result; // eax\n  size_t n; // [rsp+18h] [rbp-8h]\n\n  if ( *(_QWORD *)(a2 + 24) <= a1 )\n  {\n    result = (int)s1;\n    if ( !s1 )\n      return result;\n    return fputs_unlocked(s1, stdout);\n  }\n  n = *(_QWORD *)(16 * a1 + *(_QWORD *)(a2 + 40) + 8);\n  if ( n )\n    return fwrite_unlocked(*(const void **)(16 * a1 + *(_QWORD *)(a2 + 40)), 1uLL, n, stdout);\n  result = (int)s1;\n  if ( s1 )\n    return fputs_unlocked(s1, stdout);\n  return result;\n}\n"], [4203671, "sub_402497", "unsigned __int64 __fastcall sub_402497(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)\n{\n  char v4; // al\n  unsigned __int64 result; // rax\n  char v6; // [rsp+2Fh] [rbp-11h]\n  unsigned __int64 i; // [rsp+30h] [rbp-10h]\n  unsigned __int64 j; // [rsp+30h] [rbp-10h]\n  unsigned __int64 v9; // [rsp+38h] [rbp-8h]\n\n  if ( !byte_60A310 )\n    a3 = *(_QWORD *)(a1 + 24);\n  v9 = a3;\n  if ( c < 0 )\n    v4 = 32;\n  else\n    v4 = c;\n  v6 = v4;\n  for ( i = 0LL; i < a2 && i < v9; ++i )\n  {\n    putchar_unlocked(v6);\n    sub_4023D9(i, a1);\n  }\n  for ( j = a2 + 1; ; ++j )\n  {\n    result = j;\n    if ( j >= v9 )\n      break;\n    putchar_unlocked(v6);\n    sub_4023D9(j, a1);\n  }\n  return result;\n}\n"], [4203872, "sub_402560", "int __fastcall sub_402560(void *a1, __int64 a2)\n{\n  char v2; // al\n  __int64 v3; // rax\n  int result; // eax\n  char v5; // [rsp+1Fh] [rbp-21h]\n  __int64 v6; // [rsp+30h] [rbp-10h]\n\n  if ( c < 0 )\n    v2 = 32;\n  else\n    v2 = c;\n  v5 = v2;\n  if ( qword_60A340 )\n  {\n    v6 = qword_60A340;\n    while ( 1 )\n    {\n      if ( *(_DWORD *)v6 )\n      {\n        v3 = (__int64)(*(_DWORD *)v6 == 1 ? a1 : a2);\n        sub_4023D9(*(_QWORD *)(v6 + 8), v3);\n      }\n      else if ( a1 == &unk_60A360 )\n      {\n        sub_4023D9(qword_60A208, a2);\n      }\n      else\n      {\n        sub_4023D9(qword_60A200, (__int64)a1);\n      }\n      v6 = *(_QWORD *)(v6 + 16);\n      if ( !v6 )\n        break;\n      putchar_unlocked(v5);\n    }\n    result = putchar_unlocked(10);\n  }\n  else\n  {\n    if ( a1 == &unk_60A360 )\n      sub_4023D9(qword_60A208, a2);\n    else\n      sub_4023D9(qword_60A200, (__int64)a1);\n    sub_402497((__int64)a1, qword_60A200, qword_60A318);\n    sub_402497(a2, qword_60A208, qword_60A320);\n    result = putchar_unlocked(10);\n  }\n  return result;\n}\n"], [4204252, "sub_4026DC", "void __fastcall sub_4026DC(FILE *a1, FILE *a2)\n{\n  __int64 v2; // rax\n  __int64 v3; // rax\n  void *v4; // rax\n  void *v5; // rax\n  char v6; // [rsp+11h] [rbp-7Fh]\n  char v7; // [rsp+12h] [rbp-7Eh]\n  char v8; // [rsp+13h] [rbp-7Dh]\n  int v9; // [rsp+14h] [rbp-7Ch]\n  void *ptr; // [rsp+18h] [rbp-78h] BYREF\n  unsigned __int64 i; // [rsp+20h] [rbp-70h]\n  unsigned __int64 j; // [rsp+28h] [rbp-68h]\n  void *v13; // [rsp+30h] [rbp-60h]\n  void *v14; // [rsp+38h] [rbp-58h]\n  __int64 v15; // [rsp+40h] [rbp-50h]\n  __int64 v16; // [rsp+48h] [rbp-48h]\n  unsigned __int64 v17[2]; // [rsp+50h] [rbp-40h] BYREF\n  __int64 *v18; // [rsp+60h] [rbp-30h]\n  unsigned __int64 v19[2]; // [rsp+70h] [rbp-20h] BYREF\n  __int64 *v20; // [rsp+80h] [rbp-10h]\n\n  sub_403CDF(a1, 2LL);\n  sub_403CDF(a2, 2LL);\n  sub_40221E(v17);\n  sub_40224B(a1, v17, 1);\n  sub_40221E(v19);\n  sub_40224B(a2, v19, 2);\n  if ( byte_60A310 )\n  {\n    if ( v17[0] )\n      v2 = *(_QWORD *)(*v18 + 24);\n    else\n      v2 = 0LL;\n    qword_60A318 = v2;\n    if ( v19[0] )\n      v3 = *(_QWORD *)(*v20 + 24);\n    else\n      v3 = 0LL;\n    qword_60A320 = v3;\n  }\n  if ( byte_60A391 && (v17[0] || v19[0]) )\n  {\n    if ( v17[0] )\n      v4 = (void *)*v18;\n    else\n      v4 = &unk_60A360;\n    v13 = v4;\n    if ( v19[0] )\n      v5 = (void *)*v20;\n    else\n      v5 = &unk_60A360;\n    v14 = v5;\n    sub_402560(v13, (__int64)v5);\n    qword_60A2C0[0] = 0LL;\n    qword_60A2C8 = 0LL;\n    if ( v17[0] )\n      sub_402321(a1, v17, 1, 1);\n    if ( v19[0] )\n      sub_402321(a2, v19, 1, 2);\n  }\n  while ( v17[0] && v19[0] )\n  {\n    v9 = sub_401D05(*v18, *v20, qword_60A200, qword_60A208);\n    if ( v9 >= 0 )\n    {\n      if ( v9 <= 0 )\n      {\n        v6 = 0;\n        while ( (unsigned __int8)sub_402321(a1, v17, 0, 1) == 1 )\n        {\n          if ( (unsigned int)sub_401D05(v18[v17[0] - 1], *v20, qword_60A200, qword_60A208) )\n            goto LABEL_35;\n        }\n        v6 = 1;\n        ++v17[0];\nLABEL_35:\n        v7 = 0;\n        while ( (unsigned __int8)sub_402321(a2, v19, 0, 2) == 1 )\n        {\n          if ( (unsigned int)sub_401D05(*v18, v20[v19[0] - 1], qword_60A200, qword_60A208) )\n            goto LABEL_39;\n        }\n        v7 = 1;\n        ++v19[0];\nLABEL_39:\n        if ( byte_60A303 )\n        {\n          for ( i = 0LL; v17[0] - 1 > i; ++i )\n          {\n            for ( j = 0LL; v19[0] - 1 > j; ++j )\n              sub_402560((void *)v18[i], v20[j]);\n          }\n        }\n        if ( v6 != 1 )\n        {\n          v15 = *v18;\n          *v18 = v18[v17[0] - 1];\n          v18[v17[0] - 1] = v15;\n          v17[0] = 1LL;\n        }\n        else\n        {\n          v17[0] = 0LL;\n        }\n        if ( v7 != 1 )\n        {\n          v16 = *v20;\n          *v20 = v20[v19[0] - 1];\n          v20[v19[0] - 1] = v16;\n          v19[0] = 1LL;\n        }\n        else\n        {\n          v19[0] = 0LL;\n        }\n      }\n      else\n      {\n        if ( byte_60A302 )\n          sub_402560(&unk_60A360, *v20);\n        sub_402321(a2, v19, 1, 2);\n        byte_60A304 = 1;\n      }\n    }\n    else\n    {\n      if ( byte_60A301 )\n        sub_402560((void *)*v18, (__int64)&unk_60A360);\n      sub_402321(a1, v17, 1, 1);\n      byte_60A304 = 1;\n    }\n  }\n  ptr = 0LL;\n  v8 = 0;\n  if ( dword_60A348 != 2 && (byte_60A305[0] != 1 || byte_60A306 != 1) )\n    v8 = 1;\n  if ( (byte_60A301 || v8) && v17[0] )\n  {\n    if ( byte_60A301 )\n      sub_402560((void *)*v18, (__int64)&unk_60A360);\n    if ( v19[0] )\n      byte_60A304 = 1;\n    do\n    {\n      if ( !(unsigned __int8)sub_40204B(a1, (__int64 *)&ptr, 1) )\n        break;\n      if ( byte_60A301 )\n        sub_402560(ptr, (__int64)&unk_60A360);\n    }\n    while ( !byte_60A305[0] || byte_60A301 == 1 );\n  }\n  if ( (byte_60A302 || v8) && v19[0] )\n  {\n    if ( byte_60A302 )\n      sub_402560(&unk_60A360, *v20);\n    if ( v17[0] )\n      byte_60A304 = 1;\n    do\n    {\n      if ( !(unsigned __int8)sub_40204B(a2, (__int64 *)&ptr, 2) )\n        break;\n      if ( byte_60A302 )\n        sub_402560(&unk_60A360, (__int64)ptr);\n    }\n    while ( !byte_60A306 || byte_60A302 == 1 );\n  }\n  sub_401CB6((__int64)ptr);\n  free(ptr);\n  sub_402362((__int64)v17);\n  sub_402362((__int64)v19);\n}\n"], [4205888, "sub_402D40", "_QWORD *__fastcall sub_402D40(int a1, __int64 a2)\n{\n  _QWORD *result; // rax\n\n  if ( a1 && a1 != 1 && a1 != 2 )\n    __assert_fail(\"file == 0 || file == 1 || file == 2\", \"../../src/src/join.c\", 0x32Bu, \"add_field\");\n  if ( !a1 && a2 )\n    __assert_fail(\"file != 0 || field == 0\", \"../../src/src/join.c\", 0x32Cu, \"add_field\");\n  result = (_QWORD *)sub_406306(24LL);\n  *(_DWORD *)result = a1;\n  result[1] = a2;\n  result[2] = 0LL;\n  *((_QWORD *)off_60A210 + 2) = result;\n  off_60A210 = result;\n  return result;\n}\n"], [4206059, "sub_402DEB", "__int64 __fastcall sub_402DEB(__int64 a1)\n{\n  __int64 v1; // rbx\n  char *v2; // rax\n  int v4; // [rsp+1Ch] [rbp-24h]\n  __int64 v5; // [rsp+20h] [rbp-20h] BYREF\n\n  v4 = sub_406708(a1, 0LL, 10LL, &v5, &locale);\n  if ( v4 == 1 )\n  {\n    v5 = -1LL;\n  }\n  else if ( v4 || !v5 )\n  {\n    v1 = sub_4041AE(a1);\n    v2 = gettext(\"invalid field number: %s\");\n    error(1, 0, v2, v1);\n  }\n  return v5 - 1;\n}\n"], [4206215, "sub_402E87", "__int64 __fastcall sub_402E87(char *a1, _DWORD *a2, __int64 *a3)\n{\n  int v3; // eax\n  __int64 v4; // rbx\n  char *v5; // rax\n  __int64 result; // rax\n  __int64 v7; // rbx\n  char *v8; // rax\n  __int64 v9; // rbx\n  char *v10; // rax\n\n  v3 = *a1;\n  if ( v3 == 48 )\n  {\n    if ( a1[1] )\n    {\n      v4 = sub_4041AE(a1);\n      v5 = gettext(\"invalid field specifier: %s\");\n      error(1, 0, v5, v4);\n    }\n    *a2 = 0;\n    result = (__int64)a3;\n    *a3 = 0LL;\n  }\n  else\n  {\n    if ( v3 < 48 || v3 > 50 )\n    {\n      v9 = sub_4041AE(a1);\n      v10 = gettext(\"invalid file number in field spec: %s\");\n      error(1, 0, v10, v9);\n      abort();\n    }\n    if ( a1[1] != 46 )\n    {\n      v7 = sub_4041AE(a1);\n      v8 = gettext(\"invalid field specifier: %s\");\n      error(1, 0, v8, v7);\n    }\n    *a2 = *a1 - 48;\n    result = sub_402DEB((__int64)(a1 + 2));\n    *a3 = result;\n  }\n  return result;\n}\n"], [4206536, "sub_402FC8", "_QWORD *__fastcall sub_402FC8(char *a1)\n{\n  char *v1; // rax\n  _QWORD *result; // rax\n  int v3; // [rsp+14h] [rbp-1Ch] BYREF\n  __int64 v4; // [rsp+18h] [rbp-18h] BYREF\n  char *s; // [rsp+20h] [rbp-10h]\n  char *v6; // [rsp+28h] [rbp-8h]\n\n  s = a1;\n  do\n  {\n    v6 = s;\n    s = strpbrk(s, \", \\t\");\n    if ( s )\n    {\n      v1 = s++;\n      *v1 = 0;\n    }\n    sub_402E87(v6, &v3, &v4);\n    result = sub_402D40(v3, v4);\n  }\n  while ( s );\n  return result;\n}\n"], [4206656, "sub_403040", "_QWORD *__fastcall sub_403040(_QWORD *a1, __int64 a2)\n{\n  char *v2; // rax\n  _QWORD *result; // rax\n  __int64 v4; // [rsp+10h] [rbp-10h]\n\n  if ( *a1 != -1LL && *a1 != a2 )\n  {\n    v4 = *a1 + 1LL;\n    v2 = gettext(\"incompatible join fields %lu, %lu\");\n    error(1, 0, v2, v4, a2 + 1);\n  }\n  result = a1;\n  *a1 = a2;\n  return result;\n}\n"], [4206785, "sub_4030C1", "unsigned __int64 __fastcall sub_4030C1(__int64 a1, _QWORD *a2, _DWORD *a3, _DWORD *a4, int *a5, _DWORD *a6, _DWORD *a7)\n{\n  int v7; // eax\n  __int64 v8; // rbx\n  char *v9; // rax\n  __int64 v10; // rax\n  __int64 v11; // rax\n  unsigned __int64 result; // rax\n  bool v16; // [rsp+33h] [rbp-1Dh]\n  int v17; // [rsp+34h] [rbp-1Ch]\n  char *v18; // [rsp+38h] [rbp-18h]\n\n  v17 = *a5;\n  if ( *a5 == 2 )\n  {\n    v16 = *a3 == 0;\n    v18 = (char *)a2[v16];\n    v7 = a3[v16];\n    if ( v7 == 1 )\n    {\n      --*a4;\n      v10 = sub_402DEB((__int64)v18);\n      sub_403040(&qword_60A200, v10);\n    }\n    else if ( v7 > 1 )\n    {\n      if ( v7 == 2 )\n      {\n        --a4[1];\n        v11 = sub_402DEB((__int64)v18);\n        sub_403040(&qword_60A208, v11);\n      }\n      else if ( v7 == 3 )\n      {\n        sub_402FC8(v18);\n      }\n    }\n    else if ( !v7 )\n    {\n      v8 = sub_4041AE(a1);\n      v9 = gettext(\"extra operand %s\");\n      error(0, 0, v9, v8);\n      sub_4018E6(1);\n    }\n    if ( !v16 )\n    {\n      *a3 = a3[1];\n      *a2 = a2[1];\n    }\n    v17 = 1;\n  }\n  a3[v17] = *a6;\n  a2[v17] = a1;\n  *a5 = v17 + 1;\n  result = (unsigned int)*a6;\n  if ( (_DWORD)result == 3 )\n  {\n    result = (unsigned __int64)a7;\n    *a7 = 3;\n  }\n  return result;\n}\n"], [4207235, "main", "void __fastcall __noreturn main(int a1, char **a2, char **a3)\n{\n  __int64 v3; // rbx\n  char *v4; // rax\n  char *v5; // rax\n  __int64 v6; // rax\n  __int64 v7; // rax\n  __int64 v8; // rax\n  __int64 v9; // rbx\n  char *v10; // rax\n  char *v11; // rax\n  int v12; // eax\n  char *v13; // rax\n  __int64 v14; // rbx\n  char *v15; // rax\n  FILE *v16; // rax\n  const char *v17; // rbx\n  int *v18; // rax\n  FILE *v19; // rax\n  const char *v20; // rbx\n  int *v21; // rax\n  char *v22; // rbx\n  int *v23; // rax\n  const char *v24; // rbx\n  int *v25; // rax\n  const char *v26; // rbx\n  int *v27; // rax\n  char v28; // [rsp+0h] [rbp-80h]\n  unsigned __int8 v29; // [rsp+2Ah] [rbp-56h]\n  bool v30; // [rsp+2Bh] [rbp-55h]\n  int v31; // [rsp+2Ch] [rbp-54h] BYREF\n  int v32; // [rsp+30h] [rbp-50h] BYREF\n  int v33; // [rsp+34h] [rbp-4Ch] BYREF\n  int i; // [rsp+38h] [rbp-48h]\n  int v35; // [rsp+3Ch] [rbp-44h]\n  _DWORD v36[4]; // [rsp+40h] [rbp-40h] BYREF\n  int v37[2]; // [rsp+50h] [rbp-30h] BYREF\n  __int64 v38; // [rsp+58h] [rbp-28h] BYREF\n  FILE *v39; // [rsp+60h] [rbp-20h]\n  FILE *v40; // [rsp+68h] [rbp-18h]\n\n  v32 = 0;\n  v37[0] = 0;\n  v37[1] = 0;\n  v33 = 0;\n  sub_4040A3(*a2, a2, a3);\n  setlocale(6, &locale);\n  bindtextdomain(\"coreutils\", \"/root/Product/coreutils/exe/share/locale\");\n  textdomain(\"coreutils\");\n  byte_60A300 = sub_403DFF(3LL);\n  sub_407340(sub_403B0D);\n  sub_407340(sub_4021C5);\n  byte_60A303 = 1;\n  byte_60A304 = 0;\n  byte_60A306 = 0;\n  byte_60A305[0] = 0;\n  dword_60A348 = 0;\n  while ( 1 )\n  {\n    v35 = getopt_long(a1, a2, \"-a:e:i1:2:j:o:t:v:\", &longopts, 0LL);\n    if ( v35 == -1 )\n    {\n      v32 = 0;\n      while ( optind < a1 )\n      {\n        v12 = optind++;\n        sub_4030C1((__int64)a2[v12], &qword_60A2E0, v36, v37, &v33, &v32, &v31);\n      }\n      if ( v33 != 2 )\n      {\n        if ( v33 )\n        {\n          v14 = sub_4041AE(a2[a1 - 1]);\n          v15 = gettext(\"missing operand after %s\");\n          error(0, 0, v15, v14);\n        }\n        else\n        {\n          v13 = gettext(\"missing operand\");\n          error(0, 0, v13);\n        }\n        sub_4018E6(1);\n      }\n      for ( i = 0; i <= 1; ++i )\n      {\n        if ( v37[i] )\n        {\n          sub_403040(&qword_60A200, i);\n          sub_403040(&qword_60A208, i);\n        }\n      }\n      if ( qword_60A200 == -1 )\n        qword_60A200 = 0LL;\n      if ( qword_60A208 == -1 )\n        qword_60A208 = 0LL;\n      if ( !strcmp(qword_60A2E0, \"-\") )\n        v16 = (FILE *)stdin;\n      else\n        v16 = (FILE *)sub_403D19(qword_60A2E0, \"r\");\n      v39 = v16;\n      if ( !v16 )\n      {\n        v17 = qword_60A2E0;\n        v18 = __errno_location();\n        error(1, *v18, \"%s\", v17);\n      }\n      if ( !strcmp(qword_60A2E8, \"-\") )\n        v19 = (FILE *)stdin;\n      else\n        v19 = (FILE *)sub_403D19(qword_60A2E8, \"r\");\n      v40 = v19;\n      if ( !v19 )\n      {\n        v20 = qword_60A2E8;\n        v21 = __errno_location();\n        error(1, *v21, \"%s\", v20);\n      }\n      if ( v39 == v40 )\n      {\n        v22 = gettext(\"both files cannot be standard input\");\n        v23 = __errno_location();\n        error(1, *v23, v22);\n      }\n      sub_4026DC(v39, v40);\n      if ( (unsigned int)sub_406B74(v39) )\n      {\n        v24 = qword_60A2E0;\n        v25 = __errno_location();\n        error(1, *v25, \"%s\", v24);\n      }\n      if ( (unsigned int)sub_406B74(v40) )\n      {\n        v26 = qword_60A2E8;\n        v27 = __errno_location();\n        error(1, *v27, \"%s\", v26);\n      }\n      if ( byte_60A305[0] || byte_60A306 )\n        exit(1);\n      exit(0);\n    }\n    v31 = 0;\n    if ( v35 == 105 )\n    {\n      byte_60A390 = 1;\n      goto LABEL_65;\n    }\n    if ( v35 > 105 )\n    {\n      if ( v35 == 118 )\n      {\n        byte_60A303 = 0;\nLABEL_25:\n        if ( (unsigned int)sub_406708(optarg, 0LL, 10LL, &v38, &locale) || v38 != 1 && v38 != 2 )\n        {\n          v3 = sub_4041AE(optarg);\n          v4 = gettext(\"invalid field number: %s\");\n          error(1, 0, v4, v3);\n        }\n        if ( v38 == 1 )\n          byte_60A301 = 1;\n        else\n          byte_60A302 = 1;\n        goto LABEL_65;\n      }\n      if ( v35 > 118 )\n      {\n        switch ( v35 )\n        {\n          case 129:\n            dword_60A348 = 2;\n            break;\n          case 130:\n            byte_60A391 = 1;\n            break;\n          case 128:\n            dword_60A348 = 1;\n            break;\n          default:\n            goto LABEL_64;\n        }\n      }\n      else\n      {\n        switch ( v35 )\n        {\n          case 'o':\n            if ( !strcmp(optarg, \"auto\") )\n            {\n              byte_60A310 = 1;\n            }\n            else\n            {\n              sub_402FC8(optarg);\n              v31 = 3;\n            }\n            break;\n          case 't':\n            v29 = *optarg;\n            if ( *optarg )\n            {\n              if ( optarg[1] )\n              {\n                if ( !strcmp(optarg, \"\\\\0\") )\n                {\n                  v29 = 0;\n                }\n                else\n                {\n                  v9 = sub_4041AE(optarg);\n                  v10 = gettext(\"multi-character tab %s\");\n                  error(1, 0, v10, v9);\n                }\n              }\n            }\n            else\n            {\n              v29 = 10;\n            }\n            if ( c >= 0 && v29 != c )\n            {\n              v11 = gettext(\"incompatible tabs\");\n              error(1, 0, v11);\n            }\n            c = v29;\n            break;\n          case 'j':\n            if ( (*optarg == 49 || *optarg == 50) && !optarg[1] && a2[optind - 1] + 2 == optarg )\n            {\n              v30 = *optarg == 50;\n              ++v37[v30];\n              v31 = v30 + 1;\n            }\n            else\n            {\n              v8 = sub_402DEB((__int64)optarg);\n              sub_403040(&qword_60A200, v8);\n              sub_403040(&qword_60A208, qword_60A200);\n            }\n            break;\n          default:\n            goto LABEL_64;\n        }\n      }\n    }\n    else\n    {\n      if ( v35 == 49 )\n      {\n        v6 = sub_402DEB((__int64)optarg);\n        sub_403040(&qword_60A200, v6);\n        goto LABEL_65;\n      }\n      if ( v35 > 49 )\n      {\n        switch ( v35 )\n        {\n          case 'a':\n            goto LABEL_25;\n          case 'e':\n            if ( s1 && strcmp(s1, optarg) )\n            {\n              v5 = gettext(\"conflicting empty-field replacement strings\");\n              error(1, 0, v5);\n            }\n            s1 = optarg;\n            break;\n          case '2':\n            v7 = sub_402DEB((__int64)optarg);\n            sub_403040(&qword_60A208, v7);\n            break;\n          default:\n            goto LABEL_64;\n        }\n      }\n      else\n      {\n        if ( v35 == -130 )\n          sub_4018E6(0);\n        if ( v35 != 1 )\n        {\n          if ( v35 == -131 )\n          {\n            sub_40609E(\n              (_DWORD)stdout,\n              (unsigned int)\"join\",\n              (unsigned int)\"GNU coreutils\",\n              (_DWORD)off_60A220,\n              (unsigned int)\"Mike Haertel\",\n              0,\n              v28);\n            exit(0);\n          }\nLABEL_64:\n          sub_4018E6(1);\n        }\n        sub_4030C1((__int64)optarg, &qword_60A2E0, v36, v37, &v33, &v32, &v31);\n      }\n    }\nLABEL_65:\n    v32 = v31;\n  }\n}\n"], [4209400, "sub_403AF8", "__int64 __fastcall sub_403AF8(unsigned __int8 a1)\n{\n  __int64 result; // rax\n\n  result = a1;\n  byte_60A3A0 = a1;\n  return result;\n}\n"], [4209421, "sub_403B0D", "__int64 sub_403B0D()\n{\n  const char *v0; // rbx\n  int *v1; // rax\n  int *v2; // rax\n  __int64 result; // rax\n  char *v4; // [rsp+8h] [rbp-18h]\n\n  if ( (unsigned int)sub_407019(stdout) && (byte_60A3A0 != 1 || *__errno_location() != 32) )\n  {\n    v4 = gettext(\"write error\");\n    if ( qword_60A398 )\n    {\n      v0 = (const char *)sub_4057C7(qword_60A398);\n      v1 = __errno_location();\n      error(0, *v1, \"%s: %s\", v0, v4);\n    }\n    else\n    {\n      v2 = __errno_location();\n      error(0, *v2, \"%s\", v4);\n    }\n    _exit(status);\n  }\n  result = sub_407019(stderr);\n  if ( (_DWORD)result )\n    _exit(status);\n  return result;\n}\n"], [4209656, "sub_403BF8", "_BYTE *__fastcall sub_403BF8(_BYTE *a1)\n{\n  char v2; // [rsp+17h] [rbp-11h]\n  _BYTE *i; // [rsp+20h] [rbp-8h]\n\n  v2 = 0;\n  while ( *a1 == 47 )\n    ++a1;\n  for ( i = a1; *i; ++i )\n  {\n    if ( *i == 47 )\n    {\n      v2 = 1;\n    }\n    else if ( v2 )\n    {\n      a1 = i;\n      v2 = 0;\n    }\n  }\n  return a1;\n}\n"], [4209761, "sub_403C61", "size_t __fastcall sub_403C61(const char *a1)\n{\n  size_t i; // [rsp+10h] [rbp-10h]\n\n  for ( i = strlen(a1); i > 1 && a1[i - 1] == 47; --i )\n    ;\n  return i;\n}\n"], [4209839, "sub_403CAF", "int __fastcall sub_403CAF(int a1, off_t a2, off_t a3, int a4)\n{\n  return posix_fadvise(a1, a2, a3, a4);\n}\n"], [4209887, "sub_403CDF", "void __fastcall sub_403CDF(FILE *a1, int a2)\n{\n  int v2; // eax\n\n  if ( a1 )\n  {\n    v2 = fileno(a1);\n    sub_403CAF(v2, 0LL, 0LL, a2);\n  }\n}\n"], [4209945, "sub_403D19", "FILE *__fastcall sub_403D19(const char *a1, const char *a2)\n{\n  int v3; // [rsp+18h] [rbp-18h]\n  int fd; // [rsp+1Ch] [rbp-14h]\n  int v5; // [rsp+20h] [rbp-10h]\n  int v6; // [rsp+24h] [rbp-Ch]\n  FILE *stream; // [rsp+28h] [rbp-8h]\n\n  stream = fopen(a1, a2);\n  if ( !stream )\n    return stream;\n  v3 = fileno(stream);\n  if ( v3 < 0 || v3 > 2 )\n    return stream;\n  fd = sub_405946((unsigned int)v3);\n  if ( fd < 0 )\n  {\n    v5 = *__errno_location();\n    sub_406B74(stream);\n    *__errno_location() = v5;\n    return 0LL;\n  }\n  if ( !(unsigned int)sub_406B74(stream) )\n  {\n    stream = fdopen(fd, a2);\n    if ( stream )\n      return stream;\n  }\n  v6 = *__errno_location();\n  close(fd);\n  *__errno_location() = v6;\n  return 0LL;\n}\n"], [4210175, "sub_403DFF", "__int64 __fastcall sub_403DFF(int a1)\n{\n  unsigned __int8 v2; // [rsp+17h] [rbp-9h]\n  const char *s1; // [rsp+18h] [rbp-8h]\n\n  v2 = 1;\n  s1 = setlocale(a1, 0LL);\n  if ( s1 && (!strcmp(s1, \"C\") || !strcmp(s1, \"POSIX\")) )\n    v2 = 0;\n  return v2;\n}\n"], [4210268, "sub_403E5C", "void *__fastcall sub_403E5C(void *a1)\n{\n  return memset(a1, 0, 0x18uLL);\n}\n"], [4210304, "sub_403E80", "__int64 __fastcall sub_403E80(__int64 a1, __int64 a2)\n{\n  return sub_403EAA(a1, a2, 10LL);\n}\n"], [4210346, "sub_403EAA", "__int64 *__fastcall sub_403EAA(__int64 *a1, FILE *a2, char a3)\n{\n  _BYTE *v4; // rax\n  int v6; // [rsp+2Ch] [rbp-24h]\n  __int64 v7; // [rsp+30h] [rbp-20h]\n  _BYTE *v8; // [rsp+38h] [rbp-18h]\n  __int64 v9; // [rsp+40h] [rbp-10h]\n  __int64 v10; // [rsp+48h] [rbp-8h]\n\n  v7 = a1[2];\n  v8 = (_BYTE *)v7;\n  v9 = *a1 + v7;\n  if ( feof_unlocked(a2) )\n    return 0LL;\n  while ( 1 )\n  {\n    v6 = getc_unlocked(a2);\n    if ( v6 == -1 )\n      break;\nLABEL_9:\n    if ( v8 == (_BYTE *)v9 )\n    {\n      v10 = *a1;\n      v7 = sub_40639C(v7, a1);\n      v8 = (_BYTE *)(v7 + v10);\n      a1[2] = v7;\n      v9 = *a1 + v7;\n    }\n    v4 = v8++;\n    *v4 = v6;\n    if ( a3 == v6 )\n      goto LABEL_12;\n  }\n  if ( v8 == (_BYTE *)v7 || ferror_unlocked(a2) )\n    return 0LL;\n  if ( *(v8 - 1) != a3 )\n  {\n    v6 = a3;\n    goto LABEL_9;\n  }\nLABEL_12:\n  a1[1] = (__int64)&v8[-v7];\n  return a1;\n}\n"], [4210667, "sub_403FEB", "void __fastcall sub_403FEB(__int64 a1)\n{\n  free(*(void **)(a1 + 16));\n}\n"], [4210697, "sub_404009", "__int64 __fastcall sub_404009(__int64 a1, __int64 a2, unsigned __int64 a3)\n{\n  unsigned __int8 v5; // [rsp+2Bh] [rbp-25h]\n  int v6; // [rsp+2Ch] [rbp-24h]\n  unsigned int v7; // [rsp+34h] [rbp-1Ch]\n  unsigned __int64 i; // [rsp+38h] [rbp-18h]\n\n  for ( i = 0LL; i < a3; ++i )\n  {\n    v5 = *(_BYTE *)(a2 + i);\n    v6 = toupper(*(unsigned __int8 *)(a1 + i));\n    v7 = v6 - toupper(v5);\n    if ( v7 )\n      return v7;\n  }\n  return 0LL;\n}\n"], [4210851, "sub_4040A3", "char *__fastcall sub_4040A3(const char *a1)\n{\n  char *v1; // rax\n  char *result; // rax\n  char *s; // [rsp+8h] [rbp-18h]\n  char *v4; // [rsp+10h] [rbp-10h]\n  char *s1; // [rsp+18h] [rbp-8h]\n\n  s = (char *)a1;\n  if ( !a1 )\n  {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\", 1uLL, 0x37uLL, stderr);\n    abort();\n  }\n  v4 = strrchr(a1, 47);\n  if ( v4 )\n    v1 = v4 + 1;\n  else\n    v1 = (char *)a1;\n  s1 = v1;\n  if ( v1 - a1 > 6 && !strncmp(v1 - 7, \"/.libs/\", 7uLL) )\n  {\n    s = s1;\n    if ( !strncmp(s1, \"lt-\", 3uLL) )\n    {\n      s = s1 + 3;\n      program_invocation_short_name = (__int64)(s1 + 3);\n    }\n  }\n  qword_60A3A8 = (__int64)s;\n  result = s;\n  program_invocation_name = (__int64)s;\n  return result;\n}\n"], [4211082, "sub_40418A", "__int64 __fastcall sub_40418A(unsigned int a1, __int64 a2)\n{\n  return sub_405639(a1, 6LL, a2);\n}\n"], [4211118, "sub_4041AE", "__int64 __fastcall sub_4041AE(__int64 a1)\n{\n  return sub_40418A(0, a1);\n}\n"], [4211149, "sub_4041CD", "__int64 __fastcall sub_4041CD(__int64 *a1)\n{\n  __int64 *v1; // rax\n  int v3; // [rsp+14h] [rbp-Ch]\n  __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v3 = *__errno_location();\n  if ( a1 )\n    v1 = a1;\n  else\n    v1 = &qword_60A3C0;\n  v4 = sub_40642A(v1, 56LL);\n  *__errno_location() = v3;\n  return v4;\n}\n"], [4211222, "sub_404216", "__int64 __fastcall sub_404216(__int64 *a1)\n{\n  __int64 *v1; // rax\n\n  if ( a1 )\n    v1 = a1;\n  else\n    v1 = &qword_60A3C0;\n  return *(unsigned int *)v1;\n}\n"], [4211252, "sub_404234", "__int64 *__fastcall sub_404234(__int64 *a1, int a2)\n{\n  __int64 *result; // rax\n\n  if ( a1 )\n    result = a1;\n  else\n    result = &qword_60A3C0;\n  *(_DWORD *)result = a2;\n  return result;\n}\n"], [4211288, "sub_404258", "__int64 __fastcall sub_404258(__int64 *a1, unsigned __int8 a2, char a3)\n{\n  __int64 *v3; // rax\n  unsigned int v5; // [rsp+24h] [rbp-Ch]\n\n  if ( a1 )\n    v3 = a1;\n  else\n    v3 = &qword_60A3C0;\n  v5 = (*((_DWORD *)v3 + (a2 >> 5) + 2) >> (a2 & 0x1F)) & 1;\n  *((_DWORD *)v3 + (a2 >> 5) + 2) ^= (v5 ^ a3 & 1) << (a2 & 0x1F);\n  return v5;\n}\n"], [4211424, "sub_4042E0", "__int64 __fastcall sub_4042E0(__int64 *a1, int a2)\n{\n  __int64 *v3; // [rsp+4h] [rbp-18h]\n  unsigned int v4; // [rsp+18h] [rbp-4h]\n\n  v3 = a1;\n  if ( !a1 )\n    v3 = &qword_60A3C0;\n  v4 = *((_DWORD *)v3 + 1);\n  *((_DWORD *)v3 + 1) = a2;\n  return v4;\n}\n"], [4211475, "sub_404313", "__int64 *__fastcall sub_404313(__int64 *a1, __int64 a2, __int64 a3)\n{\n  __int64 *result; // rax\n  __int64 *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = a1;\n  if ( !a1 )\n    v4 = &qword_60A3C0;\n  *(_DWORD *)v4 = 8;\n  if ( !a2 || !a3 )\n    abort();\n  v4[5] = a2;\n  result = v4;\n  v4[6] = a3;\n  return result;\n}\n"], [4211565, "sub_40436D", "_QWORD *__fastcall sub_40436D(_QWORD *a1, int a2)\n{\n  __int64 v3[7]; // [rsp+10h] [rbp-40h] BYREF\n\n  memset(v3, 0, sizeof(v3));\n  if ( a2 == 8 )\n    abort();\n  LODWORD(v3[0]) = a2;\n  *a1 = v3[0];\n  a1[1] = v3[1];\n  a1[2] = v3[2];\n  a1[3] = v3[3];\n  a1[4] = v3[4];\n  a1[5] = v3[5];\n  a1[6] = v3[6];\n  return a1;\n}\n"], [4211685, "sub_4043E5", "char *__fastcall sub_4043E5(const char *a1, int a2)\n{\n  char *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = gettext(a1);\n  if ( v3 == a1 && a2 == 7 )\n    v3 = (char *)L\"\\\"`'\";\n  return v3;\n}\n"], [4211746, "sub_404422", "unsigned __int64 __fastcall sub_404422(__int64 a1, unsigned __int64 a2, __int64 a3, size_t a4, unsigned int a5, int a6, __int64 a7, char *a8, char *a9)\n{\n  int v9; // eax\n  bool v10; // al\n  int v11; // eax\n  char v20; // [rsp+65h] [rbp-6Bh]\n  bool v21; // [rsp+66h] [rbp-6Ah]\n  unsigned __int8 v22; // [rsp+67h] [rbp-69h]\n  char v23; // [rsp+68h] [rbp-68h]\n  char v24; // [rsp+69h] [rbp-67h]\n  bool v25; // [rsp+6Ah] [rbp-66h]\n  bool v26; // [rsp+6Bh] [rbp-65h]\n  wchar_t pwc; // [rsp+6Ch] [rbp-64h] BYREF\n  __int64 i; // [rsp+70h] [rbp-60h]\n  unsigned __int64 v29; // [rsp+78h] [rbp-58h]\n  char *s; // [rsp+80h] [rbp-50h]\n  size_t n; // [rsp+88h] [rbp-48h]\n  unsigned __int64 v32; // [rsp+90h] [rbp-40h]\n  unsigned __int64 j; // [rsp+98h] [rbp-38h]\n  size_t v34; // [rsp+A0h] [rbp-30h]\n  unsigned __int64 v35; // [rsp+A8h] [rbp-28h]\n  mbstate_t p; // [rsp+B0h] [rbp-20h] BYREF\n  unsigned __int64 v37; // [rsp+B8h] [rbp-18h]\n\n  v37 = __readfsqword(0x28u);\n  v29 = 0LL;\n  s = 0LL;\n  n = 0LL;\n  v20 = 0;\n  v26 = __ctype_get_mb_cur_max() == 1;\n  v21 = (a6 & 2) != 0;\n  if ( a5 == 3 )\n    goto LABEL_11;\n  if ( a5 > 3 )\n  {\n    if ( a5 == 5 )\n    {\n      v20 = 1;\n      v21 = 0;\n      goto LABEL_33;\n    }\n    if ( a5 >= 5 )\n    {\n      if ( a5 > 8 )\n        abort();\n      if ( a5 != 8 )\n      {\n        a8 = sub_4043E5((const char *)L\"`'\", a5);\n        a9 = sub_4043E5((const char *)L\"'\", a5);\n      }\n      if ( (a6 & 2) == 0 )\n      {\n        for ( s = a8; *s; ++s )\n        {\n          if ( v29 < a2 )\n            *(_BYTE *)(v29 + a1) = *s;\n          ++v29;\n        }\n      }\n      v20 = 1;\n      s = a9;\n      n = strlen(a9);\n      goto LABEL_33;\n    }\n    a5 = 3;\n    v21 = 1;\nLABEL_11:\n    if ( !v21 )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(a1 + v29) = 34;\n      ++v29;\n    }\n    v20 = 1;\n    s = (char *)L\"\\\"`'\";\n    n = 1LL;\n    goto LABEL_33;\n  }\n  if ( a5 == 1 )\n  {\n    a5 = 2;\n    v21 = 1;\n    goto LABEL_27;\n  }\n  if ( a5 > 1 )\n  {\nLABEL_27:\n    if ( !v21 )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(a1 + v29) = 39;\n      ++v29;\n    }\n    s = (_BYTE *)(L\"\\\"`'\" + 4);\n    n = 1LL;\n    goto LABEL_33;\n  }\n  v21 = 0;\nLABEL_33:\n  for ( i = 0LL; a4 == -1LL ? *(_BYTE *)(a3 + i) != 0 : i != a4; ++i )\n  {\n    v24 = 0;\n    if ( v20 && n && i + n <= a4 && !memcmp((const void *)(a3 + i), s, n) )\n    {\n      if ( v21 )\n        return sub_404422(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n      v24 = 1;\n    }\n    v22 = *(_BYTE *)(a3 + i);\n    if ( v22 > 0x3Au )\n    {\n      if ( v22 == 94 )\n        goto LABEL_144;\n      if ( v22 > 0x5Eu )\n      {\n        if ( v22 <= 0x7Au )\n        {\n          if ( v22 >= 0x61u || v22 == 95 )\n            goto LABEL_206;\n          goto LABEL_144;\n        }\n        if ( v22 != 124 )\n        {\n          if ( v22 < 0x7Cu || v22 == 125 )\n          {\n            if ( a4 == -1LL )\n              v10 = *(_BYTE *)(a3 + 1) != 0;\n            else\n              v10 = a4 != 1;\n            if ( v10 )\n              goto LABEL_206;\n          }\n          else if ( v22 != 126 )\n          {\nLABEL_157:\n            if ( v26 )\n            {\n              v32 = 1LL;\n              v25 = ((*__ctype_b_loc())[v22] & 0x4000) != 0;\n            }\n            else\n            {\n              memset(&p, 0, sizeof(p));\n              v32 = 0LL;\n              v25 = 1;\n              if ( a4 == -1LL )\n                a4 = strlen((const char *)a3);\n              do\n              {\n                v34 = mbrtowc(&pwc, (const char *)(v32 + i + a3), a4 - (v32 + i), &p);\n                if ( !v34 )\n                  break;\n                if ( v34 == -1LL )\n                {\n                  v25 = 0;\n                  break;\n                }\n                if ( v34 == -2LL )\n                {\n                  v25 = 0;\n                  while ( i + v32 < a4 && *(_BYTE *)(v32 + i + a3) )\n                    ++v32;\n                  break;\n                }\n                if ( v21 && a5 == 2 )\n                {\n                  for ( j = 1LL; j < v34; ++j )\n                  {\n                    v11 = *(char *)(j + v32 + i + a3);\n                    if ( v11 == 94 )\n                      return sub_404422(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    if ( v11 > 94 )\n                    {\n                      if ( v11 == 96 || v11 == 124 )\n                        return sub_404422(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    }\n                    else if ( (unsigned int)(v11 - 91) <= 1 )\n                    {\n                      return sub_404422(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    }\n                  }\n                }\n                if ( !iswprint(pwc) )\n                  v25 = 0;\n                v32 += v34;\n              }\n              while ( !mbsinit(&p) );\n            }\n            if ( v32 > 1 || v20 && !v25 )\n            {\n              v35 = i + v32;\n              while ( 1 )\n              {\n                if ( v20 && !v25 )\n                {\n                  if ( v21 )\n                    return sub_404422(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                  if ( v29 < a2 )\n                    *(_BYTE *)(a1 + v29) = 92;\n                  if ( ++v29 < a2 )\n                    *(_BYTE *)(v29 + a1) = (v22 >> 6) + 48;\n                  if ( ++v29 < a2 )\n                    *(_BYTE *)(v29 + a1) = ((v22 >> 3) & 7) + 48;\n                  ++v29;\n                  v22 = (v22 & 7) + 48;\n                }\n                else if ( v24 )\n                {\n                  if ( v29 < a2 )\n                    *(_BYTE *)(a1 + v29) = 92;\n                  ++v29;\n                  v24 = 0;\n                }\n                if ( i + 1 >= v35 )\n                  break;\n                if ( v29 < a2 )\n                  *(_BYTE *)(v29 + a1) = v22;\n                ++v29;\n                ++i;\n                v22 = *(_BYTE *)(a3 + i);\n              }\n              goto LABEL_215;\n            }\n            goto LABEL_206;\n          }\n          goto LABEL_143;\n        }\nLABEL_144:\n        if ( a5 == 2 && v21 )\n          return sub_404422(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        goto LABEL_206;\n      }\n      if ( v22 > 0x5Au )\n      {\n        if ( v22 == 92 )\n        {\n          v23 = *(_BYTE *)(a3 + i);\n          if ( v20 && v21 && n )\n            goto LABEL_215;\n          goto LABEL_134;\n        }\n        if ( v22 <= 0x5Cu )\n          goto LABEL_144;\n      }\n      else\n      {\n        if ( v22 >= 0x41u )\n          goto LABEL_206;\n        if ( v22 <= 0x3Eu )\n          goto LABEL_144;\n        if ( v22 != 63 )\n          goto LABEL_157;\n        if ( a5 == 2 )\n        {\n          if ( v21 )\n            return sub_404422(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        }\n        else if ( a5 == 3 && (a6 & 4) != 0 && i + 2 < a4 && *(_BYTE *)(i + 1 + a3) == 63 )\n        {\n          v9 = *(char *)(i + 2 + a3);\n          if ( v9 != 45 )\n          {\n            if ( v9 > 45 )\n            {\n              if ( v9 != 47 && (v9 < 47 || (unsigned int)(v9 - 60) > 2) )\n                goto LABEL_206;\n            }\n            else if ( v9 != 33 && (v9 < 33 || (unsigned int)(v9 - 39) > 2) )\n            {\n              goto LABEL_206;\n            }\n          }\n          if ( v21 )\n            return sub_404422(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          v22 = *(_BYTE *)(i + 2 + a3);\n          i += 2LL;\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 63;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 34;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 34;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 63;\n          ++v29;\n        }\n      }\n    }\n    else\n    {\n      if ( v22 >= 0x2Bu )\n        goto LABEL_206;\n      if ( v22 > 0x22u )\n      {\n        if ( v22 != 38 )\n        {\n          if ( v22 > 0x26u )\n          {\n            if ( v22 == 39 )\n            {\n              if ( a5 == 2 )\n              {\n                if ( v21 )\n                  return sub_404422(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                if ( v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 39;\n                if ( ++v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 92;\n                if ( ++v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 39;\n                ++v29;\n              }\n              goto LABEL_206;\n            }\n            goto LABEL_144;\n          }\n          if ( v22 != 36 )\n          {\n            if ( v22 > 0x24u )\n              goto LABEL_206;\nLABEL_143:\n            if ( i )\n              goto LABEL_206;\n          }\n        }\n        goto LABEL_144;\n      }\n      if ( v22 >= 0x20u )\n        goto LABEL_144;\n      if ( v22 == 9 )\n      {\n        v23 = 116;\n        goto LABEL_134;\n      }\n      if ( v22 > 9u )\n      {\n        if ( v22 == 11 )\n        {\n          v23 = 118;\n        }\n        else\n        {\n          if ( v22 < 0xBu )\n          {\n            v23 = 110;\n            goto LABEL_134;\n          }\n          if ( v22 == 12 )\n          {\n            v23 = 102;\n          }\n          else\n          {\n            if ( v22 != 13 )\n              goto LABEL_157;\n            v23 = 114;\nLABEL_134:\n            if ( a5 == 2 && v21 )\n              return sub_404422(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          }\n        }\nLABEL_136:\n        if ( v20 )\n        {\n          v22 = v23;\nLABEL_211:\n          if ( v21 )\n            return sub_404422(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 92;\n          ++v29;\n          goto LABEL_215;\n        }\n        goto LABEL_206;\n      }\n      if ( v22 == 7 )\n      {\n        v23 = 97;\n        goto LABEL_136;\n      }\n      if ( v22 > 7u )\n      {\n        v23 = 98;\n        goto LABEL_136;\n      }\n      if ( v22 )\n        goto LABEL_157;\n      if ( v20 )\n      {\n        if ( v21 )\n          return sub_404422(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        if ( v29 < a2 )\n          *(_BYTE *)(a1 + v29) = 92;\n        ++v29;\n        if ( i + 1 < a4 && *(char *)(i + 1 + a3) > 47 && *(char *)(i + 1 + a3) <= 57 )\n        {\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 48;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 48;\n          ++v29;\n        }\n        v22 = 48;\n      }\n      else if ( (a6 & 1) != 0 )\n      {\n        continue;\n      }\n    }\nLABEL_206:\n    if ( (v20 == 1 || v21) && a7 && (*(_DWORD *)(4LL * (v22 >> 5) + a7) & (1 << (v22 & 0x1F))) != 0 || v24 == 1 )\n      goto LABEL_211;\nLABEL_215:\n    if ( v29 < a2 )\n      *(_BYTE *)(v29 + a1) = v22;\n    ++v29;\n  }\n  if ( !v29 && a5 == 2 && v21 )\n    return sub_404422(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n  if ( s && !v21 )\n  {\n    while ( *s )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(v29 + a1) = *s;\n      ++v29;\n      ++s;\n    }\n  }\n  if ( v29 < a2 )\n    *(_BYTE *)(a1 + v29) = 0;\n  return v29;\n}\n"], [4214893, "sub_40506D", "unsigned __int64 __fastcall sub_40506D(__int64 a1, unsigned __int64 a2, __int64 a3, size_t a4, __int64 *a5)\n{\n  __int64 *v5; // rax\n  int v9; // [rsp+4Ch] [rbp-14h]\n  __int64 *v10; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+58h] [rbp-8h]\n\n  if ( a5 )\n    v5 = a5;\n  else\n    v5 = &qword_60A3C0;\n  v10 = v5;\n  v9 = *__errno_location();\n  v11 = sub_404422(\n          a1,\n          a2,\n          a3,\n          a4,\n          *(_DWORD *)v10,\n          *((_DWORD *)v10 + 1),\n          (__int64)(v10 + 1),\n          (char *)v10[5],\n          (char *)v10[6]);\n  *__errno_location() = v9;\n  return v11;\n}\n"], [4215053, "sub_40510D", "__int64 __fastcall sub_40510D(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_40513F(a1, a2, 0LL, a3);\n}\n"], [4215103, "sub_40513F", "__int64 __fastcall sub_40513F(__int64 a1, size_t a2, _QWORD *a3, __int64 *a4)\n{\n  __int64 *v4; // rax\n  int v7; // [rsp+40h] [rbp-20h]\n  int v8; // [rsp+44h] [rbp-1Ch]\n  __int64 *v9; // [rsp+48h] [rbp-18h]\n  unsigned __int64 v10; // [rsp+50h] [rbp-10h]\n  __int64 v11; // [rsp+58h] [rbp-8h]\n\n  if ( a4 )\n    v4 = a4;\n  else\n    v4 = &qword_60A3C0;\n  v9 = v4;\n  v7 = *__errno_location();\n  v8 = *((_DWORD *)v9 + 1) | (a3 == 0LL);\n  v10 = sub_404422(0LL, 0LL, a1, a2, *(_DWORD *)v9, v8, (__int64)(v9 + 1), (char *)v9[5], (char *)v9[6]) + 1;\n  v11 = sub_4062EC(v10);\n  sub_404422(v11, v10, a1, a2, *(_DWORD *)v9, v8, (__int64)(v9 + 1), (char *)v9[5], (char *)v9[6]);\n  *__errno_location() = v7;\n  if ( a3 )\n    *a3 = v10 - 1;\n  return v11;\n}\n"], [4215403, "sub_40526B", "void sub_40526B()\n{\n  unsigned int i; // [rsp+4h] [rbp-Ch]\n  void **ptr; // [rsp+8h] [rbp-8h]\n\n  ptr = (void **)off_60A250;\n  for ( i = 1; i < dword_60A230; ++i )\n    free(ptr[2 * i + 1]);\n  if ( ptr[1] != &unk_60A400 )\n  {\n    free(ptr[1]);\n    qword_60A240 = 256LL;\n    off_60A248 = &unk_60A400;\n  }\n  if ( ptr != (void **)&qword_60A240 )\n  {\n    free(ptr);\n    off_60A250 = &qword_60A240;\n  }\n  dword_60A230 = 1;\n}\n"], [4215574, "sub_405316", "void *__fastcall sub_405316(int a1, __int64 a2, size_t a3, __int64 a4)\n{\n  __int64 *v4; // rax\n  void *v5; // rdx\n  bool v9; // [rsp+4Bh] [rbp-45h]\n  int v10; // [rsp+4Ch] [rbp-44h]\n  int v11; // [rsp+54h] [rbp-3Ch]\n  __int64 *v12; // [rsp+58h] [rbp-38h]\n  void *ptr; // [rsp+60h] [rbp-30h]\n  __int64 v14; // [rsp+68h] [rbp-28h]\n  unsigned __int64 v15; // [rsp+70h] [rbp-20h]\n  unsigned __int64 v16; // [rsp+70h] [rbp-20h]\n  unsigned __int64 v17; // [rsp+78h] [rbp-18h]\n\n  v10 = *__errno_location();\n  v12 = off_60A250;\n  if ( a1 < 0 )\n    abort();\n  if ( dword_60A230 <= (unsigned int)a1 )\n  {\n    v14 = (unsigned int)(a1 + 1);\n    v9 = off_60A250 == &qword_60A240;\n    if ( off_60A250 == &qword_60A240 )\n      v4 = 0LL;\n    else\n      v4 = off_60A250;\n    v12 = (__int64 *)sub_40633B(v4, 16 * v14);\n    off_60A250 = v12;\n    if ( v9 )\n    {\n      v5 = off_60A248;\n      *v12 = qword_60A240;\n      v12[1] = (__int64)v5;\n    }\n    memset(&v12[2 * (unsigned int)dword_60A230], 0, 16 * (v14 - (unsigned int)dword_60A230));\n    dword_60A230 = a1 + 1;\n  }\n  v15 = v12[2 * a1];\n  ptr = (void *)v12[2 * a1 + 1];\n  v11 = *(_DWORD *)(a4 + 4) | 1;\n  v17 = sub_404422((__int64)ptr, v15, a2, a3, *(_DWORD *)a4, v11, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 48));\n  if ( v15 <= v17 )\n  {\n    v16 = v17 + 1;\n    v12[2 * a1] = v17 + 1;\n    if ( ptr != &unk_60A400 )\n      free(ptr);\n    ptr = (void *)sub_4062EC(v16);\n    v12[2 * a1 + 1] = (__int64)ptr;\n    sub_404422((__int64)ptr, v16, a2, a3, *(_DWORD *)a4, v11, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 48));\n  }\n  *__errno_location() = v10;\n  return ptr;\n}\n"], [4216220, "sub_40559C", "void *__fastcall sub_40559C(int a1, __int64 a2)\n{\n  return sub_405316(a1, a2, 0xFFFFFFFFFFFFFFFFLL, (__int64)&qword_60A3C0);\n}\n"], [4216263, "sub_4055C7", "void *__fastcall sub_4055C7(int a1, __int64 a2, size_t a3)\n{\n  return sub_405316(a1, a2, a3, (__int64)&qword_60A3C0);\n}\n"], [4216307, "sub_4055F3", "void *__fastcall sub_4055F3(__int64 a1)\n{\n  return sub_40559C(0, a1);\n}\n"], [4216338, "sub_405612", "void *__fastcall sub_405612(__int64 a1, size_t a2)\n{\n  return sub_4055C7(0, a1, a2);\n}\n"], [4216377, "sub_405639", "void *__fastcall sub_405639(int a1, int a2, __int64 a3)\n{\n  _QWORD v5[8]; // [rsp+10h] [rbp-40h] BYREF\n\n  sub_40436D(v5, a2);\n  return sub_405316(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)v5);\n}\n"], [4216442, "sub_40567A", "void *__fastcall sub_40567A(int a1, int a2, __int64 a3, size_t a4)\n{\n  _QWORD v7[8]; // [rsp+20h] [rbp-40h] BYREF\n\n  sub_40436D(v7, a2);\n  return sub_405316(a1, a3, a4, (__int64)v7);\n}\n"], [4216505, "sub_4056B9", "void *__fastcall sub_4056B9(int a1, __int64 a2)\n{\n  return sub_405639(0, a1, a2);\n}\n"], [4216541, "sub_4056DD", "void *__fastcall sub_4056DD(int a1, __int64 a2, size_t a3)\n{\n  return sub_40567A(0, a1, a2, a3);\n}\n"], [4216585, "sub_405709", "void *__fastcall sub_405709(__int64 a1, size_t a2, unsigned __int8 a3)\n{\n  __int64 v4[8]; // [rsp+20h] [rbp-40h] BYREF\n\n  v4[0] = qword_60A3C0;\n  v4[1] = qword_60A3C8;\n  v4[2] = qword_60A3D0;\n  v4[3] = qword_60A3D8;\n  v4[4] = qword_60A3E0;\n  v4[5] = qword_60A3E8;\n  v4[6] = qword_60A3F0;\n  sub_404258(v4, a3, 1);\n  return sub_405316(0, a1, a2, (__int64)v4);\n}\n"], [4216733, "sub_40579D", "void *__fastcall sub_40579D(__int64 a1, unsigned __int8 a2)\n{\n  return sub_405709(a1, 0xFFFFFFFFFFFFFFFFLL, a2);\n}\n"], [4216775, "sub_4057C7", "void *__fastcall sub_4057C7(__int64 a1)\n{\n  return sub_40579D(a1, 0x3Au);\n}\n"], [4216806, "sub_4057E6", "void *__fastcall sub_4057E6(__int64 a1, size_t a2)\n{\n  return sub_405709(a1, a2, 0x3Au);\n}\n"], [4216848, "sub_405810", "__int64 __fastcall sub_405810(unsigned int a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  return sub_405846(a1, a2, a3, a4, -1LL);\n}\n"], [4216902, "sub_405846", "void *__fastcall sub_405846(int a1, __int64 a2, __int64 a3, __int64 a4, size_t a5)\n{\n  __int64 v8[8]; // [rsp+30h] [rbp-40h] BYREF\n\n  v8[0] = qword_60A3C0;\n  v8[1] = qword_60A3C8;\n  v8[2] = qword_60A3D0;\n  v8[3] = qword_60A3D8;\n  v8[4] = qword_60A3E0;\n  v8[5] = qword_60A3E8;\n  v8[6] = qword_60A3F0;\n  sub_404313(v8, a2, a3);\n  return sub_405316(a1, a4, a5, (__int64)v8);\n}\n"], [4217053, "sub_4058DD", "__int64 __fastcall sub_4058DD(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_405810(0, a1, a2, a3);\n}\n"], [4217100, "sub_40590C", "void *__fastcall sub_40590C(__int64 a1, __int64 a2, __int64 a3, size_t a4)\n{\n  return sub_405846(0, a1, a2, a3, a4);\n}\n"], [4217158, "sub_405946", "__int64 __fastcall sub_405946(int a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  return sub_406C29(a1, 0, 3, a4, a5, a6);\n}\n"], [4217196, "sub_40596C", "int __fastcall sub_40596C(FILE *a1, const char *a2, const char *a3, const char *a4, __int64 *a5, unsigned __int64 a6)\n{\n  char *v6; // rax\n  char *v7; // rax\n  __int64 v8; // rbx\n  char *v9; // rax\n  __int64 v10; // r12\n  __int64 v11; // rbx\n  char *v12; // rax\n  __int64 v13; // r13\n  __int64 v14; // r12\n  __int64 v15; // rbx\n  char *v16; // rax\n  int result; // eax\n  __int64 v18; // r14\n  __int64 v19; // r13\n  __int64 v20; // r12\n  __int64 v21; // rbx\n  char *v22; // rax\n  __int64 v23; // r13\n  __int64 v24; // r15\n  __int64 v25; // r14\n  __int64 v26; // r12\n  __int64 v27; // rbx\n  char *v28; // rax\n  __int64 v29; // r14\n  __int64 v30; // r13\n  __int64 v31; // r15\n  __int64 v32; // r12\n  __int64 v33; // rbx\n  char *v34; // rax\n  __int64 v35; // r15\n  __int64 v36; // r14\n  __int64 v37; // r13\n  __int64 v38; // r12\n  __int64 v39; // rbx\n  char *v40; // rax\n  __int64 v41; // r15\n  __int64 v42; // r14\n  __int64 v43; // r13\n  __int64 v44; // r12\n  __int64 v45; // rbx\n  char *v46; // rax\n  __int64 v47; // r15\n  __int64 v48; // r14\n  __int64 v49; // r13\n  __int64 v50; // r12\n  __int64 v51; // rbx\n  char *v52; // rax\n  __int64 v53; // [rsp+30h] [rbp-80h]\n  __int64 v54; // [rsp+38h] [rbp-78h]\n  __int64 v55; // [rsp+38h] [rbp-78h]\n  __int64 v56; // [rsp+40h] [rbp-70h]\n  __int64 v57; // [rsp+40h] [rbp-70h]\n  __int64 v58; // [rsp+40h] [rbp-70h]\n  __int64 v59; // [rsp+48h] [rbp-68h]\n  __int64 v60; // [rsp+48h] [rbp-68h]\n  __int64 v61; // [rsp+48h] [rbp-68h]\n  __int64 v62; // [rsp+48h] [rbp-68h]\n\n  if ( a2 )\n    fprintf(a1, \"%s (%s) %s\\n\", a2, a3, a4);\n  else\n    fprintf(a1, \"%s %s\\n\", a3, a4);\n  v6 = gettext(\"(C)\");\n  fprintf(a1, \"Copyright %s %d Free Software Foundation, Inc.\", v6, 2011LL);\n  v7 = gettext(\n         \"\\n\"\n         \"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n         \"\\n\");\n  fputs_unlocked(v7, a1);\n  if ( a6 == 4 )\n  {\n    v18 = a5[3];\n    v19 = a5[2];\n    v20 = a5[1];\n    v21 = *a5;\n    v22 = gettext(\"Written by %s, %s, %s,\\nand %s.\\n\");\n    result = fprintf(a1, v22, v21, v20, v19, v18);\n  }\n  else if ( a6 > 4 )\n  {\n    if ( a6 == 7 )\n    {\n      v35 = a5[6];\n      v36 = a5[5];\n      v37 = a5[4];\n      v60 = a5[3];\n      v56 = a5[2];\n      v38 = a5[1];\n      v39 = *a5;\n      v40 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\");\n      result = fprintf(a1, v40, v39, v38, v56, v60, v37, v36, v35);\n    }\n    else if ( a6 > 7 )\n    {\n      if ( a6 == 8 )\n      {\n        v61 = a5[7];\n        v41 = a5[6];\n        v42 = a5[5];\n        v43 = a5[4];\n        v57 = a5[3];\n        v54 = a5[2];\n        v44 = a5[1];\n        v45 = *a5;\n        v46 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\");\n        result = fprintf(a1, v46, v45, v44, v54, v57, v43, v42, v41, v61);\n      }\n      else\n      {\n        v62 = a5[8];\n        v58 = a5[7];\n        v47 = a5[6];\n        v48 = a5[5];\n        v49 = a5[4];\n        v55 = a5[3];\n        v53 = a5[2];\n        v50 = a5[1];\n        v51 = *a5;\n        if ( a6 == 9 )\n          v52 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\");\n        else\n          v52 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\");\n        result = fprintf(a1, v52, v51, v50, v53, v55, v49, v48, v47, v58, v62);\n      }\n    }\n    else if ( a6 == 5 )\n    {\n      v23 = a5[4];\n      v24 = a5[3];\n      v25 = a5[2];\n      v26 = a5[1];\n      v27 = *a5;\n      v28 = gettext(\"Written by %s, %s, %s,\\n%s, and %s.\\n\");\n      result = fprintf(a1, v28, v27, v26, v25, v24, v23);\n    }\n    else\n    {\n      v29 = a5[5];\n      v30 = a5[4];\n      v59 = a5[3];\n      v31 = a5[2];\n      v32 = a5[1];\n      v33 = *a5;\n      v34 = gettext(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\");\n      result = fprintf(a1, v34, v33, v32, v31, v59, v30, v29);\n    }\n  }\n  else\n  {\n    switch ( a6 )\n    {\n      case 1uLL:\n        v8 = *a5;\n        v9 = gettext(\"Written by %s.\\n\");\n        result = fprintf(a1, v9, v8);\n        break;\n      case 0uLL:\n        abort();\n      case 2uLL:\n        v10 = a5[1];\n        v11 = *a5;\n        v12 = gettext(\"Written by %s and %s.\\n\");\n        result = fprintf(a1, v12, v11, v10);\n        break;\n      default:\n        v13 = a5[2];\n        v14 = a5[1];\n        v15 = *a5;\n        v16 = gettext(\"Written by %s, %s, and %s.\\n\");\n        result = fprintf(a1, v16, v15, v14, v13);\n        break;\n    }\n  }\n  return result;\n}\n"], [4218711, "sub_405F57", "int __fastcall sub_405F57(FILE *a1, const char *a2, const char *a3, const char *a4, __int64 *a5)\n{\n  unsigned __int64 i; // [rsp+38h] [rbp-8h]\n\n  for ( i = 0LL; a5[i]; ++i )\n    ;\n  return sub_40596C(a1, a2, a3, a4, a5, i);\n}\n"], [4218821, "sub_405FC5", "int __fastcall sub_405FC5(FILE *a1, const char *a2, const char *a3, const char *a4, unsigned int *a5)\n{\n  __int64 *v5; // rax\n  unsigned __int64 i; // [rsp+38h] [rbp-58h]\n  __int64 v8[10]; // [rsp+40h] [rbp-50h] BYREF\n\n  for ( i = 0LL; i <= 9; ++i )\n  {\n    if ( *a5 >= 0x30 )\n    {\n      v5 = (__int64 *)*((_QWORD *)a5 + 1);\n      *((_QWORD *)a5 + 1) = v5 + 1;\n    }\n    else\n    {\n      v5 = (__int64 *)(*((_QWORD *)a5 + 2) + *a5);\n      *a5 += 8;\n    }\n    v8[i] = *v5;\n    if ( !v8[i] )\n      break;\n  }\n  return sub_40596C(a1, a2, a3, a4, v8, i);\n}\n"], [4219038, "sub_40609E", "int sub_40609E(FILE *a1, const char *a2, const char *a3, const char *a4, ...)\n{\n  gcc_va_list va; // [rsp+28h] [rbp-C8h] BYREF\n\n  va_start(va, a4);\n  return sub_405FC5(a1, a2, a3, a4, (unsigned int *)va);\n}\n"], [4219220, "sub_406154", "int sub_406154()\n{\n  char *v0; // rax\n  char *v1; // rax\n  FILE *v2; // rbx\n  char *v3; // rax\n\n  v0 = gettext(\"\\nReport bugs to: %s\\n\");\n  printf(v0, \"bug-coreutils@gnu.org\");\n  v1 = gettext(\"%s home page: <%s>\\n\");\n  printf(v1, \"GNU coreutils\", \"http://www.gnu.org/software/coreutils/\");\n  v2 = stdout;\n  v3 = gettext(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\");\n  return fputs_unlocked(v3, v2);\n}\n"], [4219325, "sub_4061BD", "__int64 __fastcall sub_4061BD(unsigned __int64 a1, unsigned __int64 a2)\n{\n  if ( 0xFFFFFFFFFFFFFFFFLL / a2 < a1 )\n    sub_406488(a1, a2, 0xFFFFFFFFFFFFFFFFLL % a2);\n  return sub_406306(a2 * a1);\n}\n"], [4219387, "sub_4061FB", "__int64 __fastcall sub_4061FB(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)\n{\n  unsigned __int64 v3; // rax\n  unsigned __int64 v4; // rdx\n\n  v3 = 0xFFFFFFFFFFFFFFFFLL / a3;\n  v4 = 0xFFFFFFFFFFFFFFFFLL % a3;\n  if ( v3 < a2 )\n    sub_406488(a1, a2, v4);\n  return sub_40633B(a1, a3 * a2);\n}\n"], [4219463, "sub_406247", "__int64 __fastcall sub_406247(__int64 a1, unsigned __int64 *a2, unsigned __int64 a3)\n{\n  unsigned __int64 v3; // rdx\n  unsigned __int64 v6; // [rsp+28h] [rbp-8h]\n\n  v6 = *a2;\n  if ( a1 )\n  {\n    v3 = 0xAAAAAAAAAAAAAAAALL % a3;\n    if ( 0xAAAAAAAAAAAAAAAALL / a3 <= v6 )\n      sub_406488(a1, a2, v3);\n    v6 += (v6 + 1) >> 1;\n  }\n  else if ( !v6 )\n  {\n    v6 = (0x80 / a3 == 0) + 0x80 / a3;\n  }\n  *a2 = v6;\n  return sub_40633B(a1, a3 * v6);\n}\n"], [4219628, "sub_4062EC", "__int64 __fastcall sub_4062EC(__int64 a1)\n{\n  return sub_406306(a1);\n}\n"], [4219654, "sub_406306", "void *__fastcall sub_406306(size_t a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  void *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = malloc(a1);\n  if ( !v4 && a1 )\n    sub_406488(a1, a2, v2);\n  return v4;\n}\n"], [4219707, "sub_40633B", "void *__fastcall sub_40633B(void *a1, size_t a2)\n{\n  void *result; // rax\n  __int64 v3; // rdx\n  void *ptr; // [rsp+8h] [rbp-8h]\n\n  if ( a2 || !a1 )\n  {\n    ptr = realloc(a1, a2);\n    if ( !ptr )\n    {\n      if ( a2 )\n        sub_406488(a1, a2, v3);\n    }\n    result = ptr;\n  }\n  else\n  {\n    free(a1);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4219804, "sub_40639C", "__int64 __fastcall sub_40639C(__int64 a1, unsigned __int64 *a2)\n{\n  return sub_406247(a1, a2, 1uLL);\n}\n"], [4219846, "sub_4063C6", "void *__fastcall sub_4063C6(size_t a1, __int64 a2)\n{\n  void *v2; // rax\n\n  v2 = sub_406306(a1, a2);\n  return memset(v2, 0, a1);\n}\n"], [4219889, "sub_4063F1", "void *__fastcall sub_4063F1(size_t a1, size_t a2)\n{\n  __int64 v2; // rdx\n  void *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = calloc(a1, a2);\n  if ( !v4 )\n    sub_406488(a1, a2, v2);\n  return v4;\n}\n"], [4219946, "sub_40642A", "void *__fastcall sub_40642A(const void *a1, size_t a2)\n{\n  void *v2; // rax\n\n  v2 = sub_406306(a2, a2);\n  return memcpy(v2, a1, a2);\n}\n"], [4219995, "sub_40645B", "void *__fastcall sub_40645B(const char *a1)\n{\n  size_t v1; // rax\n\n  v1 = strlen(a1);\n  return sub_40642A(a1, v1 + 1);\n}\n"], [4220040, "sub_406488", "void __noreturn sub_406488()\n{\n  char *v0; // rax\n\n  v0 = gettext(\"memory exhausted\");\n  error(status, 0, \"%s\", v0);\n  abort();\n}\n"], [4220093, "sub_4064BD", "void __fastcall sub_4064BD(int a1, __int64 a2, size_t a3, __int64 a4, size_t a5)\n{\n  char *v5; // rax\n  char *v6; // rax\n  void *v7; // r12\n  void *v8; // rbx\n  char *v9; // rax\n\n  v5 = gettext(\"string comparison failed\");\n  error(0, a1, v5);\n  v6 = gettext(\"Set LC_ALL='C' to work around the problem.\");\n  error(0, 0, v6);\n  v7 = sub_40567A(1, 6, a4, a5);\n  v8 = sub_40567A(0, 6, a2, a3);\n  v9 = gettext(\"The strings compared were %s and %s.\");\n  error(status, 0, v9, v8, v7);\n}\n"], [4220304, "sub_406590", "__int64 __fastcall sub_406590(__int64 a1, size_t a2, __int64 a3, size_t a4)\n{\n  unsigned int v7; // [rsp+28h] [rbp-8h]\n  int v8; // [rsp+2Ch] [rbp-4h]\n\n  v7 = sub_407175(a1, a2, a3, a4);\n  v8 = *__errno_location();\n  if ( v8 )\n    sub_4064BD(v8, a1, a2, a3, a4);\n  return v7;\n}\n"], [4220405, "sub_4065F5", "__int64 __fastcall sub_4065F5(__int64 a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  unsigned int v7; // [rsp+28h] [rbp-8h]\n  int v8; // [rsp+2Ch] [rbp-4h]\n\n  v7 = sub_407251(a1, a2, a3, a4);\n  v8 = *__errno_location();\n  if ( v8 )\n    sub_4064BD(v8, a1, a2 - 1, a3, a4 - 1);\n  return v7;\n}\n"], [4220520, "sub_406668", "__int64 __fastcall sub_406668(unsigned __int64 *a1, int a2)\n{\n  __int64 result; // rax\n\n  if ( 0xFFFFFFFFFFFFFFFFLL / a2 >= *a1 )\n  {\n    *a1 *= a2;\n    result = 0LL;\n  }\n  else\n  {\n    *a1 = -1LL;\n    result = 1LL;\n  }\n  return result;\n}\n"], [4220615, "sub_4066C7", "__int64 __fastcall sub_4066C7(unsigned __int64 *a1, int a2, int a3)\n{\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; a3--; i |= sub_406668(a1, a2) )\n    ;\n  return i;\n}\n"], [4220680, "sub_406708", "__int64 __fastcall sub_406708(const char *a1, char **a2, int a3, _QWORD *a4, const char *a5)\n{\n  char **v5; // rax\n  int v7; // eax\n  int v8; // eax\n  unsigned __int8 i; // [rsp+3Fh] [rbp-31h]\n  unsigned int v13; // [rsp+40h] [rbp-30h]\n  int v14; // [rsp+44h] [rbp-2Ch]\n  int v15; // [rsp+48h] [rbp-28h]\n  int v16; // [rsp+4Ch] [rbp-24h]\n  char v17; // [rsp+50h] [rbp-20h] BYREF\n  unsigned __int64 v18; // [rsp+58h] [rbp-18h] BYREF\n  unsigned __int8 *v19; // [rsp+60h] [rbp-10h]\n  char **endptr; // [rsp+68h] [rbp-8h]\n\n  v13 = 0;\n  if ( a3 < 0 || a3 > 36 )\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\", \"../../src/lib/xstrtol.c\", 0x53u, \"xstrtoul\");\n  if ( a2 )\n    v5 = a2;\n  else\n    v5 = (char **)&v17;\n  endptr = v5;\n  v19 = (unsigned __int8 *)a1;\n  for ( i = *a1; ((*__ctype_b_loc())[i] & 0x2000) != 0; i = *v19 )\n    ++v19;\n  if ( i == 45 )\n    return 4LL;\n  *__errno_location() = 0;\n  v18 = strtoul(a1, endptr, a3);\n  if ( *endptr == a1 )\n  {\n    if ( !a5 || !**endptr || !strchr(a5, **endptr) )\n      return 4LL;\n    v18 = 1LL;\n  }\n  else if ( *__errno_location() )\n  {\n    if ( *__errno_location() != 34 )\n      return 4LL;\n    v13 = 1;\n  }\n  if ( !a5 )\n  {\n    *a4 = v18;\n    return v13;\n  }\n  if ( !**endptr )\n    goto LABEL_76;\n  v14 = 1024;\n  v15 = 1;\n  if ( !strchr(a5, **endptr) )\n  {\n    *a4 = v18;\n    return v13 | 2;\n  }\n  if ( strchr(a5, 48) )\n  {\n    v7 = (*endptr)[1];\n    if ( v7 == 68 )\n      goto LABEL_35;\n    if ( v7 != 105 )\n    {\n      if ( v7 != 66 )\n        goto LABEL_36;\nLABEL_35:\n      v14 = 1000;\n      v15 = 2;\n      goto LABEL_36;\n    }\n    if ( (*endptr)[2] == 66 )\n      v15 = 3;\n  }\nLABEL_36:\n  v8 = **endptr;\n  if ( v8 != 89 )\n  {\n    if ( v8 > 89 )\n    {\n      if ( v8 == 103 )\n      {\nLABEL_65:\n        v16 = sub_4066C7(&v18, v14, 3);\n        goto LABEL_74;\n      }\n      if ( v8 <= 103 )\n      {\n        switch ( v8 )\n        {\n          case 'b':\n            v16 = sub_406668(&v18, 512);\n            break;\n          case 'c':\n            v16 = 0;\n            break;\n          case 'Z':\n            v16 = sub_4066C7(&v18, v14, 7);\n            break;\n          default:\n            goto LABEL_73;\n        }\n        goto LABEL_74;\n      }\n      if ( v8 == 109 )\n        goto LABEL_67;\n      if ( v8 > 109 )\n      {\n        if ( v8 != 116 )\n        {\n          if ( v8 != 119 )\n            goto LABEL_73;\n          v16 = sub_406668(&v18, 2);\n          goto LABEL_74;\n        }\nLABEL_69:\n        v16 = sub_4066C7(&v18, v14, 4);\n        goto LABEL_74;\n      }\n      if ( v8 != 107 )\n        goto LABEL_73;\n    }\n    else if ( v8 != 75 )\n    {\n      if ( v8 <= 75 )\n      {\n        if ( v8 == 69 )\n        {\n          v16 = sub_4066C7(&v18, v14, 6);\n          goto LABEL_74;\n        }\n        if ( v8 != 71 )\n        {\n          if ( v8 != 66 )\n          {\nLABEL_73:\n            *a4 = v18;\n            return v13 | 2;\n          }\n          v16 = sub_406668(&v18, 1024);\n          goto LABEL_74;\n        }\n        goto LABEL_65;\n      }\n      if ( v8 == 80 )\n      {\n        v16 = sub_4066C7(&v18, v14, 5);\n        goto LABEL_74;\n      }\n      if ( v8 != 84 )\n      {\n        if ( v8 != 77 )\n          goto LABEL_73;\nLABEL_67:\n        v16 = sub_4066C7(&v18, v14, 2);\n        goto LABEL_74;\n      }\n      goto LABEL_69;\n    }\n    v16 = sub_4066C7(&v18, v14, 1);\n    goto LABEL_74;\n  }\n  v16 = sub_4066C7(&v18, v14, 8);\nLABEL_74:\n  v13 |= v16;\n  *endptr += v15;\n  if ( **endptr )\n    v13 |= 2u;\nLABEL_76:\n  *a4 = v18;\n  return v13;\n}\n"], [4221812, "sub_406B74", "int __fastcall sub_406B74(FILE *a1)\n{\n  int v2; // eax\n  int v3; // [rsp+14h] [rbp-Ch]\n  int v4; // [rsp+18h] [rbp-8h]\n\n  v3 = 0;\n  if ( fileno(a1) < 0 )\n    return fclose(a1);\n  if ( !__freading(a1) || (v2 = fileno(a1), lseek(v2, 0LL, 1) != -1) )\n  {\n    if ( (unsigned int)sub_406F16(a1) )\n      v3 = *__errno_location();\n  }\n  v4 = fclose(a1);\n  if ( v3 )\n  {\n    *__errno_location() = v3;\n    v4 = -1;\n  }\n  return v4;\n}\n"], [4221993, "sub_406C29", "__int64 __fastcall sub_406C29(int a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __m128 a7, __m128 a8, __m128 a9, __m128 a10, __m128 a11, __m128 a12, __m128 a13, __m128 a14)\n{\n  int v14; // ecx\n  int v15; // er8\n  int v16; // er9\n  int v18; // [rsp+10h] [rbp-E0h]\n  int v19; // [rsp+14h] [rbp-DCh]\n  int v20; // [rsp+18h] [rbp-D8h]\n  int v21; // [rsp+1Ch] [rbp-D4h]\n  __int64 v22; // [rsp+50h] [rbp-A0h]\n  __int64 v23; // [rsp+58h] [rbp-98h]\n  __int64 v24; // [rsp+60h] [rbp-90h]\n  __int64 v25; // [rsp+68h] [rbp-88h]\n  __m128 v26; // [rsp+70h] [rbp-80h]\n  __m128 v27; // [rsp+80h] [rbp-70h]\n  __m128 v28; // [rsp+90h] [rbp-60h]\n  __m128 v29; // [rsp+A0h] [rbp-50h]\n  __m128 v30; // [rsp+B0h] [rbp-40h]\n  __m128 v31; // [rsp+C0h] [rbp-30h]\n  __m128 v32; // [rsp+D0h] [rbp-20h]\n  __m128 v33; // [rsp+E0h] [rbp-10h]\n\n  v22 = a3;\n  v23 = a4;\n  v24 = a5;\n  v25 = a6;\n  v26 = a7;\n  v27 = a8;\n  v28 = a9;\n  v29 = a10;\n  v30 = a11;\n  v31 = a12;\n  v32 = a13;\n  v33 = a14;\n  if ( a2 != 1030 )\n    return (unsigned int)fcntl(a1, a2, v22);\n  v19 = v22;\n  if ( dword_60A500 < 0 )\n  {\n    v18 = sub_406C29(a1, 0, v22, a4, a5, a6);\n  }\n  else\n  {\n    v18 = fcntl(a1, 1030, (unsigned int)v22);\n    if ( v18 < 0 && *__errno_location() == 22 )\n    {\n      v18 = sub_406C29(a1, 0, v19, v14, v15, v16);\n      if ( v18 < 0 )\n        return (unsigned int)v18;\n      dword_60A500 = -1;\n    }\n    else\n    {\n      dword_60A500 = 1;\n    }\n  }\n  if ( v18 >= 0 && dword_60A500 == -1 )\n  {\n    v20 = fcntl(v18, 1);\n    if ( v20 < 0 || fcntl(v18, 2, v20 | 1u) == -1 )\n    {\n      v21 = *__errno_location();\n      close(v18);\n      *__errno_location() = v21;\n      v18 = -1;\n    }\n  }\n  return (unsigned int)v18;\n}\n"], [4222691, "sub_406EE3", "__int64 __fastcall sub_406EE3(_DWORD *a1)\n{\n  __int64 result; // rax\n\n  result = *a1 & 0x100;\n  if ( (_DWORD)result )\n    result = sub_406F61(a1, 0LL, 1LL);\n  return result;\n}\n"], [4222742, "sub_406F16", "int __fastcall sub_406F16(FILE *a1)\n{\n  if ( !a1 || !__freading(a1) )\n    return fflush(a1);\n  sub_406EE3(a1);\n  return fflush(a1);\n}\n"], [4222817, "sub_406F61", "int __fastcall sub_406F61(FILE *a1, __off_t a2, int a3)\n{\n  int v3; // eax\n  __off_t v6; // [rsp+28h] [rbp-8h]\n\n  if ( a1->_IO_read_end != a1->_IO_read_ptr || a1->_IO_write_ptr != a1->_IO_write_base || a1->_IO_save_base )\n    return fseeko(a1, a2, a3);\n  v3 = fileno(a1);\n  v6 = lseek(v3, a2, a3);\n  if ( v6 == -1 )\n    return -1;\n  a1->_flags &= 0xFFFFFFEF;\n  a1->_offset = v6;\n  return 0;\n}\n"], [4223001, "sub_407019", "__int64 __fastcall sub_407019(FILE *a1)\n{\n  bool v2; // [rsp+1Dh] [rbp-3h]\n  bool v3; // [rsp+1Eh] [rbp-2h]\n  bool v4; // [rsp+1Fh] [rbp-1h]\n\n  v2 = __fpending(a1) != 0;\n  v3 = ferror_unlocked(a1) != 0;\n  v4 = sub_406B74(a1) != 0;\n  if ( !v3 && (!v4 || !v2 && *__errno_location() == 9) )\n    return 0LL;\n  if ( !v4 )\n    *__errno_location() = 0;\n  return 0xFFFFFFFFLL;\n}\n"], [4223140, "sub_4070A4", "__int64 __fastcall sub_4070A4(const char *a1, __int64 a2, const char *a3, __int64 a4)\n{\n  unsigned int v10; // [rsp+2Ch] [rbp-14h]\n  size_t v11; // [rsp+30h] [rbp-10h]\n  size_t v12; // [rsp+38h] [rbp-8h]\n\n  while ( 1 )\n  {\n    *__errno_location() = 0;\n    v10 = strcoll(a1, a3);\n    if ( v10 || *__errno_location() )\n      break;\n    v11 = strlen(a1) + 1;\n    v12 = strlen(a3) + 1;\n    a1 += v11;\n    a3 += v12;\n    a2 -= v11;\n    a4 -= v12;\n    if ( !a2 )\n      return (unsigned int)-(a4 != 0);\n    if ( !a4 )\n      return 1LL;\n  }\n  return v10;\n}\n"], [4223349, "sub_407175", "__int64 __fastcall sub_407175(const char *a1, size_t a2, const char *a3, __int64 a4)\n{\n  char v7; // [rsp+2Ah] [rbp-6h]\n  char v8; // [rsp+2Bh] [rbp-5h]\n  unsigned int v9; // [rsp+2Ch] [rbp-4h]\n\n  if ( a2 == a4 && !memcmp(a1, a3, a2) )\n  {\n    *__errno_location() = 0;\n    v9 = 0;\n  }\n  else\n  {\n    v7 = a1[a2];\n    v8 = a3[a4];\n    a1[a2] = 0;\n    a3[a4] = 0;\n    v9 = sub_4070A4(a1, a2 + 1, a3, a4 + 1);\n    a1[a2] = v7;\n    a3[a4] = v8;\n  }\n  return v9;\n}\n"], [4223569, "sub_407251", "__int64 __fastcall sub_407251(const char *a1, size_t a2, const char *a3, __int64 a4)\n{\n  if ( a2 != a4 || memcmp(a1, a3, a2) )\n    return sub_4070A4(a1, a2, a3, a4);\n  *__errno_location() = 0;\n  return 0LL;\n}\n"], [4223680, "init", "void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)\n{\n  __int64 v4; // rbx\n  signed __int64 v5; // rbp\n\n  v4 = 0LL;\n  v5 = &off_609E18 - off_609E10;\n  init_proc();\n  if ( v5 )\n  {\n    do\n      ((void (__fastcall *)(_QWORD, __int64, __int64))off_609E10[v4++])(a1, a2, a3);\n    while ( v4 != v5 );\n  }\n}\n"], [4223792, "fini", "void fini(void)\n{\n  ;\n}\n"], [4223808, "sub_407340", "int __fastcall sub_407340(void (__fastcall *a1)(void *))\n{\n  void *v1; // rdx\n\n  if ( &qword_60A1F8 )\n    v1 = (void *)qword_60A1F8;\n  else\n    v1 = 0LL;\n  return __cxa_atexit(a1, 0LL, v1);\n}\n"], [4223836, ".term_proc", "void term_proc()\n{\n  ;\n}\n"]]