[[4203152, ".init_proc", "void *init_proc()\n{\n  void *result; // rax\n\n  result = &_gmon_start__;\n  if ( &_gmon_start__ )\n    result = (void *)__gmon_start__();\n  return result;\n}\n"], [4203184, "sub_4022B0", "__int64 sub_4022B0()\n{\n  return qword_61D010();\n}\n"], [4203200, ".getenv", "// attributes: thunk\nchar *getenv(const char *name)\n{\n  return getenv(name);\n}\n"], [4203216, ".sigprocmask", "// attributes: thunk\nint sigprocmask(int how, const sigset_t *set, sigset_t *oset)\n{\n  return sigprocmask(how, set, oset);\n}\n"], [4203232, ".raise", "// attributes: thunk\nint raise(int sig)\n{\n  return raise(sig);\n}\n"], [4203248, ".free", "// attributes: thunk\nvoid free(void *ptr)\n{\n  free(ptr);\n}\n"], [4203264, ".pthread_create", "// attributes: thunk\nint pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)\n{\n  return pthread_create(newthread, attr, start_routine, arg);\n}\n"], [4203280, ".abort", "// attributes: thunk\nvoid __noreturn abort(void)\n{\n  abort();\n}\n"], [4203296, ".__errno_location", "// attributes: thunk\nint *__errno_location(void)\n{\n  return _errno_location();\n}\n"], [4203312, ".unlink", "// attributes: thunk\nint unlink(const char *name)\n{\n  return unlink(name);\n}\n"], [4203328, ".strncmp", "// attributes: thunk\nint strncmp(const char *s1, const char *s2, size_t n)\n{\n  return strncmp(s1, s2, n);\n}\n"], [4203344, "._exit", "// attributes: thunk\nvoid __noreturn _exit(int status)\n{\n  exit(status);\n}\n"], [4203360, ".strcpy", "// attributes: thunk\nchar *strcpy(char *dest, const char *src)\n{\n  return strcpy(dest, src);\n}\n"], [4203376, ".__fpending", "// attributes: thunk\nsize_t __fpending(FILE *fp)\n{\n  return _fpending(fp);\n}\n"], [4203392, ".toupper", "// attributes: thunk\nint toupper(int c)\n{\n  return toupper(c);\n}\n"], [4203408, ".ferror", "// attributes: thunk\nint ferror(FILE *stream)\n{\n  return ferror(stream);\n}\n"], [4203424, ".qsort", "// attributes: thunk\nvoid qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar)\n{\n  qsort(base, nmemb, size, compar);\n}\n"], [4203440, ".sigaction", "// attributes: thunk\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oact)\n{\n  return sigaction(sig, act, oact);\n}\n"], [4203456, ".iswcntrl", "// attributes: thunk\nint iswcntrl(wint_t wc)\n{\n  return iswcntrl(wc);\n}\n"], [4203472, ".localeconv", "// attributes: thunk\nstruct lconv *localeconv(void)\n{\n  return localeconv();\n}\n"], [4203488, ".fcntl", "// attributes: thunk\nint fcntl(int fd, int cmd, ...)\n{\n  return fcntl(fd, cmd);\n}\n"], [4203504, ".clearerr_unlocked", "// attributes: thunk\nvoid clearerr_unlocked(FILE *stream)\n{\n  clearerr_unlocked(stream);\n}\n"], [4203520, ".getpid", "// attributes: thunk\n__pid_t getpid(void)\n{\n  return getpid();\n}\n"], [4203536, ".fread_unlocked", "// attributes: thunk\nsize_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream)\n{\n  return fread_unlocked(ptr, size, n, stream);\n}\n"], [4203552, ".textdomain", "// attributes: thunk\nchar *textdomain(const char *domainname)\n{\n  return textdomain(domainname);\n}\n"], [4203568, ".pthread_cond_wait", "// attributes: thunk\nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)\n{\n  return pthread_cond_wait(cond, mutex);\n}\n"], [4203584, ".fclose", "// attributes: thunk\nint fclose(FILE *stream)\n{\n  return fclose(stream);\n}\n"], [4203600, ".__sched_cpucount", "// attributes: thunk\nint __sched_cpucount(size_t setsize, const cpu_set_t *setp)\n{\n  return _sched_cpucount(setsize, setp);\n}\n"], [4203616, ".bindtextdomain", "// attributes: thunk\nchar *bindtextdomain(const char *domainname, const char *dirname)\n{\n  return bindtextdomain(domainname, dirname);\n}\n"], [4203632, ".stpcpy", "// attributes: thunk\nchar *stpcpy(char *dest, const char *src)\n{\n  return stpcpy(dest, src);\n}\n"], [4203648, ".__ctype_get_mb_cur_max", "// attributes: thunk\nsize_t __ctype_get_mb_cur_max(void)\n{\n  return _ctype_get_mb_cur_max();\n}\n"], [4203664, ".strlen", "// attributes: thunk\nsize_t strlen(const char *s)\n{\n  return strlen(s);\n}\n"], [4203680, ".__stack_chk_fail", "// attributes: thunk\nvoid __noreturn __stack_chk_fail()\n{\n  _stack_chk_fail();\n}\n"], [4203696, ".getuid", "// attributes: thunk\n__uid_t getuid(void)\n{\n  return getuid();\n}\n"], [4203712, ".getopt_long", "// attributes: thunk\nint getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind)\n{\n  return getopt_long(argc, argv, shortopts, longopts, longind);\n}\n"], [4203728, ".mbrtowc", "// attributes: thunk\nsize_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p)\n{\n  return mbrtowc(pwc, s, n, p);\n}\n"], [4203744, ".gettext", "// attributes: thunk\nchar *gettext(const char *msgid)\n{\n  return gettext(msgid);\n}\n"], [4203760, ".dup2", "// attributes: thunk\nint dup2(int fd, int fd2)\n{\n  return dup2(fd, fd2);\n}\n"], [4203776, ".strchr", "// attributes: thunk\nchar *strchr(const char *s, int c)\n{\n  return strchr(s, c);\n}\n"], [4203792, ".printf", "// attributes: thunk\nint printf(const char *format, ...)\n{\n  return printf(format);\n}\n"], [4203808, "._obstack_begin", "// attributes: thunk\nint _obstack_begin(struct obstack *a1, int a2, int a3, void *(*a4)(__int64), void (*a5)(void *))\n{\n  return obstack_begin(a1, a2, a3, a4, a5);\n}\n"], [4203824, ".pthread_mutex_destroy", "// attributes: thunk\nint pthread_mutex_destroy(pthread_mutex_t *mutex)\n{\n  return pthread_mutex_destroy(mutex);\n}\n"], [4203840, ".nanosleep", "// attributes: thunk\nint nanosleep(const struct timespec *requested_time, struct timespec *remaining)\n{\n  return nanosleep(requested_time, remaining);\n}\n"], [4203856, ".strrchr", "// attributes: thunk\nchar *strrchr(const char *s, int c)\n{\n  return strrchr(s, c);\n}\n"], [4203872, ".lseek", "// attributes: thunk\n__off_t lseek(int fd, __off_t offset, int whence)\n{\n  return lseek(fd, offset, whence);\n}\n"], [4203888, ".gettimeofday", "// attributes: thunk\nint gettimeofday(struct timeval *tv, __timezone_ptr_t tz)\n{\n  return gettimeofday(tv, tz);\n}\n"], [4203904, ".__assert_fail", "// attributes: thunk\nvoid __noreturn __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function)\n{\n  _assert_fail(assertion, file, line, function);\n}\n"], [4203920, ".memset", "// attributes: thunk\nvoid *memset(void *s, int c, size_t n)\n{\n  return memset(s, c, n);\n}\n"], [4203936, ".fgetc", "// attributes: thunk\nint fgetc(FILE *stream)\n{\n  return fgetc(stream);\n}\n"], [4203952, ".close", "// attributes: thunk\nint close(int fd)\n{\n  return close(fd);\n}\n"], [4203968, ".pipe", "// attributes: thunk\nint pipe(int pipedes[2])\n{\n  return pipe(pipedes);\n}\n"], [4203984, ".posix_fadvise", "// attributes: thunk\nint posix_fadvise(int fd, off_t offset, off_t len, int advise)\n{\n  return posix_fadvise(fd, offset, len, advise);\n}\n"], [4204000, ".memchr", "// attributes: thunk\nvoid *memchr(const void *s, int c, size_t n)\n{\n  return memchr(s, c, n);\n}\n"], [4204016, ".read", "// attributes: thunk\nssize_t read(int fd, void *buf, size_t nbytes)\n{\n  return read(fd, buf, nbytes);\n}\n"], [4204032, ".__libc_start_main", "// attributes: thunk\nint __fastcall __libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end)\n{\n  return _libc_start_main(main, argc, ubp_av, init, fini, rtld_fini, stack_end);\n}\n"], [4204048, ".memcmp", "// attributes: thunk\nint memcmp(const void *s1, const void *s2, size_t n)\n{\n  return memcmp(s1, s2, n);\n}\n"], [4204064, ".pthread_cond_signal", "// attributes: thunk\nint pthread_cond_signal(pthread_cond_t *cond)\n{\n  return pthread_cond_signal(cond);\n}\n"], [4204080, ".fputs_unlocked", "// attributes: thunk\nint fputs_unlocked(const char *s, FILE *stream)\n{\n  return fputs_unlocked(s, stream);\n}\n"], [4204096, ".ferror_unlocked", "// attributes: thunk\nint ferror_unlocked(FILE *stream)\n{\n  return ferror_unlocked(stream);\n}\n"], [4204112, ".calloc", "// attributes: thunk\nvoid *calloc(size_t nmemb, size_t size)\n{\n  return calloc(nmemb, size);\n}\n"], [4204128, ".strxfrm", "// attributes: thunk\nsize_t strxfrm(char *dest, const char *src, size_t n)\n{\n  return strxfrm(dest, src, n);\n}\n"], [4204144, ".strcmp", "// attributes: thunk\nint strcmp(const char *s1, const char *s2)\n{\n  return strcmp(s1, s2);\n}\n"], [4204160, ".signal", "// attributes: thunk\n__sighandler_t signal(int sig, __sighandler_t handler)\n{\n  return signal(sig, handler);\n}\n"], [4204176, ".fputc_unlocked", "// attributes: thunk\nint fputc_unlocked(int c, FILE *stream)\n{\n  return fputc_unlocked(c, stream);\n}\n"], [4204192, ".fprintf", "// attributes: thunk\nint fprintf(FILE *stream, const char *format, ...)\n{\n  return fprintf(stream, format);\n}\n"], [4204208, ".sigemptyset", "// attributes: thunk\nint sigemptyset(sigset_t *set)\n{\n  return sigemptyset(set);\n}\n"], [4204224, ".__gmon_start__", "// attributes: thunk\n__int64 __gmon_start__(void)\n{\n  return _gmon_start__();\n}\n"], [4204240, ".obstack_free", "// attributes: thunk\nvoid obstack_free(struct obstack *obstack, void *block)\n{\n  obstack_free(obstack, block);\n}\n"], [4204256, ".strtol", "// attributes: thunk\n__int64 strtol(const char *nptr, char **endptr, int base)\n{\n  return strtol(nptr, endptr, base);\n}\n"], [4204272, ".memcpy", "// attributes: thunk\nvoid *memcpy(void *dest, const void *src, size_t n)\n{\n  return memcpy(dest, src, n);\n}\n"], [4204288, ".putchar_unlocked", "// attributes: thunk\nint putchar_unlocked(int c)\n{\n  return putchar_unlocked(c);\n}\n"], [4204304, ".fileno", "// attributes: thunk\nint fileno(FILE *stream)\n{\n  return fileno(stream);\n}\n"], [4204320, ".getgid", "// attributes: thunk\n__gid_t getgid(void)\n{\n  return getgid();\n}\n"], [4204336, ".__xstat", "// attributes: thunk\nint __xstat(int ver, const char *filename, struct stat *stat_buf)\n{\n  return _xstat(ver, filename, stat_buf);\n}\n"], [4204352, ".pthread_cond_init", "// attributes: thunk\nint pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr)\n{\n  return pthread_cond_init(cond, cond_attr);\n}\n"], [4204368, ".wcwidth", "// attributes: thunk\nint wcwidth(wchar_t c)\n{\n  return wcwidth(c);\n}\n"], [4204384, ".putc_unlocked", "// attributes: thunk\nint putc_unlocked(int c, FILE *stream)\n{\n  return putc_unlocked(c, stream);\n}\n"], [4204400, ".pthread_mutex_unlock", "// attributes: thunk\nint pthread_mutex_unlock(pthread_mutex_t *mutex)\n{\n  return pthread_mutex_unlock(mutex);\n}\n"], [4204416, ".malloc", "// attributes: thunk\nvoid *malloc(size_t size)\n{\n  return malloc(size);\n}\n"], [4204432, ".fflush", "// attributes: thunk\nint fflush(FILE *stream)\n{\n  return fflush(stream);\n}\n"], [4204448, ".nl_langinfo", "// attributes: thunk\nchar *nl_langinfo(nl_item item)\n{\n  return nl_langinfo(item);\n}\n"], [4204464, ".__fxstat", "// attributes: thunk\nint __fxstat(int ver, int fildes, struct stat *stat_buf)\n{\n  return _fxstat(ver, fildes, stat_buf);\n}\n"], [4204480, ".strcoll", "// attributes: thunk\nint strcoll(const char *s1, const char *s2)\n{\n  return strcoll(s1, s2);\n}\n"], [4204496, ".mkstemp", "// attributes: thunk\nint mkstemp(char *a1)\n{\n  return mkstemp(a1);\n}\n"], [4204512, ".__freading", "// attributes: thunk\nint __freading(FILE *fp)\n{\n  return _freading(fp);\n}\n"], [4204528, ".fwrite_unlocked", "// attributes: thunk\nsize_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)\n{\n  return fwrite_unlocked(ptr, size, n, stream);\n}\n"], [4204544, ".realloc", "// attributes: thunk\nvoid *realloc(void *ptr, size_t size)\n{\n  return realloc(ptr, size);\n}\n"], [4204560, ".fdopen", "// attributes: thunk\nFILE *fdopen(int fd, const char *modes)\n{\n  return fdopen(fd, modes);\n}\n"], [4204576, ".setlocale", "// attributes: thunk\nchar *setlocale(int category, const char *locale)\n{\n  return setlocale(category, locale);\n}\n"], [4204592, "._obstack_newchunk", "// attributes: thunk\nvoid _obstack_newchunk(struct obstack *a1, int a2)\n{\n  obstack_newchunk(a1, a2);\n}\n"], [4204608, ".setvbuf", "// attributes: thunk\nint setvbuf(FILE *stream, char *buf, int modes, size_t n)\n{\n  return setvbuf(stream, buf, modes, n);\n}\n"], [4204624, ".memmove", "// attributes: thunk\nvoid *memmove(void *dest, const void *src, size_t n)\n{\n  return memmove(dest, src, n);\n}\n"], [4204640, ".strtold", "// attributes: thunk\nlong double strtold(const char *nptr, char **endptr)\n{\n  return strtold(nptr, endptr);\n}\n"], [4204656, ".error", "// attributes: thunk\nvoid error(int status, int errnum, const char *format, ...)\n{\n  error(status, errnum, format);\n}\n"], [4204672, ".waitpid", "// attributes: thunk\n__pid_t waitpid(__pid_t pid, int *stat_loc, int options)\n{\n  return waitpid(pid, stat_loc, options);\n}\n"], [4204688, ".pthread_cond_destroy", "// attributes: thunk\nint pthread_cond_destroy(pthread_cond_t *cond)\n{\n  return pthread_cond_destroy(cond);\n}\n"], [4204704, ".open", "// attributes: thunk\nint open(const char *file, int oflag, ...)\n{\n  return open(file, oflag);\n}\n"], [4204720, ".fseeko", "// attributes: thunk\nint fseeko(FILE *stream, __off_t off, int whence)\n{\n  return fseeko(stream, off, whence);\n}\n"], [4204736, ".fopen", "// attributes: thunk\nFILE *fopen(const char *filename, const char *modes)\n{\n  return fopen(filename, modes);\n}\n"], [4204752, ".sysconf", "// attributes: thunk\n__int64 sysconf(int name)\n{\n  return sysconf(name);\n}\n"], [4204768, ".pthread_join", "// attributes: thunk\nint pthread_join(pthread_t th, void **thread_return)\n{\n  return pthread_join(th, thread_return);\n}\n"], [4204784, ".strtoumax", "// attributes: thunk\nuintmax_t strtoumax(const char *nptr, char **endptr, int base)\n{\n  return strtoumax(nptr, endptr, base);\n}\n"], [4204800, ".strtoul", "// attributes: thunk\nunsigned __int64 strtoul(const char *nptr, char **endptr, int base)\n{\n  return strtoul(nptr, endptr, base);\n}\n"], [4204816, ".__cxa_atexit", "// attributes: thunk\nint __fastcall __cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle)\n{\n  return _cxa_atexit(lpfunc, obj, lpdso_handle);\n}\n"], [4204832, ".getppid", "// attributes: thunk\n__pid_t getppid(void)\n{\n  return getppid();\n}\n"], [4204848, ".sigismember", "// attributes: thunk\nint sigismember(const sigset_t *set, int signo)\n{\n  return sigismember(set, signo);\n}\n"], [4204864, ".exit", "// attributes: thunk\nvoid __noreturn exit(int status)\n{\n  exit(status);\n}\n"], [4204880, ".fwrite", "// attributes: thunk\nsize_t fwrite(const void *ptr, size_t size, size_t n, FILE *s)\n{\n  return fwrite(ptr, size, n, s);\n}\n"], [4204896, ".getrlimit", "// attributes: thunk\nint getrlimit(__rlimit_resource_t resource, struct rlimit *rlimits)\n{\n  return getrlimit(resource, rlimits);\n}\n"], [4204912, ".ngettext", "// attributes: thunk\nchar *ngettext(const char *msgid1, const char *msgid2, unsigned __int64 n)\n{\n  return ngettext(msgid1, msgid2, n);\n}\n"], [4204928, ".sched_getaffinity", "// attributes: thunk\nint sched_getaffinity(__pid_t pid, size_t cpusetsize, cpu_set_t *cpuset)\n{\n  return sched_getaffinity(pid, cpusetsize, cpuset);\n}\n"], [4204944, ".fflush_unlocked", "// attributes: thunk\nint fflush_unlocked(FILE *stream)\n{\n  return fflush_unlocked(stream);\n}\n"], [4204960, ".mbsinit", "// attributes: thunk\nint mbsinit(const mbstate_t *ps)\n{\n  return mbsinit(ps);\n}\n"], [4204976, ".execlp", "// attributes: thunk\nint execlp(const char *file, const char *arg, ...)\n{\n  return execlp(file, arg);\n}\n"], [4204992, ".iswprint", "// attributes: thunk\nint iswprint(wint_t wc)\n{\n  return iswprint(wc);\n}\n"], [4205008, ".pthread_mutex_init", "// attributes: thunk\nint pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr)\n{\n  return pthread_mutex_init(mutex, mutexattr);\n}\n"], [4205024, ".sigaddset", "// attributes: thunk\nint sigaddset(sigset_t *set, int signo)\n{\n  return sigaddset(set, signo);\n}\n"], [4205040, ".fork", "// attributes: thunk\n__pid_t fork(void)\n{\n  return fork();\n}\n"], [4205056, ".feof_unlocked", "// attributes: thunk\nint feof_unlocked(FILE *stream)\n{\n  return feof_unlocked(stream);\n}\n"], [4205072, ".pthread_mutex_lock", "// attributes: thunk\nint pthread_mutex_lock(pthread_mutex_t *mutex)\n{\n  return pthread_mutex_lock(mutex);\n}\n"], [4205088, ".__ctype_b_loc", "// attributes: thunk\nconst unsigned __int16 **__ctype_b_loc(void)\n{\n  return _ctype_b_loc();\n}\n"], [4205104, "start", "// positive sp value has been detected, the output may be wrong!\nvoid __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))\n{\n  __int64 v3; // rax\n  int v4; // esi\n  __int64 v5; // [rsp-8h] [rbp-8h] BYREF\n  char *retaddr; // [rsp+0h] [rbp+0h] BYREF\n\n  v4 = v5;\n  v5 = v3;\n  __libc_start_main(main, v4, &retaddr, init, fini, a3, &v5);\n  __halt();\n}\n"], [4205152, "sub_402A60", "signed __int64 sub_402A60()\n{\n  signed __int64 result; // rax\n\n  result = &unk_61D55F - &unk_61D558;\n  if ( (unsigned __int64)(&unk_61D55F - &unk_61D558) > 0xE )\n    result = 0LL;\n  return result;\n}\n"], [4205200, "sub_402A90", "__int64 sub_402A90()\n{\n  return 0LL;\n}\n"], [4205264, "sub_402AD0", "signed __int64 sub_402AD0()\n{\n  signed __int64 result; // rax\n\n  if ( !byte_61D5B8 )\n  {\n    result = sub_402A60();\n    byte_61D5B8 = 1;\n  }\n  return result;\n}\n"], [4205296, "sub_402AF0", "__int64 sub_402AF0()\n{\n  return sub_402A90();\n}\n"], [4205341, "sub_402B1D", "__int64 __fastcall sub_402B1D(unsigned int a1)\n{\n  __int64 result; // rax\n\n  if ( a1 != 1 )\n  {\n    result = a1;\n    status = a1;\n  }\n  return result;\n}\n"], [4205365, "sub_402B35", "__int64 __fastcall sub_402B35(unsigned __int8 a1)\n{\n  return a1;\n}\n"], [4205380, "sub_402B44", "__int64 __fastcall sub_402B44(__int64 a1)\n{\n  return a1;\n}\n"], [4205394, "sub_402B52", "int sub_402B52()\n{\n  __int64 v0; // rbx\n  char *v1; // rax\n  char *v2; // rax\n  FILE *v3; // rbx\n  char *v4; // rax\n  __int64 v5; // rbx\n  char *v6; // rax\n  __int64 v7; // rbx\n  char *v8; // rax\n  const char *s1; // [rsp+8h] [rbp-18h]\n\n  v0 = sub_40E690(qword_61DBB0);\n  v1 = gettext(\"\\nReport %s bugs to %s\\n\");\n  printf(v1, v0, \"bug-coreutils@gnu.org\");\n  v2 = gettext(\"%s home page: <%s>\\n\");\n  printf(v2, \"GNU coreutils\", \"http://www.gnu.org/software/coreutils/\");\n  v3 = stdout;\n  v4 = gettext(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\");\n  fputs_unlocked(v4, v3);\n  s1 = setlocale(5, 0LL);\n  if ( s1 && strncmp(s1, \"en_\", 3uLL) )\n  {\n    v5 = sub_40E690(qword_61DBB0);\n    v6 = gettext(\"Report %s translation bugs to <http://translationproject.org/team/>\\n\");\n    printf(v6, v5);\n  }\n  v7 = sub_40E690(qword_61DBB0);\n  v8 = gettext(\"For complete documentation, run: info coreutils '%s invocation'\\n\");\n  return printf(v8, v7);\n}\n"], [4205660, "sub_402C5C", "void __fastcall __noreturn sub_402C5C(const char *a1, char *a2)\n{\n  char *v2; // rbx\n  int *v3; // rax\n\n  if ( a2 )\n    v2 = a2;\n  else\n    v2 = gettext(\"standard output\");\n  v3 = __errno_location();\n  error(0, *v3, \"%s: %s\", a1, v2);\n  exit(2);\n}\n"], [4205752, "sub_402CB8", "void __fastcall __noreturn sub_402CB8(int a1)\n{\n  __int64 v1; // rbx\n  char *v2; // rax\n  __int64 v3; // r12\n  __int64 v4; // rbx\n  char *v5; // rax\n  FILE *v6; // rbx\n  char *v7; // rax\n  FILE *v8; // rbx\n  char *v9; // rax\n  FILE *v10; // rbx\n  char *v11; // rax\n  FILE *v12; // rbx\n  char *v13; // rax\n  FILE *v14; // rbx\n  char *v15; // rax\n  FILE *v16; // rbx\n  char *v17; // rax\n  FILE *v18; // rbx\n  char *v19; // rax\n  FILE *v20; // rbx\n  char *v21; // rax\n  FILE *v22; // rbx\n  char *v23; // rax\n  FILE *v24; // rbx\n  char *v25; // rax\n  FILE *v26; // rbx\n  char *v27; // rax\n  FILE *v28; // rbx\n  char *v29; // rax\n  FILE *v30; // rbx\n  char *v31; // rax\n  FILE *v32; // rbx\n  char *v33; // rax\n  char *v34; // rax\n  FILE *v35; // rbx\n  char *v36; // rax\n  FILE *v37; // rbx\n  char *v38; // rax\n  FILE *v39; // rbx\n  char *v40; // rax\n  FILE *v41; // rbx\n  char *v42; // rax\n  FILE *v43; // rbx\n  char *v44; // rax\n\n  if ( a1 )\n  {\n    v1 = qword_61DBB0;\n    v2 = gettext(\"Try `%s --help' for more information.\\n\");\n    fprintf(stderr, v2, v1);\n  }\n  else\n  {\n    v3 = qword_61DBB0;\n    v4 = qword_61DBB0;\n    v5 = gettext(\"Usage: %s [OPTION]... [FILE]...\\n  or:  %s [OPTION]... --files0-from=F\\n\");\n    printf(v5, v4, v3);\n    v6 = stdout;\n    v7 = gettext(\"Write sorted concatenation of all FILE(s) to standard output.\\n\\n\");\n    fputs_unlocked(v7, v6);\n    v8 = stdout;\n    v9 = gettext(\"Mandatory arguments to long options are mandatory for short options too.\\n\");\n    fputs_unlocked(v9, v8);\n    v10 = stdout;\n    v11 = gettext(\"Ordering options:\\n\\n\");\n    fputs_unlocked(v11, v10);\n    v12 = stdout;\n    v13 = gettext(\n            \"  -b, --ignore-leading-blanks  ignore leading blanks\\n\"\n            \"  -d, --dictionary-order      consider only blanks and alphanumeric characters\\n\"\n            \"  -f, --ignore-case           fold lower case to upper case characters\\n\");\n    fputs_unlocked(v13, v12);\n    v14 = stdout;\n    v15 = gettext(\n            \"  -g, --general-numeric-sort  compare according to general numerical value\\n\"\n            \"  -i, --ignore-nonprinting    consider only printable characters\\n\"\n            \"  -M, --month-sort            compare (unknown) < `JAN' < ... < `DEC'\\n\");\n    fputs_unlocked(v15, v14);\n    v16 = stdout;\n    v17 = gettext(\"  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\\n\");\n    fputs_unlocked(v17, v16);\n    v18 = stdout;\n    v19 = gettext(\n            \"  -n, --numeric-sort          compare according to string numerical value\\n\"\n            \"  -R, --random-sort           sort by random hash of keys\\n\"\n            \"      --random-source=FILE    get random bytes from FILE\\n\"\n            \"  -r, --reverse               reverse the result of comparisons\\n\");\n    fputs_unlocked(v19, v18);\n    v20 = stdout;\n    v21 = gettext(\n            \"      --sort=WORD             sort according to WORD:\\n\"\n            \"                                general-numeric -g, human-numeric -h, month -M,\\n\"\n            \"                                numeric -n, random -R, version -V\\n\"\n            \"  -V, --version-sort          natural sort of (version) numbers within text\\n\"\n            \"\\n\");\n    fputs_unlocked(v21, v20);\n    v22 = stdout;\n    v23 = gettext(\"Other options:\\n\\n\");\n    fputs_unlocked(v23, v22);\n    v24 = stdout;\n    v25 = gettext(\n            \"      --batch-size=NMERGE   merge at most NMERGE inputs at once;\\n\"\n            \"                            for more use temp files\\n\");\n    fputs_unlocked(v25, v24);\n    v26 = stdout;\n    v27 = gettext(\n            \"  -c, --check, --check=diagnose-first  check for sorted input; do not sort\\n\"\n            \"  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\\n\"\n            \"      --compress-program=PROG  compress temporaries with PROG;\\n\"\n            \"                              decompress them with PROG -d\\n\");\n    fputs_unlocked(v27, v26);\n    v28 = stdout;\n    v29 = gettext(\n            \"      --debug               annotate the part of the line used to sort,\\n\"\n            \"                              and warn about questionable usage to stderr\\n\"\n            \"      --files0-from=F       read input from the files specified by\\n\"\n            \"                            NUL-terminated names in file F;\\n\"\n            \"                            If F is - then read names from standard input\\n\");\n    fputs_unlocked(v29, v28);\n    v30 = stdout;\n    v31 = gettext(\n            \"  -k, --key=POS1[,POS2]     start a key at POS1 (origin 1), end it at POS2\\n\"\n            \"                            (default end of line).  See POS syntax below\\n\"\n            \"  -m, --merge               merge already sorted files; do not sort\\n\");\n    fputs_unlocked(v31, v30);\n    v32 = stdout;\n    v33 = gettext(\n            \"  -o, --output=FILE         write result to FILE instead of standard output\\n\"\n            \"  -s, --stable              stabilize sort by disabling last-resort comparison\\n\"\n            \"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\\n\");\n    fputs_unlocked(v33, v32);\n    v34 = gettext(\n            \"  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\\n\"\n            \"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\\n\"\n            \"                              multiple options specify multiple directories\\n\"\n            \"      --parallel=N          change the number of sorts run concurrently to N\\n\"\n            \"  -u, --unique              with -c, check for strict ordering;\\n\"\n            \"                              without -c, output only the first of an equal run\\n\");\n    printf(v34, \"/tmp\");\n    v35 = stdout;\n    v36 = gettext(\"  -z, --zero-terminated     end lines with 0 byte, not newline\\n\");\n    fputs_unlocked(v36, v35);\n    v37 = stdout;\n    v38 = gettext(\"      --help     display this help and exit\\n\");\n    fputs_unlocked(v38, v37);\n    v39 = stdout;\n    v40 = gettext(\"      --version  output version information and exit\\n\");\n    fputs_unlocked(v40, v39);\n    v41 = stdout;\n    v42 = gettext(\n            \"\\n\"\n            \"POS is F[.C][OPTS], where F is the field number and C the character position\\n\"\n            \"in the field; both are origin 1.  If neither -t nor -b is in effect, characters\\n\"\n            \"in a field are counted from the beginning of the preceding whitespace.  OPTS is\\n\"\n            \"one or more single-letter ordering options, which override global ordering\\n\"\n            \"options for that key.  If no key is given, use the entire line as the key.\\n\"\n            \"\\n\"\n            \"SIZE may be followed by the following multiplicative suffixes:\\n\");\n    fputs_unlocked(v42, v41);\n    v43 = stdout;\n    v44 = gettext(\n            \"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\\n\"\n            \"\\n\"\n            \"With no FILE, or when FILE is -, read standard input.\\n\"\n            \"\\n\"\n            \"*** WARNING ***\\n\"\n            \"The locale specified by the environment affects sort order.\\n\"\n            \"Set LC_ALL=C to get the traditional sort order that uses\\n\"\n            \"native byte values.\\n\");\n    fputs_unlocked(v44, v43);\n    sub_402B52();\n  }\n  exit(a1);\n}\n"], [4206441, "sub_402F69", "void *__fastcall sub_402F69(void *a1)\n{\n  _QWORD v2[18]; // [rsp+10h] [rbp-90h] BYREF\n\n  LOBYTE(v2[0]) = sigprocmask(0, &set, (sigset_t *)&v2[1]) == 0;\n  qmemcpy(a1, v2, 0x88uLL);\n  return a1;\n}\n"], [4206539, "sub_402FCB", "int __fastcall sub_402FCB(int a1, int a2, int a3, int a4, int a5, int a6, char a7, sigset_t set)\n{\n  int result; // eax\n\n  result = (unsigned __int8)a7;\n  if ( a7 )\n    result = sigprocmask(2, &set, 0LL);\n  return result;\n}\n"], [4206575, "sub_402FEF", "unsigned __int64 __fastcall sub_402FEF(__int64 a1, unsigned __int64 a2)\n{\n  return *(int *)(a1 + 8) % a2;\n}\n"], [4206618, "sub_40301A", "bool __fastcall sub_40301A(__int64 a1, __int64 a2)\n{\n  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);\n}\n"], [4206667, "sub_40304B", "__int64 __fastcall sub_40304B(int a1)\n{\n  __pid_t v1; // eax\n  char *v2; // r12\n  char *v3; // rbx\n  int *v4; // rax\n  char *v5; // rbx\n  char *v6; // rax\n  int stat_loc; // [rsp+28h] [rbp-18h] BYREF\n  __pid_t v9; // [rsp+2Ch] [rbp-14h]\n\n  if ( a1 )\n    v1 = a1;\n  else\n    v1 = -1;\n  v9 = waitpid(v1, &stat_loc, a1 == 0);\n  if ( v9 >= 0 )\n  {\n    if ( v9 > 0 && (a1 > 0 || (unsigned __int8)sub_4031BC((unsigned int)v9)) )\n    {\n      if ( (stat_loc & 0x7F) != 0 || (stat_loc & 0xFF00) >> 8 )\n      {\n        v5 = s1;\n        v6 = gettext(\"%s [-d] terminated abnormally\");\n        error(2, 0, v6, v5);\n      }\n      --dword_61DAB0;\n    }\n  }\n  else\n  {\n    v2 = s1;\n    v3 = gettext(\"waiting for %s [-d]\");\n    v4 = __errno_location();\n    error(2, *v4, v3, v2);\n  }\n  return (unsigned int)v9;\n}\n"], [4206915, "sub_403143", "__int64 __fastcall sub_403143(__int64 a1)\n{\n  __int64 result; // rax\n\n  if ( !qword_61DAA8 )\n  {\n    qword_61DAA8 = sub_40F78B(47LL, 0LL, sub_402FEF, sub_40301A, 0LL);\n    if ( !qword_61DAA8 )\n      sub_415114();\n  }\n  *(_BYTE *)(a1 + 12) = 1;\n  result = sub_410421(qword_61DAA8, a1);\n  if ( !result )\n    sub_415114();\n  return result;\n}\n"], [4207036, "sub_4031BC", "__int64 __fastcall sub_4031BC(int a1)\n{\n  __int64 v2; // [rsp+18h] [rbp-18h]\n  char v3[8]; // [rsp+20h] [rbp-10h] BYREF\n  int v4; // [rsp+28h] [rbp-8h]\n\n  v4 = a1;\n  v2 = sub_41046A(qword_61DAA8, v3);\n  if ( !v2 )\n    return 0LL;\n  *(_BYTE *)(v2 + 12) = 2;\n  return 1LL;\n}\n"], [4207108, "sub_403204", "__int64 __fastcall sub_403204(int a1)\n{\n  __int64 result; // rax\n\n  result = sub_4031BC(a1);\n  if ( (_BYTE)result )\n    result = sub_40304B(a1);\n  return result;\n}\n"], [4207145, "sub_403229", "__int64 sub_403229()\n{\n  __int64 result; // rax\n\n  do\n  {\n    result = (unsigned int)dword_61DAB0;\n    if ( dword_61DAB0 <= 0 )\n      break;\n    result = sub_40304B(0);\n  }\n  while ( (_DWORD)result );\n  return result;\n}\n"], [4207178, "sub_40324A", "__int64 sub_40324A()\n{\n  sub_40304B(-1);\n  return sub_403229();\n}\n"], [4207199, "sub_40325F", "__int64 sub_40325F()\n{\n  __int64 result; // rax\n\n  while ( 1 )\n  {\n    result = (unsigned int)dword_61DAB0;\n    if ( dword_61DAB0 <= 0 )\n      break;\n    sub_40304B(-1);\n  }\n  return result;\n}\n"], [4207227, "sub_40327B", "__int64 sub_40327B()\n{\n  __int64 result; // rax\n  __int64 i; // [rsp+8h] [rbp-8h]\n\n  result = qword_61DAA0;\n  for ( i = qword_61DAA0; i; i = *(_QWORD *)i )\n  {\n    unlink((const char *)(i + 13));\n    result = *(_QWORD *)i;\n  }\n  qword_61DAA0 = 0LL;\n  return result;\n}\n"], [4207295, "sub_4032BF", "__int64 sub_4032BF()\n{\n  int v0; // er8\n  int v1; // er9\n  _QWORD v3[17]; // [rsp+0h] [rbp-120h] BYREF\n  __int64 v4; // [rsp+88h] [rbp-98h] BYREF\n  int v5[34]; // [rsp+90h] [rbp-90h] BYREF\n  __int64 v6; // [rsp+118h] [rbp-8h] BYREF\n\n  if ( qword_61DAA0 )\n  {\n    sub_402F69(v5);\n    sub_40327B();\n    qmemcpy(v3, v5, sizeof(v3));\n    sub_402FCB((int)&v4, (int)&v6, (int)v3, 0, v0, v1, v3[0], *(sigset_t *)&v3[1]);\n  }\n  return sub_40D218();\n}\n"], [4207374, "sub_40330E", "void *__fastcall sub_40330E(_DWORD *a1, char a2)\n{\n  int v2; // er8\n  int v3; // er9\n  __int64 v4; // r12\n  char *v5; // rbx\n  int *v6; // rax\n  _QWORD v8[17]; // [rsp+0h] [rbp-170h] BYREF\n  __int64 v9; // [rsp+88h] [rbp-E8h] BYREF\n  char v10; // [rsp+94h] [rbp-DCh]\n  _DWORD *v11; // [rsp+98h] [rbp-D8h]\n  int v12; // [rsp+A8h] [rbp-C8h]\n  int v13; // [rsp+ACh] [rbp-C4h]\n  void *ptr; // [rsp+B0h] [rbp-C0h]\n  char *s; // [rsp+B8h] [rbp-B8h]\n  size_t n; // [rsp+C0h] [rbp-B0h]\n  void *dest; // [rsp+C8h] [rbp-A8h]\n  int v18[34]; // [rsp+D0h] [rbp-A0h] BYREF\n  __int64 v19; // [rsp+158h] [rbp-18h] BYREF\n\n  v11 = a1;\n  v10 = a2;\n  s = *(char **)(8 * qword_61DB60 + qword_61D9E8);\n  n = strlen(s);\n  ptr = (void *)sub_414F92(n + 25);\n  dest = (char *)ptr + 13;\n  memcpy((char *)ptr + 13, s, n);\n  strcpy((char *)ptr + n + 13, \"/sortXXXXXX\");\n  *(_QWORD *)ptr = 0LL;\n  if ( ++qword_61DB60 == qword_61D9F0 )\n    qword_61DB60 = 0LL;\n  sub_402F69(v18);\n  v12 = sub_414564(dest);\n  if ( v12 >= 0 )\n  {\n    *off_61D4F0 = (__int64)ptr;\n    off_61D4F0 = (__int64 *)ptr;\n  }\n  v13 = *__errno_location();\n  qmemcpy(v8, v18, sizeof(v8));\n  sub_402FCB((int)&v9, (int)&v19, (int)v8, 0, v2, v3, v8[0], *(sigset_t *)&v8[1]);\n  *__errno_location() = v13;\n  if ( v12 < 0 )\n  {\n    if ( v10 != 1 || *__errno_location() != 24 )\n    {\n      v4 = sub_4112FB(s);\n      v5 = gettext(\"cannot create temporary file in %s\");\n      v6 = __errno_location();\n      error(2, *v6, v5, v4);\n    }\n    free(ptr);\n    ptr = 0LL;\n  }\n  *v11 = v12;\n  return ptr;\n}\n"], [4207918, "sub_40352E", "FILE *__fastcall sub_40352E(const char *a1, _BYTE *a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  if ( !a1 )\n    return stdout;\n  if ( *a2 != 114 )\n    return (FILE *)sub_40ED36(a1, a2);\n  if ( !strcmp(a1, \"-\") )\n  {\n    byte_61DA03 = 1;\n    v3 = stdin;\n    sub_40E777(stdin, 2LL);\n  }\n  else\n  {\n    v3 = sub_40ED36(a1, a2);\n    sub_40E777(v3, 2LL);\n  }\n  return (FILE *)v3;\n}\n"], [4208069, "sub_4035C5", "FILE *__fastcall sub_4035C5(char *a1, _BYTE *a2)\n{\n  char *v2; // rax\n  FILE *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = sub_40352E(a1, a2);\n  if ( !v4 )\n  {\n    v2 = gettext(\"open failed\");\n    sub_402C5C(v2, a1);\n  }\n  return v4;\n}\n"], [4208146, "sub_403612", "void __fastcall sub_403612(FILE *a1, char *a2)\n{\n  int v2; // eax\n  char *v3; // rax\n  char *v5; // rax\n\n  v2 = fileno(a1);\n  if ( v2 )\n  {\n    if ( v2 == 1 )\n    {\n      if ( fflush_unlocked(a1) )\n      {\n        v3 = gettext(\"fflush failed\");\n        sub_402C5C(v3, a2);\n      }\n    }\n    else if ( (unsigned int)sub_415E9D(a1) )\n    {\n      v5 = gettext(\"close failed\");\n      sub_402C5C(v5, a2);\n    }\n  }\n  else if ( feof_unlocked(a1) )\n  {\n    clearerr_unlocked(a1);\n  }\n}\n"], [4208304, "sub_4036B0", "void __fastcall sub_4036B0(int a1, int a2)\n{\n  char *v2; // rbx\n  int *v3; // rax\n\n  if ( dup2(a1, a2) < 0 )\n  {\n    v2 = gettext(\"dup2 failed\");\n    v3 = __errno_location();\n    error(2, *v3, v2);\n  }\n}\n"], [4208385, "sub_403701", "__int64 __fastcall sub_403701(int *a1, __int64 a2)\n{\n  int v3; // er8\n  int v4; // er9\n  _QWORD v6[17]; // [rsp+0h] [rbp-150h] BYREF\n  double v7; // [rsp+88h] [rbp-C8h] BYREF\n  __int64 v8; // [rsp+90h] [rbp-C0h]\n  int *__attribute__((__org_arrdim(0,2))) pipedes; // [rsp+98h] [rbp-B8h]\n  __pid_t v10; // [rsp+A8h] [rbp-A8h]\n  int v11; // [rsp+ACh] [rbp-A4h]\n  double v12; // [rsp+B0h] [rbp-A0h]\n  __int64 v13; // [rsp+B8h] [rbp-98h]\n  int v14[34]; // [rsp+C0h] [rbp-90h] BYREF\n  __int64 v15; // [rsp+148h] [rbp-8h] BYREF\n\n  pipedes = a1;\n  v8 = a2;\n  v12 = 0.25;\n  if ( pipe(a1) < 0 )\n    return 0xFFFFFFFFLL;\n  if ( dword_61D4EC + 1 < (unsigned int)dword_61DAB0 )\n    sub_40324A();\n  while ( v8-- )\n  {\n    sub_402F69(v14);\n    v13 = qword_61DAA0;\n    qword_61DAA0 = 0LL;\n    v10 = fork();\n    v11 = *__errno_location();\n    if ( v10 )\n      qword_61DAA0 = v13;\n    qmemcpy(v6, v14, sizeof(v6));\n    sub_402FCB((int)&v7, (int)&v15, (int)v6, 0, v3, v4, v6[0], *(sigset_t *)&v6[1]);\n    *__errno_location() = v11;\n    if ( v10 >= 0 || *__errno_location() != 11 )\n      break;\n    v7 = v12;\n    sub_4152F4(v12);\n    v12 = v12 + v12;\n    sub_403229();\n  }\n  if ( v10 >= 0 )\n  {\n    if ( v10 )\n    {\n      ++dword_61DAB0;\n    }\n    else\n    {\n      close(0);\n      close(1);\n    }\n  }\n  else\n  {\n    v11 = *__errno_location();\n    close(*pipedes);\n    close(pipedes[1]);\n    *__errno_location() = v11;\n  }\n  return (unsigned int)v10;\n}\n"], [4208846, "sub_4038CE", "char *__fastcall sub_4038CE(FILE **a1, char a2)\n{\n  int v3; // eax\n  char *v4; // r12\n  char *v5; // rbx\n  int *v6; // rax\n  char *v7; // rbx\n  char *v8; // rax\n  int fd; // [rsp+1Ch] [rbp-24h] BYREF\n  int v10; // [rsp+20h] [rbp-20h] BYREF\n  int v11; // [rsp+24h] [rbp-1Ch]\n  char *v12; // [rsp+28h] [rbp-18h]\n\n  v12 = (char *)sub_40330E(&fd, a2);\n  if ( !v12 )\n    return 0LL;\n  v12[12] = 0;\n  if ( s1 )\n  {\n    v3 = sub_403701(&v10, 4LL);\n    *((_DWORD *)v12 + 2) = v3;\n    if ( *((int *)v12 + 2) <= 0 )\n    {\n      if ( !*((_DWORD *)v12 + 2) )\n      {\n        close(v11);\n        sub_4036B0(fd, 1);\n        close(fd);\n        sub_4036B0(v10, 0);\n        close(v10);\n        if ( execlp(s1, s1, 0LL) < 0 )\n        {\n          v4 = s1;\n          v5 = gettext(\"couldn't execute %s\");\n          v6 = __errno_location();\n          error(2, *v6, v5, v4);\n        }\n      }\n    }\n    else\n    {\n      close(fd);\n      close(v10);\n      fd = v11;\n      sub_403143((__int64)v12);\n    }\n  }\n  *a1 = fdopen(fd, \"w\");\n  if ( !*a1 )\n  {\n    v7 = v12 + 13;\n    v8 = gettext(\"couldn't create temporary file\");\n    sub_402C5C(v8, v7);\n  }\n  return v12;\n}\n"], [4209247, "sub_403A5F", "char *__fastcall sub_403A5F(FILE **a1)\n{\n  return sub_4038CE(a1, 0);\n}\n"], [4209278, "sub_403A7E", "FILE *__fastcall sub_403A7E(__int64 a1)\n{\n  int v2; // eax\n  char *v3; // r12\n  char *v4; // rbx\n  int *v5; // rax\n  char *v6; // r12\n  char *v7; // rbx\n  int *v8; // rax\n  int fd; // [rsp+14h] [rbp-2Ch]\n  int v10; // [rsp+18h] [rbp-28h]\n  int v11; // [rsp+1Ch] [rbp-24h]\n  int v12; // [rsp+20h] [rbp-20h] BYREF\n  int v13; // [rsp+24h] [rbp-1Ch]\n  FILE *v14; // [rsp+28h] [rbp-18h]\n\n  v14 = 0LL;\n  if ( *(_BYTE *)(a1 + 12) == 1 )\n    sub_403204(*(_DWORD *)(a1 + 8));\n  fd = open((const char *)(a1 + 13), 0);\n  if ( fd < 0 )\n    return 0LL;\n  v2 = sub_403701(&v12, 9LL);\n  v10 = v2;\n  if ( v2 == -1 )\n  {\n    if ( *__errno_location() != 24 )\n    {\n      v3 = s1;\n      v4 = gettext(\"couldn't create process for %s -d\");\n      v5 = __errno_location();\n      error(2, *v5, v4, v3);\n    }\n    close(fd);\n    *__errno_location() = 24;\n  }\n  else\n  {\n    if ( !v2 )\n    {\n      close(v12);\n      sub_4036B0(fd, 0);\n      close(fd);\n      sub_4036B0(v13, 1);\n      close(v13);\n      execlp(s1, s1, \"-d\", 0LL);\n      v6 = s1;\n      v7 = gettext(\"couldn't execute %s -d\");\n      v8 = __errno_location();\n      error(2, *v8, v7, v6);\n    }\n    *(_DWORD *)(a1 + 8) = v10;\n    sub_403143(a1);\n    close(fd);\n    close(v13);\n    v14 = fdopen(v12, \"r\");\n    if ( !v14 )\n    {\n      v11 = *__errno_location();\n      close(v12);\n      *__errno_location() = v11;\n    }\n  }\n  return v14;\n}\n"], [4209758, "sub_403C5E", "__int64 __fastcall sub_403C5E(__int64 a1)\n{\n  __int64 v1; // rax\n  _QWORD *v2; // rdx\n  __int64 result; // rax\n\n  if ( qword_61D9F0 == qword_61D9F8 )\n    qword_61D9E8 = sub_414ED3(qword_61D9E8, &qword_61D9F8, 8LL);\n  v1 = qword_61D9F0++;\n  v2 = (_QWORD *)(qword_61D9E8 + 8 * v1);\n  result = a1;\n  *v2 = a1;\n  return result;\n}\n"], [4209863, "sub_403CC7", "void __fastcall sub_403CC7(char *a1)\n{\n  int v1; // er8\n  int v2; // er9\n  char *v3; // rax\n  _QWORD v4[17]; // [rsp+0h] [rbp-140h] BYREF\n  char *name; // [rsp+88h] [rbp-B8h] BYREF\n  int errnum; // [rsp+90h] [rbp-B0h]\n  int v7; // [rsp+94h] [rbp-ACh]\n  void **i; // [rsp+98h] [rbp-A8h]\n  void *ptr; // [rsp+A0h] [rbp-A0h]\n  void *v10; // [rsp+A8h] [rbp-98h]\n  int v11[34]; // [rsp+B0h] [rbp-90h] BYREF\n  __int64 v12; // [rsp+138h] [rbp-8h] BYREF\n\n  name = a1;\n  errnum = 0;\n  for ( i = (void **)&qword_61DAA0; ; i = (void **)ptr )\n  {\n    ptr = *i;\n    if ( (char *)ptr + 13 == name )\n      break;\n  }\n  if ( *((_BYTE *)ptr + 12) == 1 )\n    sub_403204(*((_DWORD *)ptr + 2));\n  v10 = *(void **)ptr;\n  sub_402F69(v11);\n  v7 = unlink(name);\n  errnum = *__errno_location();\n  *i = v10;\n  qmemcpy(v4, v11, sizeof(v4));\n  sub_402FCB((int)&name, (int)&v12, (int)v4, 0, v1, v2, v4[0], *(sigset_t *)&v4[1]);\n  if ( v7 )\n  {\n    v3 = gettext(\"warning: cannot remove: %s\");\n    error(0, errnum, v3, name);\n  }\n  if ( !v10 )\n    off_61D4F0 = (__int64 *)i;\n  free(ptr);\n}\n"], [4210192, "compar", "int __fastcall compar(const void *a1, const void *a2)\n{\n  return strcmp(*(const char **)a1, *(const char **)a2);\n}\n"], [4210251, "sub_403E4B", "void sub_403E4B()\n{\n  bool v0; // al\n  const unsigned __int16 *v1; // rbx\n  __int64 v2; // rax\n  unsigned __int64 c; // [rsp+0h] [rbp-40h]\n  unsigned __int64 ca; // [rsp+0h] [rbp-40h]\n  size_t i; // [rsp+8h] [rbp-38h]\n  __int64 v6; // [rsp+10h] [rbp-30h]\n  const char *s; // [rsp+18h] [rbp-28h]\n  size_t v8; // [rsp+20h] [rbp-20h]\n  char *v9; // [rsp+28h] [rbp-18h]\n\n  for ( c = 0LL; c <= 0xFF; ++c )\n  {\n    *(_BYTE *)(c + 6411744) = ((*__ctype_b_loc())[(int)c] & 1) != 0;\n    *(_BYTE *)(c + 6412000) = ((*__ctype_b_loc())[(int)c] & 0x4000) == 0;\n    v0 = ((*__ctype_b_loc())[(int)c] & 8) == 0 && ((*__ctype_b_loc())[(int)c] & 1) == 0;\n    *(_BYTE *)(c + 6412256) = v0;\n    *(_BYTE *)(c + 6412512) = toupper(c);\n  }\n  if ( byte_61D5C9 )\n  {\n    for ( ca = 0LL; ca <= 0xB; ++ca )\n    {\n      s = nl_langinfo((int)ca + 131086);\n      v8 = strlen(s);\n      v9 = (char *)sub_414F92(v8 + 1);\n      (&off_61D420)[2 * ca] = v9;\n      dword_61D428[4 * ca] = ca + 1;\n      v6 = 0LL;\n      for ( i = 0LL; i < v8; ++i )\n      {\n        v1 = *__ctype_b_loc();\n        if ( (v1[(unsigned __int8)sub_402B35(s[i])] & 1) == 0 )\n        {\n          v2 = v6++;\n          v9[v2] = byte_61D8E0[(unsigned __int8)sub_402B35(s[i])];\n        }\n      }\n      v9[v6] = 0;\n    }\n    qsort(&off_61D420, 0xCuLL, 0x10uLL, compar);\n  }\n}\n"], [4210846, "sub_40409E", "unsigned __int64 __fastcall sub_40409E(unsigned int a1, char a2, __int64 a3)\n{\n  unsigned int v3; // eax\n  __int64 v4; // r12\n  __int64 v5; // rbx\n  char *v6; // rax\n  __int64 v7; // r12\n  __int64 v8; // rbx\n  char *v9; // rax\n  __int64 v10; // r12\n  __int64 v11; // rbx\n  char *v12; // rax\n  __int64 v13; // r12\n  __int64 v14; // rbx\n  char *v15; // rax\n  unsigned int v18; // [rsp+10h] [rbp-50h]\n  unsigned int v19; // [rsp+14h] [rbp-4Ch]\n  __int64 v20; // [rsp+18h] [rbp-48h] BYREF\n  struct rlimit rlimits; // [rsp+20h] [rbp-40h] BYREF\n  char v22[24]; // [rsp+30h] [rbp-30h] BYREF\n  unsigned __int64 v23; // [rsp+48h] [rbp-18h]\n\n  v23 = __readfsqword(0x28u);\n  v18 = sub_415A31(a3, 0LL, 10LL, &v20, 0LL);\n  if ( getrlimit(RLIMIT_NOFILE, &rlimits) )\n    v3 = 17;\n  else\n    v3 = LODWORD(rlimits.rlim_cur) - 3;\n  v19 = v3;\n  if ( !v18 )\n  {\n    dword_61D4EC = v20;\n    if ( (unsigned int)v20 == v20 )\n    {\n      if ( (unsigned int)dword_61D4EC > 1 )\n      {\n        if ( v3 >= dword_61D4EC )\n          return __readfsqword(0x28u) ^ v23;\n        v18 = 1;\n      }\n      else\n      {\n        v4 = sub_4112FB(a3);\n        v5 = *((_QWORD *)&longopts.name + 4 * (int)a1);\n        v6 = gettext(\"invalid --%s argument %s\");\n        error(0, 0, v6, v5, v4);\n        v7 = sub_4112FB(\"2\");\n        v8 = *((_QWORD *)&longopts.name + 4 * (int)a1);\n        v9 = gettext(\"minimum --%s argument is %s\");\n        error(2, 0, v9, v8, v7);\n      }\n    }\n    else\n    {\n      v18 = 1;\n    }\n  }\n  if ( v18 != 1 )\n    sub_41594B(v18, a1, (unsigned int)a2, &longopts, a3);\n  v10 = sub_4112FB(a3);\n  v11 = *((_QWORD *)&longopts.name + 4 * (int)a1);\n  v12 = gettext(\"--%s argument %s too large\");\n  error(0, 0, v12, v11, v10);\n  v13 = sub_410B07(v19, v22);\n  v14 = *((_QWORD *)&longopts.name + 4 * (int)a1);\n  v15 = gettext(\"maximum --%s argument with current rlimit is %s\");\n  error(2, 0, v15, v14, v13);\n  return __readfsqword(0x28u) ^ v23;\n}\n"], [4211409, "sub_4042D1", "__int64 __fastcall sub_4042D1(unsigned int a1, char a2, __int64 a3)\n{\n  int v4; // eax\n  double v5; // xmm1_8\n  double v6; // xmm0_8\n  unsigned __int64 v7; // rax\n  __int64 result; // rax\n  __int64 v9; // [rsp+0h] [rbp-30h]\n  unsigned int v11; // [rsp+14h] [rbp-1Ch]\n  unsigned __int64 v12; // [rsp+18h] [rbp-18h] BYREF\n  char *v13; // [rsp+20h] [rbp-10h] BYREF\n  double v14; // [rsp+28h] [rbp-8h]\n\n  v9 = a3;\n  v11 = sub_415A31(a3, &v13, 10LL, &v12, \"EgGkKmMPtTYZ\");\n  if ( !v11 && (unsigned int)(*(v13 - 1) - 48) <= 9 )\n  {\n    if ( v12 > 0x3FFFFFFFFFFFFFLL )\n      v11 = 1;\n    else\n      v12 <<= 10;\n  }\n  if ( v11 == 2 && (unsigned int)(*(v13 - 1) - 48) <= 9 && !v13[1] )\n  {\n    v4 = *v13;\n    if ( v4 == 37 )\n    {\n      v5 = sub_411075(a3, &v13);\n      if ( (v12 & 0x8000000000000000LL) != 0LL )\n        v6 = (double)(int)(v12 & 1 | (v12 >> 1)) + (double)(int)(v12 & 1 | (v12 >> 1));\n      else\n        v6 = (double)(int)v12;\n      v14 = v6 * v5 / 100.0;\n      if ( v14 >= 1.844674407370955e19 )\n      {\n        v11 = 1;\n      }\n      else\n      {\n        if ( v14 >= 9.223372036854776e18 )\n          v7 = (unsigned int)(int)(v14 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n        else\n          v7 = (unsigned int)(int)v14;\n        v12 = v7;\n        v11 = 0;\n      }\n    }\n    else if ( v4 == 98 )\n    {\n      v11 = 0;\n    }\n  }\n  if ( v11 )\n    sub_41594B(v11, a1, (unsigned int)a2, &longopts, v9);\n  result = qword_61D9E0;\n  if ( v12 >= qword_61D9E0 )\n  {\n    qword_61D9E0 = v12;\n    result = v12;\n    if ( 34 * (unsigned __int64)(unsigned int)dword_61D4EC >= v12 )\n      result = 34LL * (unsigned int)dword_61D4EC;\n    qword_61D9E0 = result;\n  }\n  return result;\n}\n"], [4211923, "sub_4044D3", "__int64 __fastcall sub_4044D3(unsigned int a1, char a2, __int64 a3)\n{\n  char *v4; // rax\n  unsigned int v6; // [rsp+14h] [rbp-Ch]\n  __int64 v7; // [rsp+18h] [rbp-8h] BYREF\n\n  v6 = sub_415405(a3, 0LL, 10LL, &v7, locale);\n  if ( v6 == 1 )\n    return -1LL;\n  if ( v6 )\n    sub_41594B(v6, a1, (unsigned int)a2, &longopts, a3);\n  if ( !v7 )\n  {\n    v4 = gettext(\"number in parallel must be nonzero\");\n    error(2, 0, v4);\n  }\n  return v7;\n}\n"], [4212079, "sub_40456F", "__int64 __fastcall sub_40456F(__int64 a1, __int64 a2)\n{\n  double v2; // rax\n  __int64 result; // rax\n  unsigned __int64 v4; // [rsp+10h] [rbp-30h]\n  unsigned __int64 v5; // [rsp+10h] [rbp-30h]\n  double v6; // [rsp+18h] [rbp-28h]\n  double v7; // [rsp+20h] [rbp-20h]\n  struct rlimit rlimits; // [rsp+30h] [rbp-10h] BYREF\n\n  v6 = sub_4110ED();\n  v7 = sub_411075(a1, a2);\n  if ( v6 <= v7 / 8.0 )\n    v2 = v7 / 8.0;\n  else\n    v2 = v6;\n  v4 = -1LL;\n  if ( (double)-1 + (double)-1 > v2 )\n  {\n    if ( v2 >= 9.223372036854776e18 )\n      v4 = (unsigned int)(int)(v2 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n    else\n      v4 = (unsigned int)(int)v2;\n  }\n  if ( !getrlimit(RLIMIT_DATA, &rlimits) && rlimits.rlim_cur < v4 )\n    v4 = rlimits.rlim_cur;\n  if ( !getrlimit(RLIMIT_AS, &rlimits) && rlimits.rlim_cur < v4 )\n    v4 = rlimits.rlim_cur;\n  v5 = v4 >> 1;\n  if ( !getrlimit(__RLIMIT_RSS, &rlimits) && 15 * (rlimits.rlim_cur >> 4) < v5 )\n    v5 = 15 * (rlimits.rlim_cur >> 4);\n  result = v5;\n  if ( 34 * (unsigned __int64)(unsigned int)dword_61D4EC >= v5 )\n    result = 34LL * (unsigned int)dword_61D4EC;\n  return result;\n}\n"], [4212514, "sub_404722", "__int64 __fastcall sub_404722(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5)\n{\n  unsigned int v5; // eax\n  __int64 v6; // rdi\n  bool v7; // al\n  char *v8; // rbx\n  char *v9; // rax\n  __int64 v14; // [rsp+38h] [rbp-C8h]\n  unsigned __int64 i; // [rsp+40h] [rbp-C0h]\n  __off_t v16; // [rsp+48h] [rbp-B8h]\n  unsigned __int64 v17; // [rsp+50h] [rbp-B0h]\n  unsigned __int64 v18; // [rsp+58h] [rbp-A8h]\n  struct stat stat_buf; // [rsp+60h] [rbp-A0h] BYREF\n\n  v17 = a5 + 1;\n  v14 = a5 + 2;\n  for ( i = 0LL; i < a4; ++i )\n  {\n    if ( i >= a2 )\n    {\n      if ( !strcmp(*(const char **)(8 * i + a3), \"-\") )\n      {\n        v6 = 0LL;\n        v7 = (unsigned int)sub_417170(0, &stat_buf) != 0;\n      }\n      else\n      {\n        v6 = *(_QWORD *)(8 * i + a3);\n        v7 = (unsigned int)sub_417160((char *)v6, &stat_buf) != 0;\n      }\n    }\n    else\n    {\n      v5 = fileno(*(FILE **)(8 * i + a1));\n      v6 = v5;\n      v7 = (unsigned int)sub_417170(v5, &stat_buf) != 0;\n    }\n    if ( v7 )\n    {\n      v8 = *(char **)(8 * i + a3);\n      v9 = gettext(\"stat failed\");\n      sub_402C5C(v9, v8);\n    }\n    if ( (stat_buf.st_mode & 0xF000) == 0x8000 )\n    {\n      v16 = stat_buf.st_size;\n    }\n    else\n    {\n      if ( qword_61D9E0 )\n        return qword_61D9E0;\n      v16 = 0x20000LL;\n    }\n    if ( !qword_61DB68 )\n    {\n      qword_61DB68 = qword_61D9E0;\n      if ( !qword_61D9E0 )\n        qword_61DB68 = sub_40456F(v6, (__int64)&stat_buf);\n    }\n    v18 = v17 * v16 + 1;\n    if ( v16 != v18 / v17 || qword_61DB68 - v14 <= v18 )\n      return qword_61DB68;\n    v14 += v18;\n  }\n  return v14;\n}\n"], [4213129, "sub_404989", "__int64 __fastcall sub_404989(__int64 a1, __int64 a2, unsigned __int64 a3)\n{\n  __int64 result; // rax\n  unsigned __int64 sizea; // [rsp+8h] [rbp-18h]\n\n  while ( 1 )\n  {\n    sizea = (a3 & 0xFFFFFFFFFFFFFFE0LL) + 32;\n    *(_QWORD *)a1 = malloc(sizea);\n    if ( *(_QWORD *)a1 )\n      break;\n    a3 = sizea >> 1;\n    if ( a2 + 1 >= a3 )\n      sub_415114();\n  }\n  *(_QWORD *)(a1 + 40) = a2;\n  *(_QWORD *)(a1 + 24) = sizea;\n  *(_QWORD *)(a1 + 16) = 0LL;\n  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a1 + 16);\n  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a1 + 32);\n  result = a1;\n  *(_BYTE *)(a1 + 48) = 0;\n  return result;\n}\n"], [4213311, "sub_404A3F", "__int64 __fastcall sub_404A3F(_QWORD *a1)\n{\n  return *a1 + a1[3];\n}\n"], [4213339, "sub_404A5B", "unsigned __int8 *__fastcall sub_404A5B(__int64 a1, __int64 *a2)\n{\n  unsigned __int8 *result; // rax\n  unsigned __int8 *v5; // [rsp+10h] [rbp-20h]\n  __int64 v6; // [rsp+18h] [rbp-18h]\n  unsigned __int64 v7; // [rsp+20h] [rbp-10h]\n  __int64 v8; // [rsp+28h] [rbp-8h]\n\n  v5 = *(unsigned __int8 **)a1;\n  v7 = *(_QWORD *)(a1 + 8) - 1LL + *(_QWORD *)a1;\n  v6 = *a2;\n  v8 = a2[1];\n  if ( dword_61D4E8 == 128 )\n  {\n    while ( (unsigned __int64)v5 < v7 )\n    {\n      if ( !v6-- )\n        break;\n      while ( (unsigned __int64)v5 < v7 && byte_61D5E0[(unsigned __int8)sub_402B35(*v5)] )\n        ++v5;\n      while ( (unsigned __int64)v5 < v7 && byte_61D5E0[(unsigned __int8)sub_402B35(*v5)] != 1 )\n        ++v5;\n    }\n  }\n  else\n  {\n    while ( (unsigned __int64)v5 < v7 )\n    {\n      if ( !v6-- )\n        break;\n      while ( (unsigned __int64)v5 < v7 && (char)*v5 != dword_61D4E8 )\n        ++v5;\n      if ( (unsigned __int64)v5 < v7 )\n        ++v5;\n    }\n  }\n  if ( *((_BYTE *)a2 + 48) )\n  {\n    while ( (unsigned __int64)v5 < v7 && byte_61D5E0[(unsigned __int8)sub_402B35(*v5)] )\n      ++v5;\n  }\n  result = (unsigned __int8 *)v7;\n  if ( (unsigned __int64)&v5[v8] <= v7 )\n    result = &v5[v8];\n  return result;\n}\n"], [4213745, "sub_404BF1", "unsigned __int8 *__fastcall sub_404BF1(__int64 a1, __int64 a2)\n{\n  unsigned __int8 *v4; // rax\n  unsigned __int8 *v6; // [rsp+10h] [rbp-20h]\n  __int64 v7; // [rsp+18h] [rbp-18h]\n  unsigned __int64 v8; // [rsp+20h] [rbp-10h]\n  __int64 v9; // [rsp+28h] [rbp-8h]\n\n  v6 = *(unsigned __int8 **)a1;\n  v8 = *(_QWORD *)(a1 + 8) - 1LL + *(_QWORD *)a1;\n  v7 = *(_QWORD *)(a2 + 16);\n  v9 = *(_QWORD *)(a2 + 24);\n  if ( !v9 )\n    ++v7;\n  if ( dword_61D4E8 == 128 )\n  {\n    while ( (unsigned __int64)v6 < v8 )\n    {\n      if ( !v7-- )\n        break;\n      while ( (unsigned __int64)v6 < v8 && byte_61D5E0[(unsigned __int8)sub_402B35(*v6)] )\n        ++v6;\n      while ( (unsigned __int64)v6 < v8 && byte_61D5E0[(unsigned __int8)sub_402B35(*v6)] != 1 )\n        ++v6;\n    }\n  }\n  else\n  {\n    while ( (unsigned __int64)v6 < v8 )\n    {\n      if ( !v7-- )\n        break;\n      while ( (unsigned __int64)v6 < v8 && (char)*v6 != dword_61D4E8 )\n        ++v6;\n      if ( (unsigned __int64)v6 < v8 && (v7 || v9) )\n        ++v6;\n    }\n  }\n  if ( v9 )\n  {\n    if ( *(_BYTE *)(a2 + 49) )\n    {\n      while ( (unsigned __int64)v6 < v8 && byte_61D5E0[(unsigned __int8)sub_402B35(*v6)] )\n        ++v6;\n    }\n    v4 = (unsigned __int8 *)v8;\n    if ( (unsigned __int64)&v6[v9] <= v8 )\n      v4 = &v6[v9];\n    v6 = v4;\n  }\n  return v6;\n}\n"], [4214185, "sub_404DA9", "__int64 __fastcall sub_404DA9(_QWORD *a1, FILE *a2, char *a3)\n{\n  unsigned __int8 *v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  unsigned __int64 v7; // rax\n  unsigned __int8 *v8; // rax\n  unsigned __int8 *v9; // rax\n  __int64 v10; // rax\n  char v12; // [rsp+27h] [rbp-79h]\n  __int64 v13; // [rsp+28h] [rbp-78h] BYREF\n  unsigned __int64 v14; // [rsp+30h] [rbp-70h]\n  void *ptr; // [rsp+38h] [rbp-68h]\n  unsigned __int8 **v16; // [rsp+40h] [rbp-60h]\n  unsigned __int64 v17; // [rsp+48h] [rbp-58h]\n  unsigned __int8 *v18; // [rsp+50h] [rbp-50h]\n  unsigned __int8 *v19; // [rsp+58h] [rbp-48h]\n  __int64 *v20; // [rsp+60h] [rbp-40h]\n  __int64 v21; // [rsp+68h] [rbp-38h]\n  __int64 v22; // [rsp+70h] [rbp-30h]\n  size_t n; // [rsp+78h] [rbp-28h]\n  size_t v24; // [rsp+80h] [rbp-20h]\n  unsigned __int8 *v25; // [rsp+88h] [rbp-18h]\n\n  v20 = (__int64 *)qword_61DA08;\n  v12 = byte_61D400;\n  v21 = a1[5];\n  v14 = qword_61D4E0 - 34;\n  if ( *((_BYTE *)a1 + 48) )\n    return 0LL;\n  if ( a1[1] != a1[4] )\n  {\n    memmove((void *)*a1, (const void *)(a1[1] - a1[4] + *a1), a1[4]);\n    a1[1] = a1[4];\n    a1[2] = 0LL;\n  }\n  while ( 1 )\n  {\n    ptr = (void *)(*a1 + a1[1]);\n    v22 = sub_404A3F(a1);\n    v16 = (unsigned __int8 **)(-32LL * a1[2] + v22);\n    v17 = v22 - v21 * a1[2] - (_QWORD)ptr;\n    v4 = a1[2] ? &v16[1][(_QWORD)*v16] : *a1;\n    v18 = v4;\n    do\n    {\n      if ( v21 + 1 >= v17 )\n        break;\n      n = (v17 - 1) / (v21 + 1);\n      v24 = fread_unlocked(ptr, 1uLL, n, a2);\n      v19 = (unsigned __int8 *)ptr + v24;\n      v17 -= v24;\n      if ( v24 != n )\n      {\n        if ( ferror_unlocked(a2) )\n        {\n          v5 = gettext(\"read failed\");\n          sub_402C5C(v5, a3);\n        }\n        if ( feof_unlocked(a2) )\n        {\n          *((_BYTE *)a1 + 48) = 1;\n          if ( (unsigned __int8 *)*a1 == v19 )\n            return 0LL;\n          if ( v18 != v19 && *(v19 - 1) != v12 )\n          {\n            v6 = (char *)v19++;\n            *v6 = v12;\n          }\n        }\n      }\n      while ( 1 )\n      {\n        v25 = (unsigned __int8 *)memchr(ptr, v12, v19 - (_BYTE *)ptr);\n        if ( !v25 )\n          break;\n        *v25 = 0;\n        ptr = v25 + 1;\n        v16 -= 4;\n        *v16 = v18;\n        v16[1] = (unsigned __int8 *)((_BYTE *)ptr - v18);\n        v7 = v14;\n        if ( (unsigned __int64)v16[1] >= v14 )\n          v7 = (unsigned __int64)v16[1];\n        v14 = v7;\n        v17 -= v21;\n        if ( v20 )\n        {\n          if ( v20[2] == -1 )\n            v8 = v25;\n          else\n            v8 = sub_404BF1((__int64)v16, (__int64)v20);\n          v16[3] = v8;\n          if ( *v20 == -1 )\n          {\n            if ( *((_BYTE *)v20 + 48) )\n            {\n              while ( byte_61D5E0[(unsigned __int8)sub_402B35(*v18)] )\n                ++v18;\n            }\n            v16[2] = v18;\n          }\n          else\n          {\n            v9 = sub_404A5B((__int64)v16, v20);\n            v16[2] = v9;\n          }\n        }\n        v18 = (unsigned __int8 *)ptr;\n      }\n      ptr = v19;\n    }\n    while ( !*((_BYTE *)a1 + 48) );\n    a1[1] = (char *)ptr - *a1;\n    v10 = sub_404A3F(a1);\n    a1[2] = (v10 - (__int64)v16) >> 5;\n    if ( a1[2] )\n      break;\n    v13 = a1[3] >> 5;\n    *a1 = sub_414ED3(*a1, &v13, 32LL);\n    a1[3] = 32 * v13;\n  }\n  a1[4] = (_BYTE *)ptr - v18;\n  qword_61D4E0 = v14 + 34;\n  return 1LL;\n}\n"], [4215463, "sub_4052A7", "__int64 __fastcall sub_4052A7(_BYTE *a1)\n{\n  unsigned __int8 *v1; // rax\n  unsigned __int8 *v2; // rax\n  __int64 result; // rax\n  unsigned __int8 v4; // [rsp+16h] [rbp-12h]\n  int v5; // [rsp+18h] [rbp-10h]\n  unsigned int v6; // [rsp+1Ch] [rbp-Ch]\n  unsigned __int8 *v7; // [rsp+20h] [rbp-8h]\n\n  v7 = &a1[*a1 == 45];\n  v5 = 0;\n  do\n  {\n    while ( 1 )\n    {\n      v1 = v7++;\n      v4 = *v1;\n      if ( (unsigned int)*v1 - 48 > 9 )\n        break;\n      v5 |= v4 - 48;\n    }\n  }\n  while ( v4 == dword_61D5C4 );\n  if ( v4 == dword_61D5C0 )\n  {\n    while ( 1 )\n    {\n      v2 = v7++;\n      v4 = *v2;\n      if ( (unsigned int)*v2 - 48 > 9 )\n        break;\n      v5 |= v4 - 48;\n    }\n  }\n  if ( !v5 )\n    return 0LL;\n  v6 = byte_418AC0[v4];\n  if ( *a1 == 45 )\n    result = -v6;\n  else\n    result = v6;\n  return result;\n}\n"], [4215672, "sub_405378", "__int64 __fastcall sub_405378(unsigned __int8 *a1, unsigned __int8 *a2)\n{\n  int v2; // ebx\n  __int64 result; // rax\n  unsigned int v6; // [rsp+1Ch] [rbp-14h]\n\n  while ( byte_61D5E0[(unsigned __int8)sub_402B35(*a1)] )\n    ++a1;\n  while ( byte_61D5E0[(unsigned __int8)sub_402B35(*a2)] )\n    ++a2;\n  v2 = sub_4052A7(a1);\n  v6 = v2 - sub_4052A7(a2);\n  if ( v6 )\n    result = v6;\n  else\n    result = sub_4169F1(a1, a2, (unsigned int)dword_61D5C0, (unsigned int)dword_61D5C4);\n  return result;\n}\n"], [4215848, "sub_405428", "__int64 __fastcall sub_405428(unsigned __int8 *a1, unsigned __int8 *a2)\n{\n  while ( byte_61D5E0[(unsigned __int8)sub_402B35(*a1)] )\n    ++a1;\n  while ( byte_61D5E0[(unsigned __int8)sub_402B35(*a2)] )\n    ++a2;\n  return sub_4169F1(a1, a2, (unsigned int)dword_61D5C0, (unsigned int)dword_61D5C4);\n}\n"], [4215974, "sub_4054A6", "__int64 __fastcall sub_4054A6(const char *a1, const char *a2)\n{\n  __int64 result; // rax\n  char *endptr; // [rsp+10h] [rbp-30h] BYREF\n  char *v4; // [rsp+18h] [rbp-28h] BYREF\n  long double s1; // [rsp+20h] [rbp-20h]\n  long double s2; // [rsp+30h] [rbp-10h]\n\n  s1 = strtold(a1, &endptr);\n  s2 = strtold(a2, &v4);\n  if ( a1 == endptr )\n  {\n    if ( a2 == v4 )\n      result = 0LL;\n    else\n      result = 0xFFFFFFFFLL;\n  }\n  else if ( a2 == v4 )\n  {\n    result = 1LL;\n  }\n  else if ( s2 <= s1 )\n  {\n    if ( s1 <= s2 )\n    {\n      if ( s2 == s1 )\n        result = 0LL;\n      else\n        result = 0xFFFFFFFFLL;\n    }\n    else\n    {\n      result = 1LL;\n    }\n  }\n  else\n  {\n    result = 0xFFFFFFFFLL;\n  }\n  return result;\n}\n"], [4216247, "sub_4055B7", "__int64 __fastcall sub_4055B7(unsigned __int8 *a1, unsigned __int8 **a2)\n{\n  unsigned __int8 v3; // al\n  unsigned __int8 v4; // bl\n  unsigned __int8 v5; // al\n  unsigned __int8 v6; // bl\n  unsigned __int64 v8; // [rsp+18h] [rbp-30h]\n  unsigned __int64 v9; // [rsp+20h] [rbp-28h]\n  unsigned __int8 *v10; // [rsp+28h] [rbp-20h]\n  unsigned __int8 *i; // [rsp+30h] [rbp-18h]\n  unsigned __int64 v12; // [rsp+38h] [rbp-10h]\n\n  v8 = 0LL;\n  v9 = 12LL;\n  while ( byte_61D5E0[(unsigned __int8)sub_402B35(*a1)] )\n    ++a1;\n  while ( 2 )\n  {\n    v12 = (v8 + v9) >> 1;\n    v10 = a1;\n    for ( i = (unsigned __int8 *)(&off_61D420)[2 * v12]; ; ++i )\n    {\n      if ( !*i )\n      {\n        if ( a2 )\n          *a2 = v10;\n        return (unsigned int)dword_61D428[4 * v12];\n      }\n      v3 = sub_402B35(*v10);\n      v4 = sub_402B35(byte_61D8E0[v3]);\n      if ( v4 < (unsigned __int8)sub_402B35(*i) )\n      {\n        v9 = (v8 + v9) >> 1;\n        goto LABEL_14;\n      }\n      v5 = sub_402B35(*v10);\n      v6 = sub_402B35(byte_61D8E0[v5]);\n      if ( v6 > (unsigned __int8)sub_402B35(*i) )\n        break;\n      ++v10;\n    }\n    v8 = v12 + 1;\nLABEL_14:\n    if ( v8 < v9 )\n      continue;\n    return 0LL;\n  }\n}\n"], [4216607, "sub_40571F", "unsigned __int64 __fastcall sub_40571F(char *a1)\n{\n  char *v1; // rax\n  char *v2; // rax\n  __int64 v4; // [rsp+18h] [rbp-28h]\n  char v5[24]; // [rsp+20h] [rbp-20h] BYREF\n  unsigned __int64 v6; // [rsp+38h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  v4 = sub_412DAA(a1, 16LL);\n  if ( !v4 )\n  {\n    v1 = gettext(\"open failed\");\n    sub_402C5C(v1, a1);\n  }\n  sub_4130A3(v4, v5, 16LL);\n  if ( (unsigned int)sub_4130F9(v4) )\n  {\n    v2 = gettext(\"close failed\");\n    sub_402C5C(v2, a1);\n  }\n  sub_40D303(&unk_61DAC0);\n  sub_40D6EA(v5, 16LL, &unk_61DAC0);\n  return __readfsqword(0x28u) ^ v6;\n}\n"], [4216806, "sub_4057E6", "size_t __fastcall sub_4057E6(char *a1, const char *a2, size_t a3)\n{\n  char *v3; // rbx\n  int *v4; // rax\n  char *v5; // rax\n  __int64 v6; // rbx\n  char *v7; // rax\n  size_t v10; // [rsp+28h] [rbp-18h]\n\n  *__errno_location() = 0;\n  v10 = strxfrm(a1, a2, a3);\n  if ( *__errno_location() )\n  {\n    v3 = gettext(\"string transformation failed\");\n    v4 = __errno_location();\n    error(0, *v4, v3);\n    v5 = gettext(\"set LC_ALL='C' to work around the problem\");\n    error(0, 0, v5);\n    v6 = sub_412786(0LL, 6LL, a2);\n    v7 = gettext(\"the untransformed string was %s\");\n    error(2, 0, v7, v6);\n  }\n  return v10;\n}\n"], [4217025, "sub_4058C1", "__int64 __fastcall sub_4058C1(char *a1, size_t a2, char *a3, size_t a4)\n{\n  unsigned __int64 v4; // rax\n  size_t v5; // rax\n  size_t v6; // rdx\n  char *v7; // rax\n  size_t v8; // rax\n  size_t v9; // rax\n  size_t v10; // rax\n  size_t v12; // [rsp+0h] [rbp-1190h]\n  char *s; // [rsp+8h] [rbp-1188h]\n  size_t v14; // [rsp+10h] [rbp-1180h]\n  char *src; // [rsp+18h] [rbp-1178h]\n  bool v16; // [rsp+27h] [rbp-1169h]\n  int v17; // [rsp+28h] [rbp-1168h]\n  unsigned int v18; // [rsp+2Ch] [rbp-1164h]\n  char *dest; // [rsp+30h] [rbp-1160h]\n  unsigned __int64 size; // [rsp+38h] [rbp-1158h]\n  void *ptr; // [rsp+40h] [rbp-1150h]\n  unsigned __int64 v22; // [rsp+48h] [rbp-1148h]\n  unsigned __int64 v23; // [rsp+50h] [rbp-1140h]\n  unsigned __int64 v24; // [rsp+58h] [rbp-1138h]\n  size_t n; // [rsp+60h] [rbp-1130h]\n  size_t v26; // [rsp+68h] [rbp-1128h]\n  char s1[16]; // [rsp+70h] [rbp-1120h] BYREF\n  _BYTE v28[16]; // [rsp+80h] [rbp-1110h] BYREF\n  char v29[152]; // [rsp+90h] [rbp-1100h] BYREF\n  int v30; // [rsp+128h] [rbp-1068h]\n  _DWORD v31[41]; // [rsp+12Ch] [rbp-1064h] BYREF\n  char v32[4008]; // [rsp+1D0h] [rbp-FC0h] BYREF\n  unsigned __int64 v33; // [rsp+1178h] [rbp-18h]\n\n  src = a1;\n  v14 = a2;\n  s = a3;\n  v12 = a4;\n  v33 = __readfsqword(0x28u);\n  v17 = 0;\n  dest = v32;\n  size = 4000LL;\n  ptr = 0LL;\n  v31[0] = dword_61DAC0[0];\n  qmemcpy(&v31[1], &dword_61DAC0[1], 0x98uLL);\n  qmemcpy(v29, v31, sizeof(v29));\n  v30 = v31[38];\n  if ( byte_61D5C8 )\n  {\n    v22 = (unsigned __int64)&a1[a2];\n    v23 = (unsigned __int64)&a3[a4];\n    while ( 1 )\n    {\n      v24 = 3 * (v12 + a2) + 2;\n      if ( size < v24 )\n      {\n        v4 = 3 * (v12 + a2) + 2;\n        if ( (3 * size) >> 1 >= v24 )\n          v4 = (3 * size) >> 1;\n        size = v4;\n        free(ptr);\n        ptr = malloc(size);\n        dest = (char *)ptr;\n        if ( !ptr )\n        {\n          dest = v32;\n          size = 4000LL;\n        }\n      }\n      if ( (unsigned __int64)src >= v22 )\n        v5 = 0LL;\n      else\n        v5 = sub_4057E6(dest, src, size) + 1;\n      n = v5;\n      v16 = v5 <= size;\n      if ( (unsigned __int64)s >= v23 )\n      {\n        v8 = 0LL;\n      }\n      else\n      {\n        if ( v5 > size )\n          v6 = 0LL;\n        else\n          v6 = size - v5;\n        if ( v5 > size )\n          v7 = 0LL;\n        else\n          v7 = &dest[v5];\n        v8 = sub_4057E6(v7, s, v6) + 1;\n      }\n      v26 = v8;\n      if ( !v16 || n + v8 > size )\n      {\n        size = n + v8;\n        if ( n + v8 <= 0x5555555555555554LL )\n          size = (3 * size) >> 1;\n        free(ptr);\n        ptr = (void *)sub_414F92(size);\n        dest = (char *)ptr;\n        if ( (unsigned __int64)src < v22 )\n          strxfrm((char *)ptr, src, n);\n        if ( (unsigned __int64)s < v23 )\n          strxfrm((char *)ptr + n, s, v26);\n      }\n      if ( (unsigned __int64)src < v22 )\n        src += strlen(src) + 1;\n      if ( (unsigned __int64)s < v23 )\n        s += strlen(s) + 1;\n      if ( (unsigned __int64)src >= v22 && (unsigned __int64)s >= v23 )\n        break;\n      sub_40D6EA(dest, n, v29);\n      sub_40D6EA(&dest[n], v26, v31);\n      if ( !v17 )\n      {\n        v9 = n;\n        if ( v26 <= n )\n          v9 = v26;\n        v17 = memcmp(dest, &dest[n], v9);\n        if ( !v17 )\n          v17 = (n > v26) - (n < v26);\n      }\n    }\n    v14 = n;\n    src = dest;\n    v12 = v26;\n    s = &dest[n];\n    sub_40D6EA(dest, n, v29);\n  }\n  else\n  {\n    sub_40D6EA(a1, a2, v29);\n  }\n  sub_40D3EF(v29, s1);\n  sub_40D6EA(s, v12, v31);\n  sub_40D3EF(v31, v28);\n  v18 = memcmp(s1, v28, 0x10uLL);\n  if ( !v18 )\n  {\n    if ( !v17 )\n    {\n      v10 = v14;\n      if ( v12 <= v14 )\n        v10 = v12;\n      v17 = memcmp(src, s, v10);\n      if ( !v17 )\n        v17 = (v14 > v12) - (v14 < v12);\n    }\n    v18 = v17;\n  }\n  free(ptr);\n  return v18;\n}\n"], [4218725, "sub_405F65", "__int64 __fastcall sub_405F65(_BYTE *a1, unsigned __int64 a2)\n{\n  _BYTE *v2; // rax\n  _BYTE *v4; // [rsp+8h] [rbp-18h]\n  __int64 v5; // [rsp+18h] [rbp-8h]\n\n  v4 = a1;\n  v5 = (int)sub_410C28(a1, a2 - (_QWORD)a1, 0LL);\n  while ( (unsigned __int64)v4 < a2 )\n  {\n    v2 = v4++;\n    v5 += *v2 == 9;\n  }\n  return v5;\n}\n"], [4218829, "sub_405FCD", "int __fastcall sub_405FCD(__int64 a1, __int64 a2)\n{\n  char *v3; // rax\n  int result; // eax\n  __int64 v5; // [rsp+0h] [rbp-10h]\n\n  v5 = a2;\n  while ( a1-- )\n    putchar_unlocked(32);\n  if ( a2 )\n  {\n    do\n    {\n      putchar_unlocked(95);\n      --v5;\n    }\n    while ( v5 );\n    result = putchar_unlocked(10);\n  }\n  else\n  {\n    v3 = gettext(\"^ no match for key\\n\");\n    result = printf(v3);\n  }\n  return result;\n}\n"], [4218940, "sub_40603C", "_BOOL8 __fastcall sub_40603C(_BYTE *a1)\n{\n  return a1[50] || a1[52] || a1[53];\n}\n"], [4219001, "sub_406079", "int __fastcall sub_406079(__int64 a1, __int64 a2)\n{\n  _BOOL4 v2; // eax\n  char *v3; // rax\n  char *v4; // rax\n  _BOOL4 v5; // eax\n  char v7; // [rsp+15h] [rbp-4Bh]\n  unsigned __int8 v8; // [rsp+16h] [rbp-4Ah]\n  char v9; // [rsp+17h] [rbp-49h]\n  char *endptr; // [rsp+18h] [rbp-48h] BYREF\n  char *nptr; // [rsp+20h] [rbp-40h]\n  char *v12; // [rsp+28h] [rbp-38h]\n  char *v13; // [rsp+30h] [rbp-30h]\n  char *v14; // [rsp+38h] [rbp-28h]\n  __int64 v15; // [rsp+40h] [rbp-20h]\n  __int64 v16; // [rsp+48h] [rbp-18h]\n  long double v17; // [rsp+50h] [rbp-10h]\n\n  v14 = *(char **)a1;\n  nptr = v14;\n  v12 = &v14[*(_QWORD *)(a1 + 8) - 1];\n  if ( a2 )\n  {\n    if ( *(_QWORD *)a2 != -1LL )\n      nptr = (char *)sub_404A5B(a1, (__int64 *)a2);\n    if ( *(_QWORD *)(a2 + 16) != -1LL )\n      v12 = (char *)sub_404BF1(a1, a2);\n    if ( *(_BYTE *)(a2 + 48) || *(_BYTE *)(a2 + 54) || sub_40603C((_BYTE *)a2) )\n    {\n      v9 = *v12;\n      *v12 = 0;\n      while ( byte_61D5E0[(unsigned __int8)sub_402B35(*nptr)] )\n        ++nptr;\n      endptr = nptr;\n      if ( v12 >= nptr )\n      {\n        if ( *(_BYTE *)(a2 + 54) )\n        {\n          sub_4055B7((unsigned __int8 *)nptr, (unsigned __int8 **)&endptr);\n        }\n        else if ( *(_BYTE *)(a2 + 52) )\n        {\n          v17 = strtold(nptr, &endptr);\n        }\n        else if ( *(_BYTE *)(a2 + 50) || *(_BYTE *)(a2 + 53) )\n        {\n          v2 = nptr < v12 && *nptr == 45;\n          v13 = &nptr[v2];\n          v7 = 0;\n          do\n          {\n            while ( 1 )\n            {\n              v3 = v13++;\n              v8 = *v3;\n              if ( (unsigned int)(unsigned __int8)*v3 - 48 > 9 )\n                break;\n              v7 = 1;\n            }\n          }\n          while ( v8 == dword_61D5C4 );\n          if ( v8 == dword_61D5C0 )\n          {\n            while ( 1 )\n            {\n              v4 = v13++;\n              v8 = *v4;\n              if ( (unsigned int)(unsigned __int8)*v4 - 48 > 9 )\n                break;\n              v7 = 1;\n            }\n          }\n          if ( v7 )\n          {\n            v5 = *(_BYTE *)(a2 + 53) != 1 || !byte_418AC0[v8];\n            endptr = &v13[-v5];\n          }\n        }\n        else\n        {\n          endptr = v12;\n        }\n      }\n      else\n      {\n        endptr = v12;\n      }\n      *v12 = v9;\n      v12 = endptr;\n    }\n  }\n  v15 = sub_405F65(v14, (unsigned __int64)nptr);\n  v16 = sub_405F65(nptr, (unsigned __int64)v12);\n  return sub_405FCD(v15, v16);\n}\n"], [4219697, "sub_406331", "int __fastcall sub_406331(__int64 a1)\n{\n  int result; // eax\n  __int64 v2; // [rsp+18h] [rbp-8h]\n\n  v2 = qword_61DA08;\n  while ( 1 )\n  {\n    result = sub_406079(a1, v2);\n    if ( !v2 )\n      break;\n    v2 = *(_QWORD *)(v2 + 64);\n    if ( !v2 )\n    {\n      result = (unsigned __int8)byte_61DA02 ^ 1;\n      if ( byte_61DA02 == 1 )\n        break;\n      result = (unsigned __int8)byte_61DA01 ^ 1;\n      if ( byte_61DA01 == 1 )\n        break;\n    }\n  }\n  return result;\n}\n"], [4219795, "sub_406393", "_BOOL8 __fastcall sub_406393(__int64 a1)\n{\n  return !*(_QWORD *)(a1 + 32)\n      && !*(_QWORD *)(a1 + 40)\n      && *(_BYTE *)(a1 + 48) != 1\n      && *(_BYTE *)(a1 + 49) != 1\n      && !sub_40603C((_BYTE *)a1)\n      && *(_BYTE *)(a1 + 54) != 1\n      && *(_BYTE *)(a1 + 56) != 1\n      && *(_BYTE *)(a1 + 51) != 1;\n}\n"], [4219944, "sub_406428", "_BYTE *__fastcall sub_406428(__int64 a1, _BYTE *a2)\n{\n  _BYTE *v2; // rax\n  _BYTE *v3; // rax\n  _BYTE *v4; // rax\n  _BYTE *v5; // rax\n  _BYTE *v6; // rax\n  _BYTE *v7; // rax\n  _BYTE *v8; // rax\n  _BYTE *v9; // rax\n  _BYTE *v10; // rax\n  _BYTE *v11; // rax\n  _BYTE *result; // rax\n  _BYTE *v13; // [rsp+0h] [rbp-10h]\n\n  v13 = a2;\n  if ( *(_BYTE *)(a1 + 48) || *(_BYTE *)(a1 + 49) )\n  {\n    v13 = a2 + 1;\n    *a2 = 98;\n  }\n  if ( *(_UNKNOWN **)(a1 + 32) == &unk_61D7E0 )\n  {\n    v2 = v13++;\n    *v2 = 100;\n  }\n  if ( *(_QWORD *)(a1 + 40) )\n  {\n    v3 = v13++;\n    *v3 = 102;\n  }\n  if ( *(_BYTE *)(a1 + 52) )\n  {\n    v4 = v13++;\n    *v4 = 103;\n  }\n  if ( *(_BYTE *)(a1 + 53) )\n  {\n    v5 = v13++;\n    *v5 = 104;\n  }\n  if ( *(_UNKNOWN **)(a1 + 32) == &unk_61D6E0 )\n  {\n    v6 = v13++;\n    *v6 = 105;\n  }\n  if ( *(_BYTE *)(a1 + 54) )\n  {\n    v7 = v13++;\n    *v7 = 77;\n  }\n  if ( *(_BYTE *)(a1 + 50) )\n  {\n    v8 = v13++;\n    *v8 = 110;\n  }\n  if ( *(_BYTE *)(a1 + 51) )\n  {\n    v9 = v13++;\n    *v9 = 82;\n  }\n  if ( *(_BYTE *)(a1 + 55) )\n  {\n    v10 = v13++;\n    *v10 = 114;\n  }\n  if ( *(_BYTE *)(a1 + 56) )\n  {\n    v11 = v13++;\n    *v11 = 86;\n  }\n  result = v13;\n  *v13 = 0;\n  return result;\n}\n"], [4220283, "sub_40657B", "unsigned __int64 __fastcall sub_40657B(__int64 *a1, char a2)\n{\n  const char *v2; // rax\n  const char *v3; // rax\n  const char *v4; // rax\n  const char *v5; // rax\n  char *v6; // rax\n  char *v7; // rax\n  bool v8; // al\n  bool v9; // al\n  bool v10; // al\n  char *v11; // rax\n  char *v12; // rax\n  __int64 v13; // rax\n  __int64 v14; // rax\n  char *v15; // rax\n  char *v16; // rax\n  bool v18; // [rsp+1Ch] [rbp-124h]\n  bool v19; // [rsp+1Dh] [rbp-123h]\n  char v20; // [rsp+1Fh] [rbp-121h]\n  __int64 v21; // [rsp+20h] [rbp-120h]\n  __int64 v22; // [rsp+28h] [rbp-118h]\n  __int64 v23; // [rsp+30h] [rbp-110h]\n  unsigned __int64 v24; // [rsp+38h] [rbp-108h]\n  __int64 v25; // [rsp+40h] [rbp-100h]\n  char *v26; // [rsp+48h] [rbp-F8h]\n  char *v27; // [rsp+50h] [rbp-F0h]\n  __int64 v28[4]; // [rsp+60h] [rbp-E0h] BYREF\n  __int64 v29; // [rsp+80h] [rbp-C0h]\n  __int64 v30; // [rsp+88h] [rbp-B8h]\n  __int64 v31; // [rsp+90h] [rbp-B0h]\n  __int64 v32; // [rsp+98h] [rbp-A8h]\n  __int64 v33; // [rsp+A0h] [rbp-A0h]\n  char v34[32]; // [rsp+B0h] [rbp-90h] BYREF\n  _WORD v35[24]; // [rsp+D0h] [rbp-70h] BYREF\n  char s[56]; // [rsp+100h] [rbp-40h] BYREF\n  unsigned __int64 v37; // [rsp+138h] [rbp-8h]\n\n  v37 = __readfsqword(0x28u);\n  v28[0] = *a1;\n  v28[1] = a1[1];\n  v28[2] = a1[2];\n  v28[3] = a1[3];\n  v29 = a1[4];\n  v30 = a1[5];\n  v31 = a1[6];\n  v32 = a1[7];\n  v33 = a1[8];\n  v22 = 1LL;\n  v21 = qword_61DA08;\n  while ( v21 )\n  {\n    if ( *(_BYTE *)(v21 + 57) )\n    {\n      v23 = *(_QWORD *)v21;\n      v25 = *(_QWORD *)(v21 + 16);\n      if ( *(_QWORD *)v21 == -1LL )\n        v23 = 0LL;\n      v2 = (const char *)sub_410B71(v23, v34);\n      v35[0] = 43;\n      v26 = stpcpy((char *)v35 + 1, v2);\n      v3 = (const char *)sub_410B71(v23 + 1, v34);\n      *(_DWORD *)s = 2124589;\n      v27 = stpcpy(&s[3], v3);\n      if ( *(_QWORD *)(v21 + 16) != -1LL )\n      {\n        v4 = (const char *)sub_410B71(v25 + 1, v34);\n        strcpy(v26, \" -\");\n        strcpy(v26 + 2, v4);\n        v5 = (const char *)sub_410B71((*(_QWORD *)(v21 + 24) == -1LL) + v25 + 1, v34);\n        *(_WORD *)v27 = 44;\n        strcpy(v27 + 1, v5);\n      }\n      v6 = gettext(\"obsolescent key `%s' used; consider `%s' instead\");\n      error(0, 0, v6, v35, s);\n    }\n    if ( *(_QWORD *)v21 != -1LL && *(_QWORD *)(v21 + 16) < *(_QWORD *)v21 )\n    {\n      v7 = gettext(\"key %lu has zero width and will be ignored\");\n      error(0, 0, v7, v22);\n    }\n    v8 = sub_40603C((_BYTE *)v21) || *(_BYTE *)(v21 + 54);\n    v18 = v8;\n    v9 = byte_61D5C8 != 1 && sub_406393(v21) && !*(_QWORD *)(v21 + 8) && !*(_QWORD *)(v21 + 24);\n    v19 = v9;\n    v10 = !*(_QWORD *)(v21 + 16) && *(_QWORD *)(v21 + 24);\n    if ( a2 != 1\n      && dword_61D4E8 == 128\n      && !v10\n      && (*(_BYTE *)(v21 + 48) != 1 && !v18 && !v19\n       || *(_BYTE *)(v21 + 48) != 1 && *(_QWORD *)(v21 + 8)\n       || *(_BYTE *)(v21 + 49) != 1 && *(_QWORD *)(v21 + 24)) )\n    {\n      v11 = gettext(\"leading blanks are significant in key %lu; consider also specifying `b'\");\n      error(0, 0, v11, v22);\n    }\n    if ( a2 != 1 && sub_40603C((_BYTE *)v21) )\n    {\n      v24 = *(_QWORD *)v21 + 1LL;\n      if ( *(_QWORD *)v21 == -1LL )\n        v24 = 1LL;\n      if ( *(_QWORD *)(v21 + 16) == -1LL || v24 < *(_QWORD *)(v21 + 16) + 1LL )\n      {\n        v12 = gettext(\"key %lu is numeric and spans multiple fields\");\n        error(0, 0, v12, v22);\n      }\n    }\n    if ( v29 && v29 == *(_QWORD *)(v21 + 32) )\n      v29 = 0LL;\n    if ( v30 && v30 == *(_QWORD *)(v21 + 40) )\n      v30 = 0LL;\n    LOBYTE(v31) = (unsigned __int8)(v31 & (*(_BYTE *)(v21 + 48) ^ 1)) != 0;\n    BYTE1(v31) = (BYTE1(v31) & (*(_BYTE *)(v21 + 49) ^ 1)) != 0;\n    BYTE6(v31) = (BYTE6(v31) & (*(_BYTE *)(v21 + 54) ^ 1)) != 0;\n    BYTE2(v31) = (BYTE2(v31) & (*(_BYTE *)(v21 + 50) ^ 1)) != 0;\n    BYTE4(v31) = (BYTE4(v31) & (*(_BYTE *)(v21 + 52) ^ 1)) != 0;\n    BYTE5(v31) = (BYTE5(v31) & (*(_BYTE *)(v21 + 53) ^ 1)) != 0;\n    BYTE3(v31) = (BYTE3(v31) & (*(_BYTE *)(v21 + 51) ^ 1)) != 0;\n    LOBYTE(v32) = (unsigned __int8)(v32 & (*(_BYTE *)(v21 + 56) ^ 1)) != 0;\n    HIBYTE(v31) = (HIBYTE(v31) & (*(_BYTE *)(v21 + 55) ^ 1)) != 0;\n    v21 = *(_QWORD *)(v21 + 64);\n    ++v22;\n  }\n  if ( !sub_406393((__int64)v28) || HIBYTE(v31) && (byte_61DA01 || byte_61DA02) && qword_61DA08 )\n  {\n    v20 = HIBYTE(v31);\n    if ( byte_61DA01 != 1 && byte_61DA02 != 1 )\n      HIBYTE(v31) = 0;\n    sub_406428((__int64)v28, s);\n    v13 = strlen(s);\n    v14 = sub_402B44(v13);\n    v15 = ngettext(\"option `-%s' is ignored\", \"options `-%s' are ignored\", v14);\n    error(0, 0, v15, s);\n    HIBYTE(v31) = v20;\n  }\n  if ( HIBYTE(v31) && byte_61DA01 != 1 && byte_61DA02 != 1 && qword_61DA08 )\n  {\n    v16 = gettext(\"option `-r' only applies to last-resort comparison\");\n    error(0, 0, v16);\n  }\n  return __readfsqword(0x28u) ^ v37;\n}\n"], [4222415, "sub_406DCF", "__int64 __fastcall sub_406DCF(unsigned __int8 **a1, unsigned __int8 **a2)\n{\n  unsigned __int8 *v2; // rax\n  unsigned __int8 *v3; // rax\n  size_t v4; // rax\n  unsigned __int8 *v5; // rbx\n  unsigned __int8 v6; // al\n  size_t v7; // rax\n  unsigned __int8 *v8; // rbx\n  unsigned __int8 v9; // al\n  int v10; // ebx\n  unsigned __int8 v11; // al\n  int v12; // ebx\n  unsigned __int8 v13; // al\n  int v14; // ebx\n  unsigned __int8 *v15; // rax\n  unsigned __int8 v16; // al\n  int v17; // ebx\n  unsigned __int8 *v18; // rax\n  unsigned __int8 v19; // al\n  size_t v20; // rax\n  int v21; // eax\n  __int64 result; // rax\n  unsigned __int8 v23; // [rsp+1Ah] [rbp-1046h]\n  unsigned __int8 v24; // [rsp+1Bh] [rbp-1045h]\n  unsigned int v25; // [rsp+1Ch] [rbp-1044h]\n  __int64 v26; // [rsp+20h] [rbp-1040h]\n  unsigned __int8 *s1; // [rsp+28h] [rbp-1038h]\n  unsigned __int8 *s2; // [rsp+30h] [rbp-1030h]\n  unsigned __int8 *v29; // [rsp+38h] [rbp-1028h]\n  unsigned __int8 *v30; // [rsp+38h] [rbp-1028h]\n  unsigned __int8 *v31; // [rsp+40h] [rbp-1020h]\n  unsigned __int64 v32; // [rsp+40h] [rbp-1020h]\n  unsigned __int8 *v33; // [rsp+48h] [rbp-1018h]\n  unsigned __int8 *v34; // [rsp+50h] [rbp-1010h]\n  size_t v35; // [rsp+58h] [rbp-1008h]\n  size_t v36; // [rsp+60h] [rbp-1000h]\n  unsigned __int8 *ptr; // [rsp+68h] [rbp-FF8h]\n  size_t v38; // [rsp+70h] [rbp-FF0h]\n  size_t v39; // [rsp+70h] [rbp-FF0h]\n  __int64 v40; // [rsp+78h] [rbp-FE8h]\n  __int64 v41; // [rsp+80h] [rbp-FE0h]\n  size_t v42; // [rsp+88h] [rbp-FD8h]\n  size_t n; // [rsp+90h] [rbp-FD0h]\n  unsigned __int64 v44; // [rsp+98h] [rbp-FC8h]\n  char v45; // [rsp+A0h] [rbp-FC0h] BYREF\n  unsigned __int64 v46; // [rsp+1048h] [rbp-18h]\n\n  v46 = __readfsqword(0x28u);\n  v26 = qword_61DA08;\n  s1 = a1[2];\n  s2 = a2[2];\n  v29 = a1[3];\n  v31 = a2[3];\n  while ( 1 )\n  {\n    v40 = *(_QWORD *)(v26 + 40);\n    v41 = *(_QWORD *)(v26 + 32);\n    v2 = s1;\n    if ( v29 >= s1 )\n      v2 = v29;\n    v30 = v2;\n    v3 = s2;\n    if ( v31 >= s2 )\n      v3 = v31;\n    v32 = (unsigned __int64)v3;\n    v42 = v30 - s1;\n    n = v3 - s2;\n    if ( byte_61D5C8 || sub_40603C((_BYTE *)v26) || *(_BYTE *)(v26 + 54) || *(_BYTE *)(v26 + 51) || *(_BYTE *)(v26 + 56) )\n    {\n      if ( v41 || v40 )\n      {\n        v44 = v42 + n + 2;\n        if ( v44 > 0xFA0 )\n        {\n          ptr = (unsigned __int8 *)sub_414F92(v44);\n          v33 = ptr;\n        }\n        else\n        {\n          v33 = (unsigned __int8 *)&v45;\n          ptr = 0LL;\n        }\n        v34 = &v33[v42 + 1];\n        v38 = 0LL;\n        v35 = 0LL;\n        while ( v38 < v42 )\n        {\n          if ( !v41 || *(_BYTE *)((unsigned __int8)sub_402B35(s1[v38]) + v41) != 1 )\n          {\n            v4 = v35++;\n            v5 = &v33[v4];\n            if ( v40 )\n              v6 = *(_BYTE *)((unsigned __int8)sub_402B35(s1[v38]) + v40);\n            else\n              v6 = s1[v38];\n            *v5 = v6;\n          }\n          ++v38;\n        }\n        v33[v35] = 0;\n        v39 = 0LL;\n        v36 = 0LL;\n        while ( v39 < n )\n        {\n          if ( !v41 || *(_BYTE *)((unsigned __int8)sub_402B35(s2[v39]) + v41) != 1 )\n          {\n            v7 = v36++;\n            v8 = &v34[v7];\n            if ( v40 )\n              v9 = *(_BYTE *)((unsigned __int8)sub_402B35(s2[v39]) + v40);\n            else\n              v9 = s2[v39];\n            *v8 = v9;\n          }\n          ++v39;\n        }\n        v34[v36] = 0;\n      }\n      else\n      {\n        v33 = s1;\n        v35 = v30 - s1;\n        v23 = *v30;\n        *v30 = 0;\n        v34 = s2;\n        v36 = n;\n        v24 = s2[n];\n        s2[n] = 0;\n      }\n      if ( *(_BYTE *)(v26 + 50) )\n      {\n        v25 = sub_405428(v33, v34);\n      }\n      else if ( *(_BYTE *)(v26 + 52) )\n      {\n        v25 = sub_4054A6((const char *)v33, (const char *)v34);\n      }\n      else if ( *(_BYTE *)(v26 + 53) )\n      {\n        v25 = sub_405378(v33, v34);\n      }\n      else if ( *(_BYTE *)(v26 + 54) )\n      {\n        v10 = sub_4055B7(v33, 0LL);\n        v25 = v10 - sub_4055B7(v34, 0LL);\n      }\n      else if ( *(_BYTE *)(v26 + 51) )\n      {\n        v25 = sub_4058C1((char *)v33, v35, (char *)v34, v36);\n      }\n      else if ( *(_BYTE *)(v26 + 56) )\n      {\n        v25 = sub_40EAFE(v33, v34);\n      }\n      else if ( v35 )\n      {\n        if ( v36 )\n          v25 = sub_415281(v33, v35 + 1, v34, v36 + 1);\n        else\n          v25 = 1;\n      }\n      else\n      {\n        v25 = -(v36 != 0);\n      }\n      if ( v41 || v40 )\n      {\n        free(ptr);\n      }\n      else\n      {\n        v33[v35] = v23;\n        v34[v36] = v24;\n      }\n      goto LABEL_102;\n    }\n    if ( v41 )\n    {\n      if ( v40 )\n      {\n        while ( 1 )\n        {\n          while ( s1 < v30 && *(_BYTE *)((unsigned __int8)sub_402B35(*s1) + v41) )\n            ++s1;\n          while ( (unsigned __int64)s2 < v32 && *(_BYTE *)((unsigned __int8)sub_402B35(*s2) + v41) )\n            ++s2;\n          if ( s1 >= v30 || (unsigned __int64)s2 >= v32 )\n            break;\n          v11 = sub_402B35(*s1);\n          v12 = (unsigned __int8)sub_402B35(*(_BYTE *)(v11 + v40));\n          v13 = sub_402B35(*s2);\n          v25 = v12 - (unsigned __int8)sub_402B35(*(_BYTE *)(v13 + v40));\n          if ( v25 )\n            goto LABEL_120;\n          ++s1;\n          ++s2;\n        }\n        v25 = (s1 < v30) - ((unsigned __int64)s2 < v32);\n      }\n      else\n      {\n        while ( 1 )\n        {\n          while ( s1 < v30 && *(_BYTE *)((unsigned __int8)sub_402B35(*s1) + v41) )\n            ++s1;\n          while ( (unsigned __int64)s2 < v32 && *(_BYTE *)((unsigned __int8)sub_402B35(*s2) + v41) )\n            ++s2;\n          if ( s1 >= v30 || (unsigned __int64)s2 >= v32 )\n            break;\n          v14 = (unsigned __int8)sub_402B35(*s1);\n          v25 = v14 - (unsigned __int8)sub_402B35(*s2);\n          if ( v25 )\n            goto LABEL_120;\n          ++s1;\n          ++s2;\n        }\n        v25 = (s1 < v30) - ((unsigned __int64)s2 < v32);\n      }\n      goto LABEL_102;\n    }\n    if ( !v42 )\n    {\n      v25 = -(n != 0);\n      goto LABEL_102;\n    }\n    if ( !n )\n      break;\n    if ( v40 )\n    {\n      while ( s1 < v30 && (unsigned __int64)s2 < v32 )\n      {\n        v15 = s1++;\n        v16 = sub_402B35(*v15);\n        v17 = (unsigned __int8)sub_402B35(*(_BYTE *)(v16 + v40));\n        v18 = s2++;\n        v19 = sub_402B35(*v18);\n        v25 = v17 - (unsigned __int8)sub_402B35(*(_BYTE *)(v19 + v40));\n        if ( v25 )\n          goto LABEL_120;\n      }\n    }\n    else\n    {\n      v20 = v30 - s1;\n      if ( n <= v42 )\n        v20 = n;\n      v25 = memcmp(s1, s2, v20);\n      if ( v25 )\n        goto LABEL_120;\n    }\n    if ( v42 < n )\n      v21 = -1;\n    else\n      v21 = v42 != n;\n    v25 = v21;\nLABEL_102:\n    if ( v25 )\n      goto LABEL_120;\n    v26 = *(_QWORD *)(v26 + 64);\n    if ( !v26 )\n      return 0LL;\n    if ( *(_QWORD *)(v26 + 16) == -1LL )\n    {\n      v29 = &a1[1][(_QWORD)*a1 - 1];\n      v31 = &a2[1][(_QWORD)*a2 - 1];\n    }\n    else\n    {\n      v29 = sub_404BF1((__int64)a1, v26);\n      v31 = sub_404BF1((__int64)a2, v26);\n    }\n    if ( *(_QWORD *)v26 == -1LL )\n    {\n      s1 = *a1;\n      s2 = *a2;\n      if ( *(_BYTE *)(v26 + 48) )\n      {\n        while ( s1 < v29 && byte_61D5E0[(unsigned __int8)sub_402B35(*s1)] )\n          ++s1;\n        while ( s2 < v31 && byte_61D5E0[(unsigned __int8)sub_402B35(*s2)] )\n          ++s2;\n      }\n    }\n    else\n    {\n      s1 = sub_404A5B((__int64)a1, (__int64 *)v26);\n      s2 = sub_404A5B((__int64)a2, (__int64 *)v26);\n    }\n  }\n  v25 = 1;\nLABEL_120:\n  if ( *(_BYTE *)(v26 + 55) )\n    result = -v25;\n  else\n    result = v25;\n  return result;\n}\n"], [4225737, "sub_407AC9", "__int64 __fastcall sub_407AC9(unsigned __int8 **a1, unsigned __int8 **a2)\n{\n  __int64 result; // rax\n  size_t v3; // rax\n  int v4; // eax\n  unsigned int v5; // [rsp+1Ch] [rbp-14h]\n  unsigned int v6; // [rsp+1Ch] [rbp-14h]\n  unsigned __int64 v7; // [rsp+20h] [rbp-10h]\n  size_t n; // [rsp+28h] [rbp-8h]\n\n  if ( qword_61DA08 )\n  {\n    v5 = sub_406DCF(a1, a2);\n    if ( v5 || byte_61DA02 || byte_61DA01 )\n      return v5;\n  }\n  v7 = (unsigned __int64)(a1[1] - 1);\n  n = (size_t)(a2[1] - 1);\n  if ( a1[1] == (unsigned __int8 *)1 )\n  {\n    v6 = -(a2[1] != (unsigned __int8 *)1);\n  }\n  else if ( a2[1] == (unsigned __int8 *)1 )\n  {\n    v6 = 1;\n  }\n  else if ( byte_61D5C8 )\n  {\n    v6 = sub_415281(*a1, a1[1], *a2, a2[1]);\n  }\n  else\n  {\n    v3 = (size_t)(a1[1] - 1);\n    if ( n <= v7 )\n      v3 = (size_t)(a2[1] - 1);\n    v6 = memcmp(*a1, *a2, v3);\n    if ( !v6 )\n    {\n      if ( v7 < n )\n        v4 = -1;\n      else\n        v4 = v7 != n;\n      v6 = v4;\n    }\n  }\n  if ( byte_61DA00 )\n    result = -v6;\n  else\n    result = v6;\n  return result;\n}\n"], [4226063, "sub_407C0F", "int __fastcall sub_407C0F(void **a1, FILE *a2, char *a3)\n{\n  char *v3; // rax\n  char *v4; // rax\n  int result; // eax\n  char *v6; // rax\n  char v8; // [rsp+2Fh] [rbp-21h]\n  char *v9; // [rsp+30h] [rbp-20h]\n  void *ptr; // [rsp+38h] [rbp-18h]\n  size_t n; // [rsp+40h] [rbp-10h]\n  size_t v12; // [rsp+48h] [rbp-8h]\n\n  ptr = *a1;\n  n = (size_t)a1[1];\n  v12 = (size_t)*a1 + n;\n  if ( a3 || !byte_61DA18 )\n  {\n    *(_BYTE *)(v12 - 1) = byte_61D400;\n    if ( fwrite_unlocked(ptr, 1uLL, n, a2) != n )\n    {\n      v6 = gettext(\"write failed\");\n      sub_402C5C(v6, a3);\n    }\n    result = v12 - 1;\n    *(_BYTE *)(v12 - 1) = 0;\n  }\n  else\n  {\n    v9 = (char *)*a1;\n    while ( (unsigned __int64)v9 < v12 )\n    {\n      v3 = v9++;\n      v8 = *v3;\n      if ( *v3 == 9 )\n      {\n        v8 = 62;\n      }\n      else if ( v9 == (char *)v12 )\n      {\n        v8 = 10;\n      }\n      if ( fputc_unlocked(v8, a2) == -1 )\n      {\n        v4 = gettext(\"write failed\");\n        sub_402C5C(v4, 0LL);\n      }\n    }\n    result = sub_406331((__int64)a1);\n  }\n  return result;\n}\n"], [4226355, "sub_407D33", "__int64 __fastcall sub_407D33(char *a1, char a2)\n{\n  unsigned __int64 v2; // rdx\n  __int64 v3; // r12\n  __int64 v4; // rbx\n  char *v5; // rax\n  char *v6; // rax\n  unsigned __int8 v8; // [rsp+1Eh] [rbp-D2h]\n  _BYTE v9[9]; // [rsp+1Fh] [rbp-D1h]\n  __int64 v10; // [rsp+28h] [rbp-C8h]\n  unsigned __int64 v11; // [rsp+30h] [rbp-C0h]\n  FILE *v12; // [rsp+38h] [rbp-B8h]\n  __int64 v13; // [rsp+40h] [rbp-B0h]\n  unsigned __int64 v14; // [rsp+48h] [rbp-A8h]\n  __int64 v15; // [rsp+58h] [rbp-98h]\n  void *ptr[4]; // [rsp+60h] [rbp-90h] BYREF\n  void *v17[2]; // [rsp+80h] [rbp-70h] BYREF\n  __int64 v18; // [rsp+90h] [rbp-60h]\n  char v19[24]; // [rsp+C0h] [rbp-30h] BYREF\n  unsigned __int64 v20; // [rsp+D8h] [rbp-18h]\n\n  v20 = __readfsqword(0x28u);\n  v12 = sub_4035C5(a1, \"r\");\n  v9[8] = 0;\n  v10 = 0LL;\n  v13 = qword_61DA08;\n  *(_QWORD *)v9 = byte_61DA02 == 0;\n  v9[0] = byte_61DA02 == 0;\n  v8 = 1;\n  v2 = qword_61D9E0;\n  if ( qword_61D9E0 < (unsigned __int64)qword_61D4E0 )\n    v2 = qword_61D4E0;\n  sub_404989((__int64)v17, 32LL, v2);\n  ptr[0] = 0LL;\n  while ( (unsigned __int8)sub_404DA9(v17, v12, a1) )\n  {\n    v11 = sub_404A3F(v17);\n    v14 = -32 * v18 + v11;\n    if ( *(_QWORD *)&v9[1] && v9[0] <= (int)sub_407AC9((unsigned __int8 **)ptr, (unsigned __int8 **)(v11 - 32)) )\n    {\nLABEL_6:\n      if ( a2 == 99 )\n      {\n        v15 = ((__int64)(sub_404A3F(v17) - (v11 - 32)) >> 5) + v10;\n        v3 = sub_410B71(v15, v19);\n        v4 = qword_61DBB0;\n        v5 = gettext(\"%s: %s:%s: disorder: \");\n        fprintf(stderr, v5, v4, a1, v3);\n        v6 = gettext(\"standard error\");\n        sub_407C0F((void **)(v11 - 32), stderr, v6);\n      }\n      v8 = 0;\n      break;\n    }\n    while ( 1 )\n    {\n      v11 -= 32LL;\n      if ( v11 <= v14 )\n        break;\n      if ( v9[0] <= (int)sub_407AC9((unsigned __int8 **)v11, (unsigned __int8 **)(v11 - 32)) )\n        goto LABEL_6;\n    }\n    v10 += v18;\n    if ( *(_QWORD *)(v11 + 8) > *(_QWORD *)&v9[1] )\n    {\n      while ( 1 )\n      {\n        *(_QWORD *)&v9[1] *= 2LL;\n        if ( !*(_QWORD *)&v9[1] )\n          break;\n        if ( *(_QWORD *)(v11 + 8) <= *(_QWORD *)&v9[1] )\n          goto LABEL_16;\n      }\n      *(_QWORD *)&v9[1] = *(_QWORD *)(v11 + 8);\nLABEL_16:\n      free(ptr[0]);\n      ptr[0] = (void *)sub_414F92(*(_QWORD *)&v9[1]);\n    }\n    memcpy(ptr[0], *(const void **)v11, *(_QWORD *)(v11 + 8));\n    ptr[1] = *(void **)(v11 + 8);\n    if ( v13 )\n    {\n      ptr[2] = (char *)ptr[0] + *(_QWORD *)(v11 + 16) - *(_QWORD *)v11;\n      ptr[3] = (char *)ptr[0] + *(_QWORD *)(v11 + 24) - *(_QWORD *)v11;\n    }\n  }\n  sub_403612(v12, a1);\n  free(v17[0]);\n  free(ptr[0]);\n  return v8;\n}\n"], [4227358, "sub_40811E", "__int64 __fastcall sub_40811E(__int64 a1, unsigned __int64 a2, __int64 *a3)\n{\n  FILE *v3; // rax\n  int i; // [rsp+24h] [rbp-1Ch]\n  __int64 v7; // [rsp+28h] [rbp-18h]\n\n  *a3 = sub_414E49(a2, 8LL);\n  v7 = *a3;\n  for ( i = 0; i < a2; ++i )\n  {\n    v3 = *(_QWORD *)(16LL * i + a1 + 8) && *(_BYTE *)(*(_QWORD *)(16LL * i + a1 + 8) + 12LL) ? sub_403A7E(*(_QWORD *)(16LL * i + a1 + 8)) : sub_40352E(*(const char **)(16LL * i + a1), \"r\");\n    *(_QWORD *)(8LL * i + v7) = v3;\n    if ( !*(_QWORD *)(8LL * i + v7) )\n      break;\n  }\n  return i;\n}\n"], [4227641, "sub_408239", "void __fastcall sub_408239(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, FILE *a4, char *a5, FILE **a6)\n{\n  __int64 v6; // rdx\n  _QWORD *v7; // rcx\n  _QWORD *v8; // rax\n  __int64 v9; // rdx\n  _QWORD *v10; // rcx\n  _QWORD *v11; // rax\n  __int64 v12; // rdx\n  _QWORD *v13; // rax\n  _QWORD *v14; // rdx\n  unsigned __int64 v18; // [rsp+18h] [rbp-D8h]\n  int v20; // [rsp+3Ch] [rbp-B4h]\n  void **v21; // [rsp+40h] [rbp-B0h]\n  unsigned __int64 v22; // [rsp+48h] [rbp-A8h]\n  unsigned __int64 v23; // [rsp+50h] [rbp-A0h]\n  unsigned __int64 j; // [rsp+50h] [rbp-A0h]\n  unsigned __int64 k; // [rsp+50h] [rbp-A0h]\n  unsigned __int64 l; // [rsp+50h] [rbp-A0h]\n  unsigned __int64 m; // [rsp+50h] [rbp-A0h]\n  unsigned __int64 ii; // [rsp+50h] [rbp-A0h]\n  unsigned __int64 i; // [rsp+58h] [rbp-98h]\n  unsigned __int64 jj; // [rsp+58h] [rbp-98h]\n  unsigned __int64 v31; // [rsp+60h] [rbp-90h]\n  unsigned __int64 v32; // [rsp+68h] [rbp-88h]\n  __int64 v33; // [rsp+70h] [rbp-80h]\n  _QWORD *v34; // [rsp+78h] [rbp-78h]\n  _QWORD *v35; // [rsp+80h] [rbp-70h]\n  _QWORD *v36; // [rsp+88h] [rbp-68h]\n  unsigned __int64 *v37; // [rsp+90h] [rbp-60h]\n  __int64 v38; // [rsp+98h] [rbp-58h]\n  __int64 v39; // [rsp+A0h] [rbp-50h]\n  unsigned __int64 v40; // [rsp+A8h] [rbp-48h]\n  unsigned __int64 v41; // [rsp+B0h] [rbp-40h]\n  __int64 v42; // [rsp+B8h] [rbp-38h]\n  unsigned __int64 v43; // [rsp+C0h] [rbp-30h]\n  unsigned __int64 v44; // [rsp+C8h] [rbp-28h]\n  void *ptr; // [rsp+D0h] [rbp-20h] BYREF\n  size_t n; // [rsp+D8h] [rbp-18h]\n  __int64 v47; // [rsp+E0h] [rbp-10h]\n  __int64 v48; // [rsp+E8h] [rbp-8h]\n\n  v18 = a3;\n  v34 = (_QWORD *)sub_414E49(a3, 56LL);\n  v21 = 0LL;\n  v22 = 0LL;\n  v35 = (_QWORD *)sub_414E49(v18, 8LL);\n  v36 = (_QWORD *)sub_414E49(v18, 8LL);\n  v37 = (unsigned __int64 *)sub_414E49(v18, 8LL);\n  v38 = qword_61DA08;\n  ptr = 0LL;\n  v23 = 0LL;\n  while ( v23 < v18 )\n  {\n    v6 = qword_61D9E0 / v18;\n    if ( qword_61D9E0 / v18 < qword_61D4E0 )\n      v6 = qword_61D4E0;\n    sub_404989((__int64)&v34[7 * v23], 32LL, v6);\n    if ( (unsigned __int8)sub_404DA9(&v34[7 * v23], a6[v23], *(char **)(16 * v23 + a1)) )\n    {\n      v39 = sub_404A3F(&v34[7 * v23]);\n      v35[v23] = v39 - 32;\n      v36[v23] = -32LL * v34[7 * v23 + 2] + v39;\n      ++v23;\n    }\n    else\n    {\n      sub_403612(a6[v23], *(char **)(16 * v23 + a1));\n      if ( v23 < a2 )\n      {\n        --a2;\n        sub_403CC7(*(char **)(16 * v23 + a1));\n      }\n      free((void *)v34[7 * v23]);\n      --v18;\n      for ( i = v23; i < v18; ++i )\n      {\n        v7 = (_QWORD *)(16 * i + a1);\n        v8 = (_QWORD *)(16 * (i + 1) + a1);\n        v9 = v8[1];\n        *v7 = *v8;\n        v7[1] = v9;\n        a6[i] = a6[i + 1];\n      }\n    }\n  }\n  for ( j = 0LL; j < v18; ++j )\n    v37[j] = j;\n  for ( k = 1LL; k < v18; ++k )\n  {\n    if ( (int)sub_407AC9((unsigned __int8 **)v35[v37[k - 1]], (unsigned __int8 **)v35[v37[k]]) > 0 )\n    {\n      v40 = v37[k - 1];\n      v37[k - 1] = v37[k];\n      v37[k] = v40;\n      k = 0LL;\n    }\n  }\n  while ( v18 )\n  {\n    v41 = v35[*v37];\n    if ( byte_61DA02 )\n    {\n      if ( v21 && (unsigned int)sub_407AC9((unsigned __int8 **)v21, (unsigned __int8 **)v41) )\n      {\n        v21 = 0LL;\n        sub_407C0F(&ptr, a4, a5);\n      }\n      if ( !v21 )\n      {\n        v21 = &ptr;\n        if ( *(_QWORD *)(v41 + 8) > v22 )\n        {\n          while ( v22 )\n          {\n            v22 *= 2LL;\n            if ( v22 >= *(_QWORD *)(v41 + 8) )\n              goto LABEL_30;\n          }\n          v22 = *(_QWORD *)(v41 + 8);\nLABEL_30:\n          free(ptr);\n          ptr = (void *)sub_414F92(v22);\n        }\n        n = *(_QWORD *)(v41 + 8);\n        memcpy(ptr, *(const void **)v41, n);\n        if ( v38 )\n        {\n          v47 = (__int64)ptr + *(_QWORD *)(v41 + 16) - *(_QWORD *)v41;\n          v48 = (__int64)ptr + *(_QWORD *)(v41 + 24) - *(_QWORD *)v41;\n        }\n      }\n    }\n    else\n    {\n      sub_407C0F((void **)v41, a4, a5);\n    }\n    if ( v36[*v37] >= v41 )\n    {\n      if ( (unsigned __int8)sub_404DA9(&v34[7 * *v37], a6[*v37], *(char **)(16 * *v37 + a1)) )\n      {\n        v42 = sub_404A3F(&v34[7 * *v37]);\n        v35[*v37] = v42 - 32;\n        v36[*v37] = -32LL * v34[7 * *v37 + 2] + v42;\n        goto LABEL_52;\n      }\n      for ( l = 1LL; l < v18; ++l )\n      {\n        if ( v37[l] > *v37 )\n          --v37[l];\n      }\n      --v18;\n      sub_403612(a6[*v37], *(char **)(16 * *v37 + a1));\n      if ( *v37 < a2 )\n      {\n        --a2;\n        sub_403CC7(*(char **)(16 * *v37 + a1));\n      }\n      free((void *)v34[7 * *v37]);\n      for ( m = *v37; m < v18; ++m )\n      {\n        a6[m] = a6[m + 1];\n        v10 = (_QWORD *)(16 * m + a1);\n        v11 = (_QWORD *)(16 * (m + 1) + a1);\n        v12 = v11[1];\n        *v10 = *v11;\n        v10[1] = v12;\n        v13 = &v34[7 * m];\n        v14 = &v34[7 * m + 7];\n        *v13 = *v14;\n        v13[1] = v14[1];\n        v13[2] = v14[2];\n        v13[3] = v14[3];\n        v13[4] = v14[4];\n        v13[5] = v14[5];\n        v13[6] = v14[6];\n        v35[m] = v35[m + 1];\n        v36[m] = v36[m + 1];\n      }\n      for ( ii = 0LL; ii < v18; ++ii )\n        v37[ii] = v37[ii + 1];\n    }\n    else\n    {\n      v35[*v37] = v41 - 32;\nLABEL_52:\n      v31 = 1LL;\n      v32 = v18;\n      v33 = 1LL;\n      v43 = *v37;\n      while ( v31 < v32 )\n      {\n        v20 = sub_407AC9((unsigned __int8 **)v35[v43], (unsigned __int8 **)v35[v37[v33]]);\n        if ( v20 >= 0 && (v20 || v37[v33] <= v43) )\n          v31 = v33 + 1;\n        else\n          v32 = v33;\n        v33 = (v31 + v32) >> 1;\n      }\n      v44 = v31 - 1;\n      for ( jj = 0LL; jj < v44; ++jj )\n        v37[jj] = v37[jj + 1];\n      v37[v44] = v43;\n    }\n  }\n  if ( byte_61DA02 && v21 )\n  {\n    sub_407C0F(&ptr, a4, a5);\n    free(ptr);\n  }\n  sub_403612(a4, a5);\n  free(a6);\n  free(v34);\n  free(v37);\n  free(v36);\n  free(v35);\n}\n"], [4230928, "sub_408F10", "unsigned __int64 __fastcall sub_408F10(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, FILE *a4, char *a5)\n{\n  char *v5; // rbx\n  char *v6; // rax\n  FILE **v11; // [rsp+30h] [rbp-20h] BYREF\n  unsigned __int64 v12; // [rsp+38h] [rbp-18h]\n\n  v12 = sub_40811E(a1, a3, (__int64 *)&v11);\n  if ( v12 < a3 && v12 <= 1 )\n  {\n    v5 = *(char **)(16 * v12 + a1);\n    v6 = gettext(\"open failed\");\n    sub_402C5C(v6, v5);\n  }\n  sub_408239(a1, a2, v12, a4, a5, v11);\n  return v12;\n}\n"], [4231092, "sub_408FB4", "unsigned __int8 **__fastcall sub_408FB4(unsigned __int8 **a1, unsigned __int64 a2, unsigned __int8 **a3)\n{\n  unsigned __int8 **result; // rax\n  unsigned __int8 **v5; // [rsp+18h] [rbp-28h]\n  unsigned __int64 v6; // [rsp+28h] [rbp-18h]\n  unsigned __int64 v7; // [rsp+30h] [rbp-10h]\n  unsigned __int8 **v8; // [rsp+38h] [rbp-8h]\n\n  v5 = a1;\n  v6 = a2 >> 1;\n  v7 = a2 - (a2 >> 1);\n  v8 = &a1[-4 * (a2 >> 1)];\n  do\n  {\n    while ( (int)sub_407AC9(a3 - 4, v8 - 4) <= 0 )\n    {\n      v5 -= 4;\n      a3 -= 4;\n      result = v5;\n      *v5 = *a3;\n      v5[1] = a3[1];\n      v5[2] = a3[2];\n      v5[3] = a3[3];\n      if ( !--v6 )\n        return result;\n    }\n    v5 -= 4;\n    v8 -= 4;\n    *v5 = *v8;\n    v5[1] = v8[1];\n    v5[2] = v8[2];\n    v5[3] = v8[3];\n    --v7;\n  }\n  while ( v7 );\n  do\n  {\n    v5 -= 4;\n    a3 -= 4;\n    result = v5;\n    *v5 = *a3;\n    v5[1] = a3[1];\n    v5[2] = a3[2];\n    v5[3] = a3[3];\n    --v6;\n  }\n  while ( v6 );\n  return result;\n}\n"], [4231388, "sub_4090DC", "unsigned __int8 **__fastcall sub_4090DC(unsigned __int8 **a1, unsigned __int64 a2, unsigned __int8 **a3, unsigned __int8 a4)\n{\n  unsigned __int8 **result; // rax\n  unsigned __int8 **v5; // rax\n  unsigned __int8 **v6; // rdx\n  __int64 v7; // rcx\n  unsigned __int8 **v8; // rdx\n  unsigned __int8 **v9; // rdx\n  unsigned __int8 **v10; // rdx\n  __int64 v11; // rax\n  unsigned __int8 **v12; // rdx\n  int v15; // [rsp+2Ch] [rbp-34h]\n  unsigned __int64 v16; // [rsp+40h] [rbp-20h]\n\n  if ( a2 == 2 )\n  {\n    result = (unsigned __int8 **)((int)sub_407AC9(a1 - 4, a1 - 8) > 0);\n    v15 = (int)result;\n    if ( a4 )\n    {\n      v5 = a3 - 4;\n      v6 = &a1[4 * ~v15];\n      *v5 = *v6;\n      v5[1] = v6[1];\n      v5[2] = v6[2];\n      v5[3] = v6[3];\n      result = a3 - 8;\n      v7 = 4LL * (v15 - 2);\n      *result = a1[v7];\n      result[1] = a1[v7 + 1];\n      result[2] = a1[v7 + 2];\n      result[3] = a1[v7 + 3];\n    }\n    else if ( (_DWORD)result )\n    {\n      v8 = a3 - 4;\n      *v8 = *(a1 - 4);\n      v8[1] = *(a1 - 3);\n      v8[2] = *(a1 - 2);\n      v8[3] = *(a1 - 1);\n      v9 = a1 - 4;\n      *v9 = *(a1 - 8);\n      v9[1] = *(a1 - 7);\n      v9[2] = *(a1 - 6);\n      v9[3] = *(a1 - 5);\n      v10 = a1 - 8;\n      *v10 = *(a3 - 4);\n      v10[1] = *(a3 - 3);\n      v10[2] = *(a3 - 2);\n      result = (unsigned __int8 **)*(a3 - 1);\n      v10[3] = (unsigned __int8 *)result;\n    }\n  }\n  else\n  {\n    v16 = a2 >> 1;\n    if ( a4 )\n      v11 = 0x1FFFFFFFFFFFFFFCLL * v16;\n    else\n      v11 = 0LL;\n    sub_4090DC(&a1[-4 * (a2 >> 1)], a2 - (a2 >> 1), &a3[v11], a4);\n    if ( v16 <= 1 )\n    {\n      if ( a4 != 1 )\n      {\n        v12 = a3 - 4;\n        *v12 = *(a1 - 4);\n        v12[1] = *(a1 - 3);\n        v12[2] = *(a1 - 2);\n        v12[3] = *(a1 - 1);\n      }\n    }\n    else\n    {\n      sub_4090DC(a1, v16, a3, a4 == 0);\n    }\n    if ( a4 )\n      result = sub_408FB4(a3, a2, a1);\n    else\n      result = sub_408FB4(a1, a2, a3);\n  }\n  return result;\n}\n"], [4232031, "sub_40935F", "__int64 __fastcall sub_40935F(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v5; // [rsp+28h] [rbp-8h]\n\n  v5 = sub_414F92(a1 << 8);\n  *(_QWORD *)(v5 + 24) = 0LL;\n  *(_QWORD *)(v5 + 16) = *(_QWORD *)(v5 + 24);\n  *(_QWORD *)(v5 + 8) = *(_QWORD *)(v5 + 16);\n  *(_QWORD *)v5 = *(_QWORD *)(v5 + 8);\n  *(_QWORD *)(v5 + 32) = 0LL;\n  *(_QWORD *)(v5 + 48) = a2;\n  *(_QWORD *)(v5 + 40) = *(_QWORD *)(v5 + 48);\n  *(_QWORD *)(v5 + 56) = 0LL;\n  *(_DWORD *)(v5 + 80) = 0;\n  *(_BYTE *)(v5 + 84) = 0;\n  pthread_mutex_init((pthread_mutex_t *)(v5 + 88), 0LL);\n  sub_409472(v5, v5 + 128, a3, a1, a2, 0LL);\n  return v5;\n}\n"], [4232280, "sub_409458", "void __fastcall sub_409458(void *a1)\n{\n  free(a1);\n}\n"], [4232306, "sub_409472", "__int64 __fastcall sub_409472(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, char a6)\n{\n  unsigned __int64 v6; // rax\n  __int64 v7; // rax\n  __int64 v8; // rax\n  __int64 v12; // [rsp+20h] [rbp-60h]\n  unsigned __int64 v13; // [rsp+40h] [rbp-40h]\n  unsigned __int64 v14; // [rsp+48h] [rbp-38h]\n  __int64 v15; // [rsp+50h] [rbp-30h]\n  __int64 v16; // [rsp+58h] [rbp-28h]\n\n  if ( a6 )\n    v6 = *(_QWORD *)(a1 + 40);\n  else\n    v6 = *(_QWORD *)(a1 + 48);\n  v13 = v6 >> 1;\n  v14 = v6 - (v6 >> 1);\n  v15 = -32 * a5 + a3;\n  v16 = -32LL * (v6 >> 1) + v15;\n  if ( a6 )\n    v7 = a1 + 16;\n  else\n    v7 = a1 + 24;\n  v12 = a2 + 128;\n  *(_QWORD *)(a2 + 16) = v15;\n  *(_QWORD *)a2 = *(_QWORD *)(a2 + 16);\n  *(_QWORD *)(a2 + 24) = v16;\n  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a2 + 24);\n  *(_QWORD *)(a2 + 32) = v7;\n  *(_QWORD *)(a2 + 40) = v13;\n  *(_QWORD *)(a2 + 48) = v14;\n  *(_QWORD *)(a2 + 56) = a1;\n  *(_DWORD *)(a2 + 80) = *(_DWORD *)(a1 + 80) + 1;\n  *(_BYTE *)(a2 + 84) = 0;\n  pthread_mutex_init((pthread_mutex_t *)(a2 + 88), 0LL);\n  if ( a4 <= 1 )\n  {\n    *(_QWORD *)(a2 + 64) = 0LL;\n    *(_QWORD *)(a2 + 72) = 0LL;\n  }\n  else\n  {\n    *(_QWORD *)(a2 + 64) = v12;\n    v8 = sub_409472(a2, v12, v15, a4 >> 1, a5, 1LL);\n    *(_QWORD *)(a2 + 72) = v8;\n    v12 = sub_409472(a2, v8, v16, a4 - (a4 >> 1), a5, 0LL);\n  }\n  return v12;\n}\n"], [4232821, "sub_409675", "_BOOL8 __fastcall sub_409675(__int64 a1, __int64 a2)\n{\n  _BOOL8 result; // rax\n\n  if ( *(_DWORD *)(a1 + 80) == *(_DWORD *)(a2 + 80) )\n    result = *(_QWORD *)(a1 + 40) + *(_QWORD *)(a1 + 48) < *(_QWORD *)(a2 + 40) + *(_QWORD *)(a2 + 48);\n  else\n    result = *(_DWORD *)(a1 + 80) < *(_DWORD *)(a2 + 80);\n  return result;\n}\n"], [4232941, "sub_4096ED", "int __fastcall sub_4096ED(__int64 a1)\n{\n  return pthread_mutex_lock((pthread_mutex_t *)(a1 + 88));\n}\n"], [4232971, "sub_40970B", "int __fastcall sub_40970B(__int64 a1)\n{\n  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 88));\n}\n"], [4233001, "sub_409729", "int __fastcall sub_409729(__int64 a1)\n{\n  sub_4107BA(*(_QWORD *)a1);\n  pthread_cond_destroy((pthread_cond_t *)(a1 + 48));\n  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));\n}\n"], [4233062, "sub_409766", "int __fastcall sub_409766(__int64 a1, __int64 a2)\n{\n  *(_QWORD *)a1 = sub_410719(sub_409675, 2 * a2);\n  pthread_mutex_init((pthread_mutex_t *)(a1 + 8), 0LL);\n  return pthread_cond_init((pthread_cond_t *)(a1 + 48), 0LL);\n}\n"], [4233149, "sub_4097BD", "int __fastcall sub_4097BD(__int64 a1, __int64 a2)\n{\n  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));\n  sub_4107E3(*(_QWORD *)a1, a2);\n  *(_BYTE *)(a2 + 84) = 1;\n  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));\n  return pthread_cond_signal((pthread_cond_t *)(a1 + 48));\n}\n"], [4233245, "sub_40981D", "__int64 __fastcall sub_40981D(__int64 a1)\n{\n  __int64 v2; // [rsp+18h] [rbp-8h]\n\n  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));\n  while ( 1 )\n  {\n    v2 = sub_41088C(*(_QWORD *)a1);\n    if ( v2 )\n      break;\n    pthread_cond_wait((pthread_cond_t *)(a1 + 48), (pthread_mutex_t *)(a1 + 8));\n  }\n  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));\n  sub_4096ED(v2);\n  *(_BYTE *)(v2 + 84) = 0;\n  return v2;\n}\n"], [4233370, "sub_40989A", "int __fastcall sub_40989A(__int64 a1, FILE *a2, char *a3)\n{\n  int result; // eax\n\n  if ( !byte_61DA02 )\n    goto LABEL_5;\n  if ( !qword_61DB80 || (result = sub_407AC9((unsigned __int8 **)a1, (unsigned __int8 **)&qword_61DB80)) != 0 )\n  {\n    qword_61DB80 = *(_QWORD *)a1;\n    qword_61DB88 = *(_QWORD *)(a1 + 8);\n    qword_61DB90 = *(_QWORD *)(a1 + 16);\n    qword_61DB98 = *(_QWORD *)(a1 + 24);\nLABEL_5:\n    result = sub_407C0F((void **)a1, a2, a3);\n  }\n  return result;\n}\n"], [4233508, "sub_409924", "__int64 *__fastcall sub_409924(__int64 *a1, unsigned __int64 a2, FILE *a3, char *a4)\n{\n  _QWORD *v4; // rdx\n  _QWORD *v5; // rax\n  _QWORD *v7; // rdx\n  _QWORD *v9; // rdx\n  __int64 *result; // rax\n  __int64 v17; // [rsp+20h] [rbp-30h]\n  _QWORD *v18; // [rsp+28h] [rbp-28h]\n  __int64 v19; // [rsp+30h] [rbp-20h]\n  _QWORD *v20; // [rsp+38h] [rbp-18h]\n  __int64 v21; // [rsp+48h] [rbp-8h]\n\n  v19 = *a1;\n  v20 = (_QWORD *)a1[1];\n  v17 = (a2 >> (2 * (*((_BYTE *)a1 + 80) + 1))) + 1;\n  if ( *((_DWORD *)a1 + 20) <= 1u )\n  {\n    while ( *a1 != a1[2] )\n    {\n      if ( a1[1] == a1[3] )\n        break;\n      if ( !v17-- )\n        break;\n      if ( (int)sub_407AC9((unsigned __int8 **)(*a1 - 32), (unsigned __int8 **)(a1[1] - 32)) > 0 )\n      {\n        a1[1] -= 32LL;\n        sub_40989A(a1[1], a3, a4);\n      }\n      else\n      {\n        *a1 -= 32LL;\n        sub_40989A(*a1, a3, a4);\n      }\n    }\n    if ( a1[6] == ((__int64)v20 - a1[1]) >> 5 )\n    {\n      while ( *a1 != a1[2] )\n      {\n        if ( !v17-- )\n          break;\n        *a1 -= 32LL;\n        sub_40989A(*a1, a3, a4);\n      }\n    }\n    else if ( a1[5] == (v19 - *a1) >> 5 )\n    {\n      while ( a1[1] != a1[3] )\n      {\n        if ( !v17-- )\n          break;\n        a1[1] -= 32LL;\n        sub_40989A(a1[1], a3, a4);\n      }\n    }\n  }\n  else\n  {\n    v18 = *(_QWORD **)a1[4];\n    while ( *a1 != a1[2] )\n    {\n      if ( a1[1] == a1[3] )\n        break;\n      if ( !v17-- )\n        break;\n      v18 -= 4;\n      if ( (int)sub_407AC9((unsigned __int8 **)(*a1 - 32), (unsigned __int8 **)(a1[1] - 32)) > 0 )\n      {\n        a1[1] -= 32LL;\n        v4 = (_QWORD *)a1[1];\n        v5 = v18;\n        *v18 = *v4;\n      }\n      else\n      {\n        *a1 -= 32LL;\n        v4 = (_QWORD *)*a1;\n        v5 = v18;\n        *v18 = *(_QWORD *)*a1;\n      }\n      v5[1] = v4[1];\n      v5[2] = v4[2];\n      v5[3] = v4[3];\n    }\n    if ( a1[6] == ((__int64)v20 - a1[1]) >> 5 )\n    {\n      while ( *a1 != a1[2] )\n      {\n        if ( !v17-- )\n          break;\n        v18 -= 4;\n        *a1 -= 32LL;\n        v7 = (_QWORD *)*a1;\n        *v18 = *(_QWORD *)*a1;\n        v18[1] = v7[1];\n        v18[2] = v7[2];\n        v18[3] = v7[3];\n      }\n    }\n    else if ( a1[5] == (v19 - *a1) >> 5 )\n    {\n      while ( a1[1] != a1[3] )\n      {\n        if ( !v17-- )\n          break;\n        v18 -= 4;\n        a1[1] -= 32LL;\n        v9 = (_QWORD *)a1[1];\n        *v18 = *v9;\n        v18[1] = v9[1];\n        v18[2] = v9[2];\n        v18[3] = v9[3];\n      }\n    }\n    *(_QWORD *)a1[4] = v18;\n  }\n  v21 = ((__int64)v20 - a1[1]) >> 5;\n  a1[5] -= (v19 - *a1) >> 5;\n  result = a1;\n  a1[6] -= v21;\n  return result;\n}\n"], [4234719, "sub_409DDF", "int __fastcall sub_409DDF(__int64 a1, __int64 a2)\n{\n  int result; // eax\n  bool v3; // al\n  bool v4; // al\n\n  result = *(unsigned __int8 *)(a2 + 84) ^ 1;\n  if ( *(_BYTE *)(a2 + 84) != 1 )\n  {\n    if ( (unsigned __int64)(*(_QWORD *)a2 - *(_QWORD *)(a2 + 16) + 31LL) <= 0x3E )\n    {\n      v4 = (unsigned __int64)(*(_QWORD *)(a2 + 8) - *(_QWORD *)(a2 + 24) + 31LL) > 0x3E && !*(_QWORD *)(a2 + 40);\n      result = v4;\n    }\n    else\n    {\n      v3 = (unsigned __int64)(*(_QWORD *)(a2 + 8) - *(_QWORD *)(a2 + 24) + 31LL) > 0x3E || !*(_QWORD *)(a2 + 48);\n      result = v3;\n    }\n    if ( (_BYTE)result )\n      result = sub_4097BD(a1, a2);\n  }\n  return result;\n}\n"], [4234932, "sub_409EB4", "int __fastcall sub_409EB4(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rax\n\n  if ( *(_DWORD *)(a2 + 80) <= 1u )\n  {\n    v2 = *(_QWORD *)(a2 + 40) + *(_QWORD *)(a2 + 48);\n    if ( !v2 )\n      LODWORD(v2) = sub_4097BD(a1, *(_QWORD *)(a2 + 56));\n  }\n  else\n  {\n    sub_4096ED(*(_QWORD *)(a2 + 56));\n    sub_409DDF(a1, *(_QWORD *)(a2 + 56));\n    LODWORD(v2) = sub_40970B(*(_QWORD *)(a2 + 56));\n  }\n  return v2;\n}\n"], [4235066, "sub_409F3A", "int __fastcall sub_409F3A(__int64 a1, unsigned __int64 a2, FILE *a3, char *a4)\n{\n  __int64 v7; // [rsp+28h] [rbp-8h]\n\n  while ( 1 )\n  {\n    v7 = sub_40981D(a1);\n    if ( !*(_DWORD *)(v7 + 80) )\n      break;\n    sub_409924((__int64 *)v7, a2, a3, a4);\n    sub_409DDF(a1, v7);\n    sub_409EB4(a1, v7);\n    sub_40970B(v7);\n  }\n  sub_40970B(v7);\n  return sub_4097BD(a1, v7);\n}\n"], [4235231, "start_routine", "void *__fastcall start_routine(void *a1)\n{\n  sub_40A051(\n    *(_QWORD *)a1,\n    *((_QWORD *)a1 + 1),\n    *((_QWORD *)a1 + 2),\n    *((_QWORD *)a1 + 3),\n    *((unsigned __int8 *)a1 + 32),\n    *((_QWORD *)a1 + 5),\n    *((_QWORD *)a1 + 6),\n    *((_QWORD *)a1 + 7));\n  return 0LL;\n}\n"], [4235345, "sub_40A051", "int __fastcall sub_40A051(unsigned __int8 **a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6, FILE *a7, char *a8)\n{\n  pthread_t newthread; // [rsp+48h] [rbp-78h] BYREF\n  unsigned __int64 v13; // [rsp+50h] [rbp-70h]\n  unsigned __int64 v14; // [rsp+58h] [rbp-68h]\n  unsigned __int64 v15; // [rsp+60h] [rbp-60h]\n  unsigned __int64 v16; // [rsp+68h] [rbp-58h]\n  unsigned __int64 v17; // [rsp+70h] [rbp-50h]\n  unsigned __int8 **v18; // [rsp+78h] [rbp-48h]\n  __int64 arg[4]; // [rsp+80h] [rbp-40h] BYREF\n  char v20; // [rsp+A0h] [rbp-20h]\n  __int64 v21; // [rsp+A8h] [rbp-18h]\n  FILE *v22; // [rsp+B0h] [rbp-10h]\n  char *v23; // [rsp+B8h] [rbp-8h]\n\n  v13 = *(_QWORD *)(a4 + 40) + *(_QWORD *)(a4 + 48);\n  v14 = a2 >> 1;\n  v15 = a2 - (a2 >> 1);\n  arg[0] = (__int64)a1;\n  arg[1] = a2 >> 1;\n  arg[2] = a3;\n  arg[3] = *(_QWORD *)(a4 + 64);\n  v20 = 1;\n  v21 = a6;\n  v22 = a7;\n  v23 = a8;\n  if ( a2 <= 1 || v13 <= 0x1FFFF || pthread_create(&newthread, 0LL, start_routine, arg) )\n  {\n    v16 = *(_QWORD *)(a4 + 40);\n    v17 = *(_QWORD *)(a4 + 48);\n    v18 = &a1[-4 * a3];\n    if ( v17 > 1 )\n      sub_4090DC(&a1[-4 * v16], v17, &v18[-4 * (v16 >> 1)], 0);\n    if ( v16 > 1 )\n      sub_4090DC(a1, v16, v18, 0);\n    *(_QWORD *)a4 = a1;\n    *(_QWORD *)(a4 + 8) = &a1[-4 * v16];\n    *(_QWORD *)(a4 + 16) = &a1[-4 * v16];\n    *(_QWORD *)(a4 + 24) = (char *)a1 - 32 * v16 - 32 * v17;\n    sub_4097BD(a6, a4);\n    sub_409F3A(a6, a3, a7, a8);\n  }\n  else\n  {\n    sub_40A051(-32 * *(_DWORD *)(a4 + 40) + (_DWORD)a1, v15, a3, *(_QWORD *)(a4 + 72), 0, a6, (__int64)a7, (__int64)a8);\n    pthread_join(newthread, 0LL);\n  }\n  return pthread_mutex_destroy((pthread_mutex_t *)(a4 + 88));\n}\n"], [4236099, "sub_40A343", "char __fastcall sub_40A343(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, char *a4)\n{\n  char result; // al\n  char v5; // al\n  char v8; // [rsp+25h] [rbp-13Bh]\n  char v9; // [rsp+26h] [rbp-13Ah]\n  bool v10; // [rsp+27h] [rbp-139h]\n  FILE *v11; // [rsp+28h] [rbp-138h] BYREF\n  unsigned __int64 i; // [rsp+30h] [rbp-130h]\n  char *v13; // [rsp+38h] [rbp-128h]\n  struct stat stat_buf; // [rsp+40h] [rbp-120h] BYREF\n  struct stat v15; // [rsp+D0h] [rbp-90h] BYREF\n\n  v8 = 0;\n  v13 = 0LL;\n  for ( i = a2; ; ++i )\n  {\n    result = i;\n    if ( i >= a3 )\n      break;\n    v10 = strcmp(*(const char **)(16 * i + a1), \"-\") == 0;\n    if ( a4 && !strcmp(a4, *(const char **)(16 * i + a1)) && !v10 )\n    {\n      v9 = 1;\n      goto LABEL_21;\n    }\n    if ( v8 != 1 )\n    {\n      if ( a4 )\n        result = (unsigned int)sub_417160(a4, &stat_buf) != 0;\n      else\n        result = (unsigned int)sub_417170(1, &stat_buf) != 0;\n      if ( result )\n        return result;\n      v8 = 1;\n    }\n    if ( v10 )\n    {\n      if ( (unsigned int)sub_417170(0, &v15) )\n        goto LABEL_19;\n    }\n    else if ( (unsigned int)sub_417160(*(char **)(16 * i + a1), &v15) )\n    {\n      goto LABEL_19;\n    }\n    if ( v15.st_ino != stat_buf.st_ino || v15.st_dev != stat_buf.st_dev )\n    {\nLABEL_19:\n      v5 = 0;\n      goto LABEL_20;\n    }\n    v5 = 1;\nLABEL_20:\n    v9 = v5 & 1;\nLABEL_21:\n    if ( v9 )\n    {\n      if ( !v13 )\n      {\n        v13 = sub_403A5F(&v11);\n        sub_408F10(16 * i + a1, 0LL, 1uLL, v11, v13 + 13);\n      }\n      *(_QWORD *)(16 * i + a1) = v13 + 13;\n      *(_QWORD *)(a1 + 16 * i + 8) = v13;\n    }\n  }\n  return result;\n}\n"], [4236766, "sub_40A5DE", "void __fastcall sub_40A5DE(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3, char *a4)\n{\n  unsigned __int64 v4; // rax\n  unsigned __int64 v5; // rax\n  unsigned __int64 v6; // rax\n  unsigned __int64 v7; // rax\n  __int64 v8; // rax\n  char *v9; // rax\n  char *v10; // rbx\n  char *v11; // rax\n  unsigned __int64 v12; // rax\n  unsigned __int64 v13; // rax\n  unsigned __int64 v17; // [rsp+10h] [rbp-90h]\n  FILE **v18; // [rsp+20h] [rbp-80h] BYREF\n  FILE *v19; // [rsp+28h] [rbp-78h] BYREF\n  __int64 v20; // [rsp+30h] [rbp-70h]\n  unsigned __int64 v21; // [rsp+38h] [rbp-68h]\n  unsigned __int64 v22; // [rsp+40h] [rbp-60h]\n  char *v23; // [rsp+48h] [rbp-58h]\n  unsigned __int64 v24; // [rsp+50h] [rbp-50h]\n  __int64 v25; // [rsp+58h] [rbp-48h]\n  unsigned __int64 v26; // [rsp+60h] [rbp-40h]\n  unsigned __int64 v27; // [rsp+68h] [rbp-38h]\n  char *v28; // [rsp+70h] [rbp-30h]\n  unsigned __int64 v29; // [rsp+78h] [rbp-28h]\n  FILE *v30; // [rsp+80h] [rbp-20h]\n  char *v31; // [rsp+88h] [rbp-18h]\n\n  while ( (unsigned int)dword_61D4EC < a3 )\n  {\n    v20 = 0LL;\n    v21 = 0LL;\n    while ( (unsigned int)dword_61D4EC <= a3 - v20 )\n    {\n      v23 = sub_403A5F(&v19);\n      v4 = a2;\n      if ( (unsigned int)dword_61D4EC <= a2 )\n        v4 = (unsigned int)dword_61D4EC;\n      v24 = sub_408F10((__int64)&a1[2 * v20], v4, (unsigned int)dword_61D4EC, v19, v23 + 13);\n      v5 = a2;\n      if ( v24 <= a2 )\n        v5 = v24;\n      a2 -= v5;\n      a1[2 * v21] = v23 + 13;\n      a1[2 * v21 + 1] = v23;\n      v20 += v24;\n      ++v21;\n    }\n    v25 = a3 - v20;\n    v26 = (unsigned int)dword_61D4EC - v21 % (unsigned int)dword_61D4EC;\n    if ( v26 < a3 - v20 )\n    {\n      v27 = v25 - v26 + 1;\n      v28 = sub_403A5F(&v19);\n      v6 = a2;\n      if ( v27 <= a2 )\n        v6 = v27;\n      v29 = sub_408F10((__int64)&a1[2 * v20], v6, v27, v19, v28 + 13);\n      v7 = a2;\n      if ( v29 <= a2 )\n        v7 = v29;\n      a2 -= v7;\n      a1[2 * v21] = v28 + 13;\n      v8 = v21++;\n      a1[2 * v8 + 1] = v28;\n      v20 += v29;\n    }\n    memmove(&a1[2 * v21], &a1[2 * v20], 16 * (a3 - v20));\n    a2 += v21;\n    a3 += v21 - v20;\n  }\n  sub_40A343((__int64)a1, a2, a3, a4);\n  while ( 1 )\n  {\n    v22 = sub_40811E((__int64)a1, a3, (__int64 *)&v18);\n    if ( v22 == a3 )\n      break;\n    if ( v22 <= 2 )\n    {\n      v10 = (char *)a1[2 * v22];\n      v11 = gettext(\"open failed\");\n      sub_402C5C(v11, v10);\n    }\n    do\n    {\nLABEL_27:\n      --v22;\n      sub_403612(v18[v22], (char *)a1[2 * v22]);\n      v31 = sub_4038CE(&v19, v22 > 2);\n    }\n    while ( !v31 );\n    v12 = a2;\n    if ( v22 <= a2 )\n      v12 = v22;\n    sub_408239((__int64)a1, v12, v22, v19, v31 + 13, v18);\n    v13 = a2;\n    if ( v22 <= a2 )\n      v13 = v22;\n    v17 = a2 - v13;\n    *a1 = v31 + 13;\n    a1[1] = v31;\n    memmove(a1 + 2, &a1[2 * v22], 16 * (a3 - v22));\n    a2 = v17 + 1;\n    a3 = a3 - v22 + 1;\n  }\n  v30 = sub_40352E(a4, \"w\");\n  if ( !v30 )\n  {\n    if ( *__errno_location() != 24 || v22 <= 2 )\n    {\n      v9 = gettext(\"open failed\");\n      sub_402C5C(v9, a4);\n    }\n    goto LABEL_27;\n  }\n  sub_408239((__int64)a1, a2, a3, v30, a4, v18);\n}\n"], [4238067, "sub_40AAF3", "unsigned __int64 __fastcall sub_40AAF3(char **a1, unsigned __int64 a2, char *a3, unsigned __int64 a4)\n{\n  __int64 v4; // rax\n  char v10; // [rsp+3Fh] [rbp-121h]\n  FILE *v11; // [rsp+40h] [rbp-120h] BYREF\n  FILE *v12; // [rsp+48h] [rbp-118h] BYREF\n  unsigned __int64 v13; // [rsp+50h] [rbp-110h]\n  char *v14; // [rsp+58h] [rbp-108h]\n  __int64 v15; // [rsp+60h] [rbp-100h]\n  unsigned __int64 v16; // [rsp+68h] [rbp-F8h]\n  __int64 v17; // [rsp+70h] [rbp-F0h]\n  __int64 v18; // [rsp+78h] [rbp-E8h]\n  __int64 *v19; // [rsp+80h] [rbp-E0h]\n  char *v20; // [rsp+88h] [rbp-D8h]\n  unsigned __int8 **v21; // [rsp+90h] [rbp-D0h]\n  void *v22; // [rsp+98h] [rbp-C8h]\n  __int64 v23; // [rsp+A0h] [rbp-C0h]\n  void *v24; // [rsp+A8h] [rbp-B8h]\n  void *ptr; // [rsp+B0h] [rbp-B0h] BYREF\n  __int64 v26; // [rsp+B8h] [rbp-A8h]\n  unsigned __int64 v27; // [rsp+C0h] [rbp-A0h]\n  __int64 v28; // [rsp+C8h] [rbp-98h]\n  __int64 v29; // [rsp+D0h] [rbp-90h]\n  char v30; // [rsp+E0h] [rbp-80h]\n  char v31[104]; // [rsp+F0h] [rbp-70h] BYREF\n  unsigned __int64 v32; // [rsp+158h] [rbp-8h]\n\n  v32 = __readfsqword(0x28u);\n  v13 = 0LL;\n  v10 = 0;\n  v28 = 0LL;\n  while ( a2 )\n  {\n    v20 = *a1;\n    v11 = sub_4035C5(v20, \"r\");\n    if ( a4 <= 1 )\n    {\n      v15 = 48LL;\n    }\n    else\n    {\n      v16 = 1LL;\n      v17 = 1LL;\n      while ( v16 < a4 )\n      {\n        v16 *= 2LL;\n        ++v17;\n      }\n      v15 = 32 * v17;\n    }\n    if ( !v28 )\n    {\n      v4 = sub_404722((__int64)&v11, 1uLL, (__int64)a1, a2, v15);\n      sub_404989((__int64)&ptr, v15, v4);\n    }\n    v30 = 0;\n    ++a1;\n    --a2;\n    while ( (unsigned __int8)sub_404DA9(&ptr, v11, v20) )\n    {\n      if ( v30 && a2 && v15 + 1 < v28 - v26 - v15 * v27 )\n      {\n        v29 = v26;\n        break;\n      }\n      v21 = (unsigned __int8 **)sub_404A3F(&ptr);\n      if ( !v30 || a2 || v13 || v29 )\n      {\n        ++v13;\n        v14 = sub_403A5F(&v12) + 13;\n      }\n      else\n      {\n        sub_403612(v11, v20);\n        v12 = sub_4035C5(a3, \"w\");\n        v14 = a3;\n        v10 = 1;\n      }\n      if ( v27 <= 1 )\n      {\n        sub_40989A((__int64)(v21 - 4), v12, v14);\n      }\n      else\n      {\n        sub_409766((__int64)v31, a4);\n        v22 = (void *)sub_40935F(a4, v27, (__int64)v21);\n        v23 = (__int64)v22 + 128;\n        sub_40A051(v21, a4, v27, (__int64)v22 + 128, 1LL, (__int64)v31, v12, v14);\n        sub_409729((__int64)v31);\n        pthread_mutex_destroy((pthread_mutex_t *)(v23 + 88));\n        sub_409458(v22);\n      }\n      sub_403612(v12, v14);\n      if ( v10 )\n        goto LABEL_28;\n    }\n    sub_403612(v11, v20);\n  }\nLABEL_28:\n  free(ptr);\n  if ( v10 != 1 )\n  {\n    v19 = (__int64 *)qword_61DAA0;\n    v24 = (void *)sub_414E49(v13, 16LL);\n    v18 = 0LL;\n    while ( v19 )\n    {\n      *((_QWORD *)v24 + 2 * v18) = (char *)v19 + 13;\n      *((_QWORD *)v24 + 2 * v18 + 1) = v19;\n      v19 = (__int64 *)*v19;\n      ++v18;\n    }\n    sub_40A5DE(v24, v13, v13, a3);\n    free(v24);\n  }\n  sub_40325F();\n  return __readfsqword(0x28u) ^ v32;\n}\n"], [4239304, "sub_40AFC8", "__int64 __fastcall sub_40AFC8(__int64 a1)\n{\n  __int64 result; // rax\n  __int64 *i; // [rsp+10h] [rbp-10h]\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_4150B6(a1, 72LL);\n  for ( i = &qword_61DA08; *i; i = (__int64 *)(*i + 64) )\n    ;\n  *i = v3;\n  result = v3;\n  *(_QWORD *)(v3 + 64) = 0LL;\n  return result;\n}\n"], [4239399, "sub_40B027", "void __fastcall __noreturn sub_40B027(__int64 a1, const char *a2)\n{\n  __int64 v2; // r12\n  char *v3; // rbx\n  char *v4; // rax\n\n  v2 = sub_4112FB(a1);\n  v3 = gettext(a2);\n  v4 = gettext(\"%s: invalid field specification %s\");\n  error(2, 0, v4, v3, v2);\n  abort();\n}\n"], [4239492, "sub_40B084", "void __fastcall __noreturn sub_40B084(__int64 a1)\n{\n  char *v1; // rax\n\n  v1 = gettext(\"options `-%s' are incompatible\");\n  error(2, 0, v1, a1);\n  abort();\n}\n"], [4239549, "sub_40B0BD", "unsigned __int64 sub_40B0BD()\n{\n  __int64 i; // [rsp+8h] [rbp-38h]\n  char v2[40]; // [rsp+10h] [rbp-30h] BYREF\n  unsigned __int64 v3; // [rsp+38h] [rbp-8h]\n\n  v3 = __readfsqword(0x28u);\n  for ( i = qword_61DA08; i; i = *(_QWORD *)(i + 64) )\n  {\n    if ( *(unsigned __int8 *)(i + 53)\n       + *(unsigned __int8 *)(i + 52)\n       + *(unsigned __int8 *)(i + 50)\n       + *(unsigned __int8 *)(i + 54)\n       + (*(unsigned __int8 *)(i + 51) | *(unsigned __int8 *)(i + 56) | (*(_QWORD *)(i + 32) != 0LL)) > 1 )\n    {\n      *(_BYTE *)(i + 55) = 0;\n      *(_BYTE *)(i + 49) = *(_BYTE *)(i + 55);\n      *(_BYTE *)(i + 48) = *(_BYTE *)(i + 49);\n      sub_406428(i, v2);\n      sub_40B084((__int64)v2);\n    }\n  }\n  return __readfsqword(0x28u) ^ v3;\n}\n"], [4239803, "sub_40B1BB", "__int64 __fastcall sub_40B1BB(__int64 a1, _QWORD *a2, const char *a3)\n{\n  unsigned int v3; // eax\n  __int64 v4; // r12\n  char *v5; // rbx\n  char *v6; // rax\n  __int64 v9; // [rsp+20h] [rbp-20h] BYREF\n  __int64 v10[3]; // [rsp+28h] [rbp-18h] BYREF\n\n  v3 = sub_415A31(a1, &v9, 10LL, v10, locale);\n  if ( v3 == 2 )\n  {\nLABEL_8:\n    *a2 = v10[0];\n    if ( *a2 == v10[0] )\n      return v9;\nLABEL_9:\n    *a2 = -1LL;\n    return v9;\n  }\n  if ( v3 <= 2 )\n  {\n    if ( v3 )\n      goto LABEL_9;\n    goto LABEL_8;\n  }\n  if ( v3 == 3 )\n    goto LABEL_9;\n  if ( v3 != 4 )\n    return v9;\n  if ( a3 )\n  {\n    v4 = sub_4112FB(a1);\n    v5 = gettext(a3);\n    v6 = gettext(\"%s: invalid count at start of %s\");\n    error(2, 0, v6, v5, v4);\n  }\n  return 0LL;\n}\n"], [4240034, "sub_40B2A2", "int __fastcall sub_40B2A2(int a1)\n{\n  sub_40327B();\n  signal(a1, 0LL);\n  return raise(a1);\n}\n"], [4240077, "sub_40B2CD", "_BYTE *__fastcall sub_40B2CD(_BYTE *a1, __int64 a2, int a3)\n{\n  int v3; // eax\n\n  while ( *a1 )\n  {\n    v3 = (char)*a1;\n    if ( v3 == 102 )\n    {\n      *(_QWORD *)(a2 + 40) = byte_61D8E0;\n    }\n    else if ( v3 > 102 )\n    {\n      if ( v3 == 105 )\n      {\n        if ( !*(_QWORD *)(a2 + 32) )\n          *(_QWORD *)(a2 + 32) = &unk_61D6E0;\n      }\n      else if ( v3 > 105 )\n      {\n        if ( v3 == 110 )\n        {\n          *(_BYTE *)(a2 + 50) = 1;\n        }\n        else\n        {\n          if ( v3 != 114 )\n            return a1;\n          *(_BYTE *)(a2 + 55) = 1;\n        }\n      }\n      else if ( v3 == 103 )\n      {\n        *(_BYTE *)(a2 + 52) = 1;\n      }\n      else\n      {\n        *(_BYTE *)(a2 + 53) = 1;\n      }\n    }\n    else if ( v3 == 86 )\n    {\n      *(_BYTE *)(a2 + 56) = 1;\n    }\n    else if ( v3 > 86 )\n    {\n      if ( v3 == 98 )\n      {\n        if ( !a3 || a3 == 2 )\n          *(_BYTE *)(a2 + 48) = 1;\n        if ( a3 == 1 || a3 == 2 )\n          *(_BYTE *)(a2 + 49) = 1;\n      }\n      else\n      {\n        if ( v3 != 100 )\n          return a1;\n        *(_QWORD *)(a2 + 32) = &unk_61D7E0;\n      }\n    }\n    else if ( v3 == 77 )\n    {\n      *(_BYTE *)(a2 + 54) = 1;\n    }\n    else\n    {\n      if ( v3 != 82 )\n        return a1;\n      *(_BYTE *)(a2 + 51) = 1;\n    }\n    ++a1;\n  }\n  return a1;\n}\n"], [4240434, "sub_40B432", "_QWORD *__fastcall sub_40B432(_QWORD *a1)\n{\n  memset(a1, 0, 0x48uLL);\n  a1[2] = -1LL;\n  return a1;\n}\n"], [4240486, "main", "void __fastcall __noreturn main(int a1, char **a2, char **a3)\n{\n  unsigned __int8 v3; // al\n  unsigned __int8 v4; // al\n  unsigned __int64 v5; // rax\n  _QWORD *v6; // rcx\n  bool v7; // al\n  _BOOL4 v8; // edx\n  _BOOL4 v9; // eax\n  int v10; // eax\n  unsigned __int64 v11; // rax\n  int v12; // eax\n  char *v13; // rax\n  __int64 v15; // rax\n  __int64 v16; // rax\n  char *v17; // rax\n  char *v18; // rax\n  char *v19; // rax\n  __int64 v20; // rbx\n  char *v21; // rax\n  char *v22; // rax\n  __int64 v23; // rbx\n  char *v24; // rax\n  char *v25; // rax\n  __int64 v26; // r12\n  char *v27; // rbx\n  int *v28; // rax\n  __int64 v29; // rbx\n  char *v30; // rax\n  __int64 v31; // rbx\n  char *v32; // rax\n  __int64 v33; // rbx\n  char *v34; // rax\n  __int64 v35; // rbx\n  char *v36; // rax\n  char v37; // al\n  char *v38; // rax\n  __int64 v39; // rbx\n  char *v40; // rax\n  char *v41; // rax\n  const char *v42; // rax\n  __int64 v43; // rax\n  __int64 v44; // rbx\n  char *v45; // rax\n  int v46; // eax\n  unsigned __int64 v47; // rax\n  unsigned __int64 v48; // rax\n  char *v49; // rax\n  char v50; // [rsp+28h] [rbp-288h]\n  char v51; // [rsp+29h] [rbp-287h]\n  char v52; // [rsp+2Ah] [rbp-286h]\n  bool v53; // [rsp+2Bh] [rbp-285h]\n  bool v54; // [rsp+2Ch] [rbp-284h]\n  char v55; // [rsp+2Dh] [rbp-283h]\n  bool v56; // [rsp+2Eh] [rbp-282h]\n  bool v57; // [rsp+2Fh] [rbp-281h]\n  char v58[12]; // [rsp+30h] [rbp-280h] BYREF\n  int v59; // [rsp+3Ch] [rbp-274h]\n  _QWORD *k; // [rsp+40h] [rbp-270h]\n  _BYTE *v61; // [rsp+48h] [rbp-268h]\n  char *v62; // [rsp+50h] [rbp-260h]\n  unsigned __int64 v63; // [rsp+58h] [rbp-258h]\n  unsigned __int64 v64; // [rsp+60h] [rbp-250h]\n  void *ptr; // [rsp+68h] [rbp-248h]\n  char *v66; // [rsp+70h] [rbp-240h]\n  char *s1; // [rsp+78h] [rbp-238h]\n  unsigned __int64 i; // [rsp+80h] [rbp-230h]\n  char *m; // [rsp+88h] [rbp-228h]\n  __int64 v70; // [rsp+90h] [rbp-220h]\n  unsigned __int64 j; // [rsp+98h] [rbp-218h]\n  unsigned __int64 l; // [rsp+A0h] [rbp-210h]\n  struct lconv *v73; // [rsp+A8h] [rbp-208h]\n  char *v74; // [rsp+B0h] [rbp-200h]\n  unsigned __int64 v75; // [rsp+B8h] [rbp-1F8h]\n  char *v76; // [rsp+C0h] [rbp-1F0h]\n  _QWORD *v77; // [rsp+C8h] [rbp-1E8h]\n  unsigned __int64 v78; // [rsp+D0h] [rbp-1E0h]\n  unsigned __int64 v79; // [rsp+D8h] [rbp-1D8h]\n  _QWORD v80[10]; // [rsp+E0h] [rbp-1D0h] BYREF\n  __int64 v81[6]; // [rsp+130h] [rbp-180h] BYREF\n  char v82; // [rsp+160h] [rbp-150h]\n  char v83; // [rsp+161h] [rbp-14Fh]\n  char v84; // [rsp+162h] [rbp-14Eh]\n  unsigned __int8 v85; // [rsp+163h] [rbp-14Dh]\n  char v86; // [rsp+164h] [rbp-14Ch]\n  char v87; // [rsp+165h] [rbp-14Bh]\n  char v88; // [rsp+166h] [rbp-14Ah]\n  char v89; // [rsp+167h] [rbp-149h]\n  char v90; // [rsp+168h] [rbp-148h]\n  struct sigaction longind[2]; // [rsp+180h] [rbp-130h] BYREF\n\n  v50 = 0;\n  v59 = 0;\n  v51 = 0;\n  v52 = 0;\n  v62 = 0LL;\n  v53 = 0;\n  v63 = 0LL;\n  v64 = 0LL;\n  v56 = getenv(\"POSIXLY_CORRECT\") != 0LL;\n  v54 = (int)sub_41116C() <= 200111;\n  v66 = 0LL;\n  s1 = 0LL;\n  sub_4111F0(*a2);\n  setlocale(6, locale);\n  bindtextdomain(\"coreutils\", \"/root/Product/coreutils/exe/share/locale\");\n  textdomain(\"coreutils\");\n  sub_402B1D(2u);\n  byte_61D5C8 = sub_40EE1C(3LL);\n  byte_61D5C9 = sub_40EE1C(2LL);\n  v73 = localeconv();\n  v3 = sub_402B35(*v73->decimal_point);\n  dword_61D5C0 = v3;\n  if ( !v3 || v73->decimal_point[1] )\n    dword_61D5C0 = 46;\n  v4 = sub_402B35(*v73->thousands_sep);\n  dword_61D5C4 = v4;\n  if ( !v4 || v73->thousands_sep[1] )\n    dword_61D5C4 = -1;\n  byte_61DA03 = 0;\n  sub_403E4B();\n  sigemptyset(&set);\n  for ( i = 0LL; i <= 0xA; ++i )\n  {\n    sigaction(sig[i], 0LL, longind);\n    if ( longind[0].sa_handler != (__sighandler_t)1 )\n      sigaddset(&set, sig[i]);\n  }\n  longind[0].sa_handler = (__sighandler_t)sub_40B2A2;\n  longind[0].sa_mask = set;\n  longind[0].sa_flags = 0;\n  for ( i = 0LL; i <= 0xA; ++i )\n  {\n    if ( sigismember(&set, sig[i]) )\n      sigaction(sig[i], longind, 0LL);\n  }\n  signal(17, 0LL);\n  sub_417140(sub_4032BF);\n  sub_40B432(v81);\n  v81[0] = -1LL;\n  ptr = (void *)sub_414E49(a1, 8LL);\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          LODWORD(longind[0].sa_handler) = -1;\n          if ( v59 != -1\n            && (!v56\n             || !v64\n             || v54\n             && !v51\n             && optind != a1\n             && *a2[optind] == 45\n             && a2[optind][1] == 111\n             && (a2[optind][2] || optind + 1 != a1)) )\n          {\n            v59 = getopt_long(a1, a2, \"-bcCdfghik:mMno:rRsS:t:T:uVy:z\", &longopts, (int *)longind);\n            if ( v59 != -1 )\n              break;\n          }\n          if ( a1 <= optind )\n          {\n            if ( v66 )\n            {\n              if ( v64 )\n              {\n                v23 = sub_4112FB(*(_QWORD *)ptr);\n                v24 = gettext(\"extra operand %s\");\n                error(0, 0, v24, v23);\n                v25 = gettext(\"file operands cannot be combined with --files0-from\");\n                fprintf(stderr, \"%s\\n\", v25);\n                sub_402CB8(2);\n              }\n              if ( !strcmp(v66, \"-\") )\n              {\n                v70 = stdin;\n              }\n              else\n              {\n                v70 = sub_40ED36(v66, \"r\");\n                if ( !v70 )\n                {\n                  v26 = sub_4112FB(v66);\n                  v27 = gettext(\"cannot open %s for reading\");\n                  v28 = __errno_location();\n                  error(2, *v28, v27, v26);\n                }\n              }\n              sub_413E7E(longind);\n              if ( (unsigned __int8)sub_41423D(v70, longind) != 1 || (unsigned int)sub_415E9D(v70) )\n              {\n                v29 = sub_4112FB(v66);\n                v30 = gettext(\"cannot read file names from %s\");\n                error(2, 0, v30, v29);\n              }\n              if ( longind[0].sa_handler )\n              {\n                free(ptr);\n                ptr = (void *)longind[0].sa_mask.__val[0];\n                v64 = (unsigned __int64)longind[0].sa_handler;\n                for ( j = 0LL; j < v64; ++j )\n                {\n                  if ( !strcmp(*((const char **)ptr + j), \"-\") )\n                  {\n                    v31 = sub_4112FB(*((_QWORD *)ptr + j));\n                    v32 = gettext(\"when reading file names from stdin, no file name of %s allowed\");\n                    error(2, 0, v32, v31);\n                  }\n                  else if ( !**((_BYTE **)ptr + j) )\n                  {\n                    v75 = j + 1;\n                    v33 = sub_412914(v66);\n                    v34 = gettext(\"%s:%lu: invalid zero-length file name\");\n                    error(2, 0, v34, v33, v75);\n                  }\n                }\n              }\n              else\n              {\n                v35 = sub_4112FB(v66);\n                v36 = gettext(\"no input from %s\");\n                error(2, 0, v36, v35);\n              }\n            }\n            for ( k = (_QWORD *)qword_61DA08; k; k = (_QWORD *)k[8] )\n            {\n              if ( sub_406393((__int64)k) && *((_BYTE *)k + 55) != 1 )\n              {\n                k[4] = v81[4];\n                k[5] = v81[5];\n                *((_BYTE *)k + 48) = v82;\n                *((_BYTE *)k + 49) = v83;\n                *((_BYTE *)k + 54) = v88;\n                *((_BYTE *)k + 50) = v84;\n                *((_BYTE *)k + 52) = v86;\n                *((_BYTE *)k + 53) = v87;\n                *((_BYTE *)k + 56) = v90;\n                *((_BYTE *)k + 51) = v85;\n                *((_BYTE *)k + 55) = v89;\n              }\n              v53 = (v53 | *((unsigned __int8 *)k + 51)) != 0;\n            }\n            if ( !qword_61DA08 && !sub_406393((__int64)v81) )\n            {\n              v50 = 1;\n              sub_40AFC8((__int64)v81);\n              v53 = (v53 | v85) != 0;\n            }\n            sub_40B0BD();\n            if ( byte_61DA18 )\n            {\n              if ( v51 || s1 )\n              {\n                if ( v51 )\n                  v37 = v51;\n                else\n                  v37 = 111;\n                byte_61D4F8 = v37;\n                sub_40B084((__int64)&byte_61D4F8);\n              }\n              if ( byte_61D5C8 )\n              {\n                v38 = setlocale(3, 0LL);\n                v39 = sub_4112FB(v38);\n                v40 = gettext(\"using %s sorting rules\");\n                error(0, 0, v40, v39);\n              }\n              else\n              {\n                v41 = gettext(\"using simple byte comparison\");\n                error(0, 0, v41);\n              }\n              sub_40657B(v81, v50);\n            }\n            byte_61DA00 = v89;\n            if ( v53 )\n              sub_40571F(v62);\n            if ( !qword_61D9F0 )\n            {\n              v76 = getenv(\"TMPDIR\");\n              if ( v76 )\n                v42 = v76;\n              else\n                v42 = \"/tmp\";\n              sub_403C5E((__int64)v42);\n            }\n            if ( !v64 )\n            {\n              v64 = 1LL;\n              free(ptr);\n              ptr = &off_61D508;\n            }\n            if ( qword_61D9E0 )\n            {\n              v43 = qword_61D9E0;\n              if ( 34 * (unsigned __int64)(unsigned int)dword_61D4EC >= qword_61D9E0 )\n                v43 = 34LL * (unsigned int)dword_61D4EC;\n              qword_61D9E0 = v43;\n            }\n            if ( v51 )\n            {\n              if ( v64 > 1 )\n              {\n                v44 = sub_4112FB(*((_QWORD *)ptr + 1));\n                v45 = gettext(\"extra operand %s not allowed with -%c\");\n                error(2, 0, v45, v44, (unsigned int)v51);\n              }\n              if ( s1 )\n              {\n                byte_61D510 = v51;\n                sub_40B084((__int64)&byte_61D510);\n              }\n              v46 = (unsigned __int8)sub_407D33(*(char **)ptr, v51) == 0;\n              exit(v46);\n            }\n            if ( v52 )\n            {\n              v77 = (_QWORD *)sub_41507D(v64, 16LL);\n              for ( l = 0LL; l < v64; ++l )\n                v77[2 * l] = *((_QWORD *)ptr + l);\n              sub_40A5DE(v77, 0LL, v64, s1);\n            }\n            else\n            {\n              if ( !v63 )\n              {\n                v78 = sub_410F0D(2LL);\n                v47 = 8LL;\n                if ( v78 <= 8 )\n                  v47 = v78;\n                v63 = v47;\n              }\n              v79 = 0xFFFFFFFFFFFFFFLL;\n              v48 = v63;\n              if ( v63 >= 0xFFFFFFFFFFFFFFLL )\n                v48 = v79;\n              v63 = v48;\n              sub_40AAF3((char **)ptr, v64, s1, v48);\n            }\n            if ( byte_61DA03 && (unsigned int)sub_415E9D(stdin) == -1 )\n            {\n              v49 = gettext(\"close failed\");\n              sub_402C5C(v49, \"-\");\n            }\n            exit(0);\n          }\n          v5 = v64++;\n          v6 = (char *)ptr + 8 * v5;\n          LODWORD(v5) = optind++;\n          *v6 = a2[(int)v5];\n        }\n        if ( v59 != 109 )\n          break;\n        v52 = 1;\n      }\n      if ( v59 <= 109 )\n        break;\n      if ( v59 == 122 )\n      {\n        byte_61D400 = 0;\n      }\n      else if ( v59 > 122 )\n      {\n        if ( v59 == 131 )\n        {\n          v66 = optarg;\n        }\n        else if ( v59 > 131 )\n        {\n          if ( v59 == 133 )\n          {\n            if ( v62 && strcmp(v62, optarg) )\n            {\n              v18 = gettext(\"multiple random sources specified\");\n              error(2, 0, v18);\n            }\n            v62 = optarg;\n          }\n          else if ( v59 < 133 )\n          {\n            sub_40409E((unsigned int)longind[0].sa_handler, v59, (__int64)optarg);\n          }\n          else\n          {\n            if ( v59 == 134 )\n            {\n              v59 = byte_4188B8[sub_40D0DC(\"--sort\", optarg, &off_418880, byte_4188B8, 1LL, off_61D520)];\n              goto LABEL_113;\n            }\n            if ( v59 != 135 )\n              goto LABEL_180;\n            v63 = sub_4044D3((unsigned int)longind[0].sa_handler, 135, (__int64)optarg);\n          }\n        }\n        else if ( v59 == 129 )\n        {\n          if ( ::s1 && strcmp(::s1, optarg) )\n          {\n            v13 = gettext(\"multiple compress programs specified\");\n            error(2, 0, v13);\n          }\n          ::s1 = optarg;\n        }\n        else\n        {\n          if ( v59 <= 129 )\n          {\n            if ( v59 != 128 )\n              goto LABEL_180;\n            if ( optarg )\n              v12 = aCccgeneralNume[sub_40D0DC(\"--check\", optarg, off_418820, \"CCcgeneral-numeric\", 1LL, off_61D520)];\n            else\n              v12 = 99;\n            v59 = v12;\n            goto LABEL_118;\n          }\n          byte_61DA18 = 1;\n        }\n      }\n      else if ( v59 == 115 )\n      {\n        byte_61DA01 = 1;\n      }\n      else if ( v59 > 115 )\n      {\n        if ( v59 == 117 )\n        {\n          byte_61DA02 = 1;\n        }\n        else if ( v59 < 117 )\n        {\n          v55 = *optarg;\n          if ( !*optarg )\n          {\n            v19 = gettext(\"empty tab\");\n            error(2, 0, v19);\n          }\n          if ( optarg[1] )\n          {\n            if ( !strcmp(optarg, \"\\\\0\") )\n            {\n              v55 = 0;\n            }\n            else\n            {\n              v20 = sub_4112FB(optarg);\n              v21 = gettext(\"multi-character tab %s\");\n              error(2, 0, v21, v20);\n            }\n          }\n          if ( dword_61D4E8 != 128 && v55 != dword_61D4E8 )\n          {\n            v22 = gettext(\"incompatible tabs\");\n            error(2, 0, v22);\n          }\n          dword_61D4E8 = v55;\n        }\n        else\n        {\n          if ( v59 != 121 )\n            goto LABEL_180;\n          if ( a2[optind - 1] == optarg )\n          {\n            for ( m = optarg; (unsigned int)(*m - 48) <= 9; ++m )\n              ;\n            optind -= *m != 0;\n          }\n        }\n      }\n      else if ( v59 == 111 )\n      {\n        if ( s1 && strcmp(s1, optarg) )\n        {\n          v17 = gettext(\"multiple output files specified\");\n          error(2, 0, v17);\n        }\n        s1 = optarg;\n      }\n      else\n      {\n        if ( v59 >= 111 && v59 != 114 )\n          goto LABEL_180;\nLABEL_113:\n        v58[0] = v59;\n        v58[1] = 0;\n        sub_40B2CD(v58, (__int64)v81, 2);\n      }\n    }\n    if ( v59 == 84 )\n    {\n      sub_403C5E((__int64)optarg);\n    }\n    else if ( v59 > 84 )\n    {\n      if ( v59 == 100 )\n        goto LABEL_113;\n      if ( v59 > 100 )\n      {\n        if ( v59 < 102 )\n          goto LABEL_180;\n        if ( v59 <= 105 )\n          goto LABEL_113;\n        if ( v59 != 107 )\n          goto LABEL_180;\n        k = sub_40B432(v80);\n        v61 = (_BYTE *)sub_40B1BB((__int64)optarg, k, \"invalid number at field start\");\n        if ( !(*k)-- )\n          sub_40B027((__int64)optarg, \"field number is zero\");\n        if ( *v61 == 46 )\n        {\n          v61 = (_BYTE *)sub_40B1BB((__int64)(v61 + 1), k + 1, \"invalid number after `.'\");\n          v15 = k[1];\n          k[1] = v15 - 1;\n          if ( !v15 )\n            sub_40B027((__int64)optarg, \"character offset is zero\");\n        }\n        if ( !*k && !k[1] )\n          *k = -1LL;\n        v61 = sub_40B2CD(v61, (__int64)k, 0);\n        if ( *v61 == 44 )\n        {\n          v61 = (_BYTE *)sub_40B1BB((__int64)(v61 + 1), k + 2, \"invalid number after `,'\");\n          v16 = k[2];\n          k[2] = v16 - 1;\n          if ( !v16 )\n            sub_40B027((__int64)optarg, \"field number is zero\");\n          if ( *v61 == 46 )\n            v61 = (_BYTE *)sub_40B1BB((__int64)(v61 + 1), k + 3, \"invalid number after `.'\");\n          v61 = sub_40B2CD(v61, (__int64)k, 1);\n        }\n        else\n        {\n          k[2] = -1LL;\n          k[3] = 0LL;\n        }\n        if ( *v61 )\n          sub_40B027((__int64)optarg, \"stray character in field spec\");\n        sub_40AFC8((__int64)k);\n      }\n      else\n      {\n        if ( v59 == 98 )\n          goto LABEL_113;\n        if ( v59 <= 98 )\n        {\n          if ( v59 != 86 )\n            goto LABEL_180;\n          goto LABEL_113;\n        }\nLABEL_118:\n        if ( v51 && v51 != v59 )\n          sub_40B084((__int64)\"cC\");\n        v51 = v59;\n      }\n    }\n    else\n    {\n      if ( v59 == 67 )\n        goto LABEL_118;\n      if ( v59 > 67 )\n      {\n        if ( v59 == 82 )\n          goto LABEL_113;\n        if ( v59 <= 82 )\n        {\n          if ( v59 != 77 )\n            goto LABEL_180;\n          goto LABEL_113;\n        }\n        sub_4042D1((unsigned int)longind[0].sa_handler, v59, (__int64)optarg);\n      }\n      else\n      {\n        if ( v59 == -130 )\n          sub_402CB8(0);\n        if ( v59 != 1 )\n        {\n          if ( v59 == -131 )\n          {\n            sub_414D2A(\n              (_DWORD)stdout,\n              (unsigned int)\"sort\",\n              (unsigned int)\"GNU coreutils\",\n              (_DWORD)off_61D518,\n              (unsigned int)\"Mike Haertel\",\n              (unsigned int)\"Paul Eggert\",\n              0);\n            exit(0);\n          }\nLABEL_180:\n          sub_402CB8(2);\n        }\n        k = 0LL;\n        if ( *optarg == 43 )\n        {\n          v7 = optind != a1 && *a2[optind] == 45 && (unsigned int)(a2[optind][1] - 48) <= 9;\n          v57 = v7;\n          v8 = v54;\n          v9 = v7 && !v56;\n          v54 = v54 || v9;\n          if ( v8 || v9 )\n          {\n            k = sub_40B432(v80);\n            v61 = (_BYTE *)sub_40B1BB((__int64)(optarg + 1), k, 0LL);\n            if ( v61 && *v61 == 46 )\n              v61 = (_BYTE *)sub_40B1BB((__int64)(v61 + 1), k + 1, 0LL);\n            if ( !*k && !k[1] )\n              *k = -1LL;\n            if ( v61 && !*sub_40B2CD(v61, (__int64)k, 0) )\n            {\n              if ( v57 )\n              {\n                v10 = optind++;\n                v74 = a2[v10];\n                v61 = (_BYTE *)sub_40B1BB((__int64)(v74 + 1), k + 2, \"invalid number after `-'\");\n                if ( *v61 == 46 )\n                  v61 = (_BYTE *)sub_40B1BB((__int64)(v61 + 1), k + 3, \"invalid number after `.'\");\n                if ( !k[3] && k[2] )\n                  --k[2];\n                if ( *sub_40B2CD(v61, (__int64)k, 1) )\n                  sub_40B027((__int64)v74, \"stray character in field spec\");\n              }\n              *((_BYTE *)k + 57) = 1;\n              sub_40AFC8((__int64)k);\n            }\n            else\n            {\n              k = 0LL;\n            }\n          }\n        }\n        if ( !k )\n        {\n          v11 = v64++;\n          *((_QWORD *)ptr + v11) = optarg;\n        }\n      }\n    }\n  }\n}\n"], [4247010, "sub_40CDE2", "void __noreturn sub_40CDE2()\n{\n  sub_402CB8(1);\n}\n"], [4247026, "sub_40CDF2", "__int64 __fastcall sub_40CDF2(const char *a1, __int64 a2, __int64 a3, size_t a4)\n{\n  __int64 result; // rax\n  char v7; // [rsp+27h] [rbp-19h]\n  __int64 i; // [rsp+28h] [rbp-18h]\n  __int64 v9; // [rsp+30h] [rbp-10h]\n  size_t n; // [rsp+38h] [rbp-8h]\n\n  v9 = -1LL;\n  v7 = 0;\n  n = strlen(a1);\n  for ( i = 0LL; *(_QWORD *)(8 * i + a2); ++i )\n  {\n    if ( !strncmp(*(const char **)(8 * i + a2), a1, n) )\n    {\n      if ( strlen(*(const char **)(8 * i + a2)) == n )\n        return i;\n      if ( v9 == -1 )\n      {\n        v9 = i;\n      }\n      else if ( !a3 || memcmp((const void *)(a4 * v9 + a3), (const void *)(i * a4 + a3), a4) )\n      {\n        v7 = 1;\n      }\n    }\n  }\n  if ( v7 )\n    result = -2LL;\n  else\n    result = v9;\n  return result;\n}\n"], [4247329, "sub_40CF21", "void __fastcall sub_40CF21(__int64 a1, __int64 a2, __int64 a3)\n{\n  char *v3; // rax\n  __int64 v4; // rbx\n  __int64 v5; // rax\n  char *format; // [rsp+28h] [rbp-18h]\n\n  if ( a3 == -1 )\n    v3 = gettext(\"invalid argument %s for %s\");\n  else\n    v3 = gettext(\"ambiguous argument %s for %s\");\n  format = v3;\n  v4 = sub_4112D7(1LL, a1);\n  v5 = sub_412786(0LL, 6LL, a2);\n  error(0, 0, format, v5, v4);\n}\n"], [4247468, "sub_40CFAC", "int __fastcall sub_40CFAC(__int64 a1, __int64 a2, size_t a3)\n{\n  char *v3; // rax\n  __int64 i; // [rsp+20h] [rbp-10h]\n  void *s1; // [rsp+28h] [rbp-8h]\n\n  s1 = 0LL;\n  v3 = gettext(\"Valid arguments are:\");\n  fprintf(stderr, v3);\n  for ( i = 0LL; *(_QWORD *)(8 * i + a1); ++i )\n  {\n    if ( i && !memcmp(s1, (const void *)(i * a3 + a2), a3) )\n    {\n      fprintf(stderr, \", `%s'\", *(const char **)(8 * i + a1));\n    }\n    else\n    {\n      fprintf(stderr, \"\\n  - `%s'\", *(const char **)(8 * i + a1));\n      s1 = (void *)(i * a3 + a2);\n    }\n  }\n  return putc_unlocked(10, stderr);\n}\n"], [4247772, "sub_40D0DC", "__int64 __fastcall sub_40D0DC(__int64 a1, const char *a2, __int64 a3, __int64 a4, size_t a5, void (*a6)(void))\n{\n  __int64 v11; // [rsp+38h] [rbp-8h]\n\n  v11 = sub_40CDF2(a2, a3, a4, a5);\n  if ( v11 >= 0 )\n    return v11;\n  sub_40CF21(a1, (__int64)a2, v11);\n  sub_40CFAC(a3, a4, a5);\n  a6();\n  return -1LL;\n}\n"], [4247906, "sub_40D162", "__int64 __fastcall sub_40D162(const void *a1, __int64 a2, __int64 a3, size_t a4)\n{\n  __int64 i; // [rsp+28h] [rbp-8h]\n\n  for ( i = 0LL; *(_QWORD *)(8 * i + a2); ++i )\n  {\n    if ( !memcmp(a1, (const void *)(i * a4 + a3), a4) )\n      return *(_QWORD *)(8 * i + a2);\n  }\n  return 0LL;\n}\n"], [4248046, "sub_40D1EE", "__int64 __fastcall sub_40D1EE(__int64 a1)\n{\n  __int64 result; // rax\n\n  result = a1;\n  qword_61DBA0 = a1;\n  return result;\n}\n"], [4248067, "sub_40D203", "__int64 __fastcall sub_40D203(unsigned __int8 a1)\n{\n  __int64 result; // rax\n\n  result = a1;\n  byte_61DBA8 = a1;\n  return result;\n}\n"], [4248088, "sub_40D218", "__int64 sub_40D218()\n{\n  const char *v0; // rbx\n  int *v1; // rax\n  int *v2; // rax\n  __int64 result; // rax\n  char *v4; // [rsp+8h] [rbp-18h]\n\n  if ( (unsigned int)sub_416CA7(stdout) && (byte_61DBA8 != 1 || *__errno_location() != 32) )\n  {\n    v4 = gettext(\"write error\");\n    if ( qword_61DBA0 )\n    {\n      v0 = (const char *)sub_412914(qword_61DBA0);\n      v1 = __errno_location();\n      error(0, *v1, \"%s: %s\", v0, v4);\n    }\n    else\n    {\n      v2 = __errno_location();\n      error(0, *v2, \"%s\", v4);\n    }\n    _exit(status);\n  }\n  result = sub_416CA7(stderr);\n  if ( (_DWORD)result )\n    _exit(status);\n  return result;\n}\n"], [4248323, "sub_40D303", "_DWORD *__fastcall sub_40D303(_DWORD *a1)\n{\n  _DWORD *result; // rax\n\n  *a1 = 1732584193;\n  a1[1] = -271733879;\n  a1[2] = -1732584194;\n  a1[3] = 271733878;\n  a1[5] = 0;\n  a1[4] = a1[5];\n  result = a1;\n  a1[6] = 0;\n  return result;\n}\n"], [4248412, "sub_40D35C", "_DWORD *__fastcall sub_40D35C(_DWORD *a1, int a2)\n{\n  _DWORD *result; // rax\n\n  result = a1;\n  *a1 = a2;\n  return result;\n}\n"], [4248434, "sub_40D372", "_DWORD *__fastcall sub_40D372(int *a1, _DWORD *a2)\n{\n  sub_40D35C(a2, *a1);\n  sub_40D35C(a2 + 1, a1[1]);\n  sub_40D35C(a2 + 2, a1[2]);\n  sub_40D35C(a2 + 3, a1[3]);\n  return a2;\n}\n"], [4248559, "sub_40D3EF", "_DWORD *__fastcall sub_40D3EF(int *a1, _DWORD *a2)\n{\n  __int64 v2; // rax\n  unsigned int v4; // [rsp+14h] [rbp-Ch]\n  __int64 v5; // [rsp+18h] [rbp-8h]\n\n  v4 = a1[6];\n  if ( v4 > 0x37 )\n    v2 = 32LL;\n  else\n    v2 = 16LL;\n  v5 = v2;\n  a1[4] += v4;\n  if ( a1[4] < v4 )\n    ++a1[5];\n  a1[v2 + 5] = 8 * a1[4];\n  a1[v2 + 6] = *((__int64 *)a1 + 2) >> 29;\n  memcpy((char *)a1 + v4 + 28, &unk_419260, 4 * v2 - v4 - 8);\n  sub_40D911(a1 + 7, 4 * v5, a1);\n  return sub_40D372(a1, a2);\n}\n"], [4248843, "sub_40D50B", "__int64 __fastcall sub_40D50B(FILE *a1, _DWORD *a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-B8h]\n  char *ptr; // [rsp+20h] [rbp-B0h]\n  size_t v5; // [rsp+28h] [rbp-A8h]\n  int v6[40]; // [rsp+30h] [rbp-A0h] BYREF\n\n  ptr = (char *)malloc(0x8048uLL);\n  if ( !ptr )\n    return 1LL;\n  sub_40D303(v6);\nLABEL_4:\n  v3 = 0LL;\n  while ( 1 )\n  {\n    v5 = fread_unlocked(&ptr[v3], 1uLL, 0x8000 - v3, a1);\n    v3 += v5;\n    if ( v3 == 0x8000 )\n    {\n      sub_40D911(ptr, 0x8000LL, v6);\n      goto LABEL_4;\n    }\n    if ( !v5 )\n      break;\n    if ( feof_unlocked(a1) )\n      goto LABEL_12;\n  }\n  if ( ferror_unlocked(a1) )\n  {\n    free(ptr);\n    return 1LL;\n  }\nLABEL_12:\n  if ( v3 )\n    sub_40D6EA(ptr, v3, v6);\n  sub_40D3EF(v6, a2);\n  free(ptr);\n  return 0LL;\n}\n"], [4249216, "sub_40D680", "_DWORD *__fastcall sub_40D680(__int64 a1, __int64 a2, _DWORD *a3)\n{\n  int v5[40]; // [rsp+20h] [rbp-A0h] BYREF\n\n  sub_40D303(v5);\n  sub_40D6EA(a1, a2, v5);\n  return sub_40D3EF(v5, a3);\n}\n"], [4249322, "sub_40D6EA", "unsigned __int64 __fastcall sub_40D6EA(char *a1, unsigned __int64 a2, unsigned int *a3)\n{\n  unsigned __int64 result; // rax\n  size_t v4; // rax\n  void *v5; // rax\n  size_t v7; // [rsp+10h] [rbp-30h]\n  char *src; // [rsp+18h] [rbp-28h]\n  size_t v9; // [rsp+28h] [rbp-18h]\n  size_t v10; // [rsp+28h] [rbp-18h]\n  __int64 v11; // [rsp+30h] [rbp-10h]\n  size_t n; // [rsp+38h] [rbp-8h]\n\n  src = a1;\n  v7 = a2;\n  result = a3[6];\n  if ( (_DWORD)result )\n  {\n    v11 = a3[6];\n    v4 = a2;\n    if ( 128 - v11 <= a2 )\n      v4 = 128 - v11;\n    n = v4;\n    memcpy((char *)a3 + v11 + 28, a1, v4);\n    a3[6] += n;\n    if ( a3[6] > 0x40 )\n    {\n      sub_40D911(a3 + 7, a3[6] & 0xFFFFFFC0, a3);\n      a3[6] &= 0x3Fu;\n      memcpy(a3 + 7, (char *)a3 + ((v11 + n) & 0xFFFFFFFFFFFFFFC0LL) + 28, a3[6]);\n    }\n    src = &a1[n];\n    result = n;\n    v7 = a2 - n;\n  }\n  if ( v7 > 0x3F )\n  {\n    result = (unsigned __int8)src & 3;\n    if ( ((unsigned __int8)src & 3) != 0 )\n    {\n      while ( v7 > 0x40 )\n      {\n        v5 = memcpy(a3 + 7, src, 0x40uLL);\n        result = sub_40D911(v5, 64LL, a3);\n        src += 64;\n        v7 -= 64LL;\n      }\n    }\n    else\n    {\n      sub_40D911(src, v7 & 0xFFFFFFFFFFFFFFC0LL, a3);\n      result = v7 & 0xFFFFFFFFFFFFFFC0LL;\n      src += v7 & 0xFFFFFFFFFFFFFFC0LL;\n      v7 &= 0x3Fu;\n    }\n  }\n  if ( v7 )\n  {\n    v9 = a3[6];\n    memcpy((char *)a3 + v9 + 28, src, v7);\n    v10 = v7 + v9;\n    if ( v10 > 0x3F )\n    {\n      sub_40D911(a3 + 7, 64LL, a3);\n      v10 -= 64LL;\n      memcpy(a3 + 7, a3 + 23, v10);\n    }\n    result = (unsigned __int64)a3;\n    a3[6] = v10;\n  }\n  return result;\n}\n"], [4249873, "sub_40D911", "_DWORD *__fastcall sub_40D911(int *a1, unsigned __int64 a2, _DWORD *a3)\n{\n  int v3; // et0\n  int v4; // et0\n  int v5; // et0\n  int v6; // et0\n  int v7; // et0\n  int v8; // et0\n  int v9; // et0\n  int v10; // et0\n  int v11; // et0\n  int v12; // et0\n  int v13; // et0\n  int v14; // et0\n  int v15; // et0\n  int v16; // et0\n  int v17; // et0\n  int v18; // et0\n  int v19; // et0\n  int v20; // et0\n  int v21; // et0\n  int v22; // et0\n  int v23; // et0\n  int v24; // et0\n  int v25; // et0\n  int v26; // et0\n  int v27; // et0\n  int v28; // et0\n  int v29; // et0\n  int v30; // et0\n  int v31; // et0\n  int v32; // et0\n  int v33; // et0\n  int v34; // et0\n  int v35; // et0\n  int v36; // et0\n  int v37; // et0\n  int v38; // et0\n  int v39; // et0\n  int v40; // et0\n  int v41; // et0\n  int v42; // et0\n  int v43; // et0\n  int v44; // et0\n  int v45; // et0\n  int v46; // et0\n  int v47; // et0\n  int v48; // et0\n  int v49; // et0\n  int v50; // et0\n  int v51; // et0\n  int v52; // et0\n  int v53; // et0\n  int v54; // et0\n  int v55; // et0\n  int v56; // et0\n  int v57; // et0\n  int v58; // et0\n  int v59; // et0\n  int v60; // et0\n  int v61; // et0\n  int v62; // et0\n  int v63; // et0\n  int v64; // et0\n  int v65; // et0\n  int v66; // et0\n  _DWORD *result; // rax\n  int v68; // [rsp+18h] [rbp-80h]\n  int v69; // [rsp+18h] [rbp-80h]\n  int v70; // [rsp+18h] [rbp-80h]\n  int v71; // [rsp+18h] [rbp-80h]\n  int v72; // [rsp+18h] [rbp-80h]\n  int v73; // [rsp+18h] [rbp-80h]\n  int v74; // [rsp+18h] [rbp-80h]\n  int v75; // [rsp+18h] [rbp-80h]\n  int v76; // [rsp+18h] [rbp-80h]\n  int v77; // [rsp+18h] [rbp-80h]\n  int v78; // [rsp+18h] [rbp-80h]\n  int v79; // [rsp+18h] [rbp-80h]\n  int v80; // [rsp+18h] [rbp-80h]\n  int v81; // [rsp+18h] [rbp-80h]\n  int v82; // [rsp+18h] [rbp-80h]\n  int v83; // [rsp+18h] [rbp-80h]\n  int v84; // [rsp+18h] [rbp-80h]\n  int v85; // [rsp+18h] [rbp-80h]\n  int v86; // [rsp+1Ch] [rbp-7Ch]\n  int v87; // [rsp+1Ch] [rbp-7Ch]\n  int v88; // [rsp+1Ch] [rbp-7Ch]\n  int v89; // [rsp+1Ch] [rbp-7Ch]\n  int v90; // [rsp+1Ch] [rbp-7Ch]\n  int v91; // [rsp+1Ch] [rbp-7Ch]\n  int v92; // [rsp+1Ch] [rbp-7Ch]\n  int v93; // [rsp+1Ch] [rbp-7Ch]\n  int v94; // [rsp+1Ch] [rbp-7Ch]\n  int v95; // [rsp+1Ch] [rbp-7Ch]\n  int v96; // [rsp+1Ch] [rbp-7Ch]\n  int v97; // [rsp+1Ch] [rbp-7Ch]\n  int v98; // [rsp+1Ch] [rbp-7Ch]\n  int v99; // [rsp+1Ch] [rbp-7Ch]\n  int v100; // [rsp+1Ch] [rbp-7Ch]\n  int v101; // [rsp+1Ch] [rbp-7Ch]\n  int v102; // [rsp+20h] [rbp-78h]\n  int v103; // [rsp+20h] [rbp-78h]\n  int v104; // [rsp+20h] [rbp-78h]\n  int v105; // [rsp+20h] [rbp-78h]\n  int v106; // [rsp+20h] [rbp-78h]\n  int v107; // [rsp+20h] [rbp-78h]\n  int v108; // [rsp+20h] [rbp-78h]\n  int v109; // [rsp+20h] [rbp-78h]\n  int v110; // [rsp+20h] [rbp-78h]\n  int v111; // [rsp+20h] [rbp-78h]\n  int v112; // [rsp+20h] [rbp-78h]\n  int v113; // [rsp+20h] [rbp-78h]\n  int v114; // [rsp+20h] [rbp-78h]\n  int v115; // [rsp+20h] [rbp-78h]\n  int v116; // [rsp+20h] [rbp-78h]\n  int v117; // [rsp+20h] [rbp-78h]\n  int v118; // [rsp+20h] [rbp-78h]\n  int v119; // [rsp+24h] [rbp-74h]\n  int v120; // [rsp+24h] [rbp-74h]\n  int v121; // [rsp+24h] [rbp-74h]\n  int v122; // [rsp+24h] [rbp-74h]\n  int v123; // [rsp+24h] [rbp-74h]\n  int v124; // [rsp+24h] [rbp-74h]\n  int v125; // [rsp+24h] [rbp-74h]\n  int v126; // [rsp+24h] [rbp-74h]\n  int v127; // [rsp+24h] [rbp-74h]\n  int v128; // [rsp+24h] [rbp-74h]\n  int v129; // [rsp+24h] [rbp-74h]\n  int v130; // [rsp+24h] [rbp-74h]\n  int v131; // [rsp+24h] [rbp-74h]\n  int v132; // [rsp+24h] [rbp-74h]\n  int v133; // [rsp+24h] [rbp-74h]\n  int v134; // [rsp+24h] [rbp-74h]\n  int v135; // [rsp+24h] [rbp-74h]\n  int v136; // [rsp+28h] [rbp-70h]\n  int v137; // [rsp+2Ch] [rbp-6Ch]\n  int v138; // [rsp+30h] [rbp-68h]\n  int v139; // [rsp+34h] [rbp-64h]\n  int *v140; // [rsp+38h] [rbp-60h]\n  int *v141; // [rsp+38h] [rbp-60h]\n  int v142; // [rsp+58h] [rbp-40h]\n  int v143; // [rsp+5Ch] [rbp-3Ch]\n  int v144; // [rsp+60h] [rbp-38h]\n  int v145; // [rsp+64h] [rbp-34h]\n  int v146; // [rsp+68h] [rbp-30h]\n  int v147; // [rsp+6Ch] [rbp-2Ch]\n  int v148; // [rsp+70h] [rbp-28h]\n  int v149; // [rsp+74h] [rbp-24h]\n  int v150; // [rsp+78h] [rbp-20h]\n  int v151; // [rsp+7Ch] [rbp-1Ch]\n  int v152; // [rsp+80h] [rbp-18h]\n  int v153; // [rsp+84h] [rbp-14h]\n  int v154; // [rsp+88h] [rbp-10h]\n  int v155; // [rsp+8Ch] [rbp-Ch]\n  int v156; // [rsp+90h] [rbp-8h]\n  int v157; // [rsp+94h] [rbp-4h]\n\n  v140 = a1;\n  v68 = *a3;\n  v86 = a3[1];\n  v102 = a3[2];\n  v119 = a3[3];\n  a3[4] += a2;\n  if ( (unsigned int)a3[4] < a2 )\n    ++a3[5];\n  while ( v140 < &a1[a2 >> 2] )\n  {\n    v136 = v68;\n    v137 = v86;\n    v138 = v102;\n    v139 = v119;\n    v142 = *v140;\n    v69 = (v119 ^ v86 & (v102 ^ v119)) + *v140 + v68 - 680876936;\n    v141 = v140 + 1;\n    v3 = __ROR4__(v69, 25);\n    v70 = v86 + v3;\n    v143 = *v141++;\n    v4 = __ROR4__((v102 ^ (v86 + v3) & (v86 ^ v102)) + v143 + v119 - 389564586, 20);\n    v120 = v70 + v4;\n    v144 = *v141++;\n    v5 = __ROR4__((v86 ^ (v70 + v4) & (v70 ^ v86)) + v144 + v102 + 606105819, 15);\n    v103 = v120 + v5;\n    v145 = *v141++;\n    v6 = __ROR4__((v70 ^ (v120 + v5) & (v120 ^ v70)) + v145 + v86 - 1044525330, 10);\n    v87 = v103 + v6;\n    v146 = *v141++;\n    v7 = __ROR4__((v120 ^ (v103 + v6) & (v103 ^ v120)) + v146 + v70 - 176418897, 25);\n    v71 = v87 + v7;\n    v147 = *v141++;\n    v8 = __ROR4__((v103 ^ (v87 + v7) & (v87 ^ v103)) + v147 + v120 + 1200080426, 20);\n    v121 = v71 + v8;\n    v148 = *v141++;\n    v9 = __ROR4__((v87 ^ (v71 + v8) & (v71 ^ v87)) + v148 + v103 - 1473231341, 15);\n    v104 = v121 + v9;\n    v149 = *v141++;\n    v10 = __ROR4__((v71 ^ (v121 + v9) & (v121 ^ v71)) + v149 + v87 - 45705983, 10);\n    v88 = v104 + v10;\n    v150 = *v141++;\n    v11 = __ROR4__((v121 ^ (v104 + v10) & (v104 ^ v121)) + v150 + v71 + 1770035416, 25);\n    v72 = v88 + v11;\n    v151 = *v141++;\n    v12 = __ROR4__((v104 ^ (v88 + v11) & (v88 ^ v104)) + v151 + v121 - 1958414417, 20);\n    v122 = v72 + v12;\n    v152 = *v141++;\n    v13 = __ROR4__((v88 ^ (v72 + v12) & (v72 ^ v88)) + v152 + v104 - 42063, 15);\n    v105 = v122 + v13;\n    v153 = *v141++;\n    v14 = __ROR4__((v72 ^ (v122 + v13) & (v122 ^ v72)) + v153 + v88 - 1990404162, 10);\n    v89 = v105 + v14;\n    v154 = *v141++;\n    v15 = __ROR4__((v122 ^ (v105 + v14) & (v105 ^ v122)) + v154 + v72 + 1804603682, 25);\n    v73 = v89 + v15;\n    v155 = *v141++;\n    v16 = __ROR4__((v105 ^ (v89 + v15) & (v89 ^ v105)) + v155 + v122 - 40341101, 20);\n    v123 = v73 + v16;\n    v156 = *v141++;\n    v17 = __ROR4__((v89 ^ (v73 + v16) & (v73 ^ v89)) + v156 + v105 - 1502002290, 15);\n    v106 = v123 + v17;\n    v157 = *v141;\n    v140 = v141 + 1;\n    v18 = __ROR4__((v73 ^ (v123 + v17) & (v123 ^ v73)) + v157 + v89 + 1236535329, 10);\n    v90 = v106 + v18;\n    v19 = __ROR4__(v143 + (v106 ^ v123 & ((v106 + v18) ^ v106)) + v73 - 165796510, 27);\n    v74 = v90 + v19;\n    v20 = __ROR4__(v148 + (v90 ^ v106 & ((v90 + v19) ^ v90)) + v123 - 1069501632, 23);\n    v124 = v74 + v20;\n    v21 = __ROR4__(v153 + (v74 ^ v90 & ((v74 + v20) ^ v74)) + v106 + 643717713, 18);\n    v107 = v124 + v21;\n    v22 = __ROR4__(v142 + (v124 ^ v74 & ((v124 + v21) ^ v124)) + v90 - 373897302, 12);\n    v91 = v107 + v22;\n    v23 = __ROR4__(v147 + (v107 ^ v124 & ((v107 + v22) ^ v107)) + v74 - 701558691, 27);\n    v75 = v91 + v23;\n    v24 = __ROR4__(v152 + (v91 ^ v107 & ((v91 + v23) ^ v91)) + v124 + 38016083, 23);\n    v125 = v75 + v24;\n    v25 = __ROR4__(v157 + (v75 ^ v91 & ((v75 + v24) ^ v75)) + v107 - 660478335, 18);\n    v108 = v125 + v25;\n    v26 = __ROR4__(v146 + (v125 ^ v75 & ((v125 + v25) ^ v125)) + v91 - 405537848, 12);\n    v92 = v108 + v26;\n    v27 = __ROR4__(v151 + (v108 ^ v125 & ((v108 + v26) ^ v108)) + v75 + 568446438, 27);\n    v76 = v92 + v27;\n    v28 = __ROR4__(v156 + (v92 ^ v108 & ((v92 + v27) ^ v92)) + v125 - 1019803690, 23);\n    v126 = v76 + v28;\n    v29 = __ROR4__(v145 + (v76 ^ v92 & ((v76 + v28) ^ v76)) + v108 - 187363961, 18);\n    v109 = v126 + v29;\n    v30 = __ROR4__(v150 + (v126 ^ v76 & ((v126 + v29) ^ v126)) + v92 + 1163531501, 12);\n    v93 = v109 + v30;\n    v31 = __ROR4__(v155 + (v109 ^ v126 & ((v109 + v30) ^ v109)) + v76 - 1444681467, 27);\n    v77 = v93 + v31;\n    v32 = __ROR4__(v144 + (v93 ^ v109 & ((v93 + v31) ^ v93)) + v126 - 51403784, 23);\n    v127 = v77 + v32;\n    v33 = __ROR4__(v149 + (v77 ^ v93 & ((v77 + v32) ^ v77)) + v109 + 1735328473, 18);\n    v110 = v127 + v33;\n    v34 = __ROR4__(v154 + (v127 ^ v77 & ((v127 + v33) ^ v127)) + v93 - 1926607734, 12);\n    v94 = v110 + v34;\n    v35 = __ROR4__(v147 + (v127 ^ (v110 + v34) ^ v110) + v77 - 378558, 28);\n    v78 = v94 + v35;\n    v36 = __ROR4__(v150 + (v110 ^ (v94 + v35) ^ v94) + v127 - 2022574463, 21);\n    v128 = v78 + v36;\n    v37 = __ROR4__(v153 + (v94 ^ (v78 + v36) ^ v78) + v110 + 1839030562, 16);\n    v111 = v128 + v37;\n    v38 = __ROR4__(v156 + (v78 ^ (v128 + v37) ^ v128) + v94 - 35309556, 9);\n    v95 = v111 + v38;\n    v39 = __ROR4__(v143 + (v128 ^ (v111 + v38) ^ v111) + v78 - 1530992060, 28);\n    v79 = v95 + v39;\n    v40 = __ROR4__(v146 + (v111 ^ (v95 + v39) ^ v95) + v128 + 1272893353, 21);\n    v129 = v79 + v40;\n    v41 = __ROR4__(v149 + (v95 ^ (v79 + v40) ^ v79) + v111 - 155497632, 16);\n    v112 = v129 + v41;\n    v42 = __ROR4__(v152 + (v79 ^ (v129 + v41) ^ v129) + v95 - 1094730640, 9);\n    v96 = v112 + v42;\n    v43 = __ROR4__(v155 + (v129 ^ (v112 + v42) ^ v112) + v79 + 681279174, 28);\n    v80 = v96 + v43;\n    v44 = __ROR4__(v142 + (v112 ^ (v96 + v43) ^ v96) + v129 - 358537222, 21);\n    v130 = v80 + v44;\n    v45 = __ROR4__(v145 + (v96 ^ (v80 + v44) ^ v80) + v112 - 722521979, 16);\n    v113 = v130 + v45;\n    v46 = __ROR4__(v148 + (v80 ^ (v130 + v45) ^ v130) + v96 + 76029189, 9);\n    v97 = v113 + v46;\n    v47 = __ROR4__(v151 + (v130 ^ (v113 + v46) ^ v113) + v80 - 640364487, 28);\n    v81 = v97 + v47;\n    v48 = __ROR4__(v154 + (v113 ^ (v97 + v47) ^ v97) + v130 - 421815835, 21);\n    v131 = v81 + v48;\n    v49 = __ROR4__(v157 + (v97 ^ (v81 + v48) ^ v81) + v113 + 530742520, 16);\n    v114 = v131 + v49;\n    v50 = __ROR4__(v144 + (v81 ^ (v131 + v49) ^ v131) + v97 - 995338651, 9);\n    v98 = v114 + v50;\n    v51 = __ROR4__(v142 + (v114 ^ ((v114 + v50) | ~v131)) + v81 - 198630844, 26);\n    v82 = v98 + v51;\n    v52 = __ROR4__(v149 + (v98 ^ ((v98 + v51) | ~v114)) + v131 + 1126891415, 22);\n    v132 = v82 + v52;\n    v53 = __ROR4__(v156 + (v82 ^ ((v82 + v52) | ~v98)) + v114 - 1416354905, 17);\n    v115 = v132 + v53;\n    v54 = __ROR4__(v147 + (v132 ^ ((v132 + v53) | ~v82)) + v98 - 57434055, 11);\n    v99 = v115 + v54;\n    v55 = __ROR4__(v154 + (v115 ^ ((v115 + v54) | ~v132)) + v82 + 1700485571, 26);\n    v83 = v99 + v55;\n    v56 = __ROR4__(v145 + (v99 ^ ((v99 + v55) | ~v115)) + v132 - 1894986606, 22);\n    v133 = v83 + v56;\n    v57 = __ROR4__(v152 + (v83 ^ ((v83 + v56) | ~v99)) + v115 - 1051523, 17);\n    v116 = v133 + v57;\n    v58 = __ROR4__(v143 + (v133 ^ ((v133 + v57) | ~v83)) + v99 - 2054922799, 11);\n    v100 = v116 + v58;\n    v59 = __ROR4__(v150 + (v116 ^ ((v116 + v58) | ~v133)) + v83 + 1873313359, 26);\n    v84 = v100 + v59;\n    v60 = __ROR4__(v157 + (v100 ^ ((v100 + v59) | ~v116)) + v133 - 30611744, 22);\n    v134 = v84 + v60;\n    v61 = __ROR4__(v148 + (v84 ^ ((v84 + v60) | ~v100)) + v116 - 1560198380, 17);\n    v117 = v134 + v61;\n    v62 = __ROR4__(v155 + (v134 ^ ((v134 + v61) | ~v84)) + v100 + 1309151649, 11);\n    v101 = v117 + v62;\n    v63 = __ROR4__(v146 + (v117 ^ ((v117 + v62) | ~v134)) + v84 - 145523070, 26);\n    v85 = v101 + v63;\n    v64 = __ROR4__(v153 + (v101 ^ ((v101 + v63) | ~v117)) + v134 - 1120210379, 22);\n    v135 = v85 + v64;\n    v65 = __ROR4__(v144 + (v85 ^ ((v85 + v64) | ~v101)) + v117 + 718787259, 17);\n    v118 = v135 + v65;\n    v66 = __ROR4__(v151 + (v135 ^ ((v135 + v65) | ~v85)) + v101 - 343485551, 11);\n    v68 = v136 + v85;\n    v86 = v137 + v118 + v66;\n    v102 = v138 + v118;\n    v119 = v139 + v135;\n  }\n  *a3 = v68;\n  a3[1] = v86;\n  a3[2] = v102;\n  result = a3;\n  a3[3] = v119;\n  return result;\n}\n"], [4253328, "sub_40E690", "_BYTE *__fastcall sub_40E690(_BYTE *a1)\n{\n  char v2; // [rsp+17h] [rbp-11h]\n  _BYTE *i; // [rsp+20h] [rbp-8h]\n\n  v2 = 0;\n  while ( *a1 == 47 )\n    ++a1;\n  for ( i = a1; *i; ++i )\n  {\n    if ( *i == 47 )\n    {\n      v2 = 1;\n    }\n    else if ( v2 )\n    {\n      a1 = i;\n      v2 = 0;\n    }\n  }\n  return a1;\n}\n"], [4253433, "sub_40E6F9", "size_t __fastcall sub_40E6F9(const char *a1)\n{\n  size_t i; // [rsp+10h] [rbp-10h]\n\n  for ( i = strlen(a1); i > 1 && a1[i - 1] == 47; --i )\n    ;\n  return i;\n}\n"], [4253511, "sub_40E747", "int __fastcall sub_40E747(int a1, off_t a2, off_t a3, int a4)\n{\n  return posix_fadvise(a1, a2, a3, a4);\n}\n"], [4253559, "sub_40E777", "void __fastcall sub_40E777(FILE *a1, int a2)\n{\n  int v2; // eax\n\n  if ( a1 )\n  {\n    v2 = fileno(a1);\n    sub_40E747(v2, 0LL, 0LL, a2);\n  }\n}\n"], [4253617, "sub_40E7B1", "_BYTE *__fastcall sub_40E7B1(_BYTE **a1)\n{\n  char v2; // [rsp+17h] [rbp-9h]\n  _BYTE *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = 0LL;\n  v2 = 0;\n  while ( **a1 )\n  {\n    if ( v2 )\n    {\n      v2 = 0;\n      if ( (unsigned __int8)sub_416A7D((unsigned int)(char)**a1) != 1 && **a1 != 126 )\n        v3 = 0LL;\n    }\n    else if ( **a1 == 46 )\n    {\n      v2 = 1;\n      if ( !v3 )\n        v3 = *a1;\n    }\n    else if ( (unsigned __int8)sub_416A43((unsigned int)(char)**a1) != 1 && **a1 != 126 )\n    {\n      v3 = 0LL;\n    }\n    ++*a1;\n  }\n  return v3;\n}\n"], [4253836, "sub_40E88C", "__int64 __fastcall sub_40E88C(unsigned __int8 a1)\n{\n  if ( (unsigned __int8)sub_416AF7(a1) )\n    return 0LL;\n  if ( (unsigned __int8)sub_416A7D(a1) )\n    return a1;\n  if ( a1 == 126 )\n    return 0xFFFFFFFFLL;\n  return (unsigned int)a1 + 256;\n}\n"], [4253916, "sub_40E8DC", "__int64 __fastcall sub_40E8DC(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4)\n{\n  int v4; // eax\n  int v5; // eax\n  unsigned int v9; // [rsp+24h] [rbp-1Ch]\n  int v10; // [rsp+28h] [rbp-18h]\n  unsigned __int64 v11; // [rsp+30h] [rbp-10h]\n  unsigned __int64 v12; // [rsp+38h] [rbp-8h]\n\n  v11 = 0LL;\n  v12 = 0LL;\n  while ( v11 < a2 || v12 < a4 )\n  {\n    v9 = 0;\n    while ( v11 < a2 && (unsigned __int8)sub_416AF7((unsigned int)*(char *)(a1 + v11)) != 1\n         || v12 < a4 && (unsigned __int8)sub_416AF7((unsigned int)*(char *)(a3 + v12)) != 1 )\n    {\n      if ( v11 == a2 )\n        v4 = 0;\n      else\n        v4 = sub_40E88C(*(_BYTE *)(a1 + v11));\n      v10 = v4;\n      if ( v12 == a4 )\n        v5 = 0;\n      else\n        v5 = sub_40E88C(*(_BYTE *)(a3 + v12));\n      if ( v10 != v5 )\n        return (unsigned int)(v10 - v5);\n      ++v11;\n      ++v12;\n    }\n    while ( *(_BYTE *)(a1 + v11) == 48 )\n      ++v11;\n    while ( *(_BYTE *)(a3 + v12) == 48 )\n      ++v12;\n    while ( (unsigned __int8)sub_416AF7((unsigned int)*(char *)(a1 + v11))\n         && (unsigned __int8)sub_416AF7((unsigned int)*(char *)(a3 + v12)) )\n    {\n      if ( !v9 )\n        v9 = *(char *)(a1 + v11) - *(char *)(a3 + v12);\n      ++v11;\n      ++v12;\n    }\n    if ( (unsigned __int8)sub_416AF7((unsigned int)*(char *)(a1 + v11)) )\n      return 1LL;\n    if ( (unsigned __int8)sub_416AF7((unsigned int)*(char *)(a3 + v12)) )\n      return 0xFFFFFFFFLL;\n    if ( v9 )\n      return v9;\n  }\n  return 0LL;\n}\n"], [4254462, "sub_40EAFE", "__int64 __fastcall sub_40EAFE(const char *a1, const char *a2)\n{\n  __int64 result; // rax\n  _BYTE *v3; // rax\n  _BYTE *v4; // rax\n  __int64 s2; // [rsp+0h] [rbp-50h]\n  __int64 s1; // [rsp+8h] [rbp-48h]\n  unsigned int v7; // [rsp+18h] [rbp-38h]\n  unsigned int v8; // [rsp+1Ch] [rbp-34h]\n  _BYTE *v9; // [rsp+20h] [rbp-30h] BYREF\n  _BYTE *v10; // [rsp+28h] [rbp-28h] BYREF\n  size_t n; // [rsp+30h] [rbp-20h]\n  _BYTE *v12; // [rsp+38h] [rbp-18h]\n  _BYTE *v13; // [rsp+40h] [rbp-10h]\n  _BYTE *v14; // [rsp+48h] [rbp-8h]\n\n  s1 = (__int64)a1;\n  s2 = (__int64)a2;\n  v7 = strcmp(a1, a2);\n  if ( !v7 )\n    return 0LL;\n  if ( !*a1 )\n    return 0xFFFFFFFFLL;\n  if ( !*a2 )\n    return 1LL;\n  if ( !strcmp(\".\", a1) )\n    return 0xFFFFFFFFLL;\n  if ( !strcmp(\".\", a2) )\n    return 1LL;\n  if ( !strcmp(\"..\", a1) )\n    return 0xFFFFFFFFLL;\n  if ( !strcmp(\"..\", a2) )\n    return 1LL;\n  if ( *a1 == 46 && *a2 != 46 )\n    return 0xFFFFFFFFLL;\n  if ( *a1 != 46 && *a2 == 46 )\n    return 1LL;\n  if ( *a1 == 46 && *a2 == 46 )\n  {\n    s1 = (__int64)(a1 + 1);\n    s2 = (__int64)(a2 + 1);\n  }\n  v9 = (_BYTE *)s1;\n  v10 = (_BYTE *)s2;\n  v13 = sub_40E7B1(&v9);\n  v14 = sub_40E7B1(&v10);\n  if ( v13 )\n    v3 = v13;\n  else\n    v3 = v9;\n  n = (size_t)&v3[-s1];\n  if ( v14 )\n    v4 = v14;\n  else\n    v4 = v10;\n  v12 = &v4[-s2];\n  if ( (v13 || v14) && (_BYTE *)n == v12 && !strncmp((const char *)s1, (const char *)s2, n) )\n  {\n    n = (size_t)&v9[-s1];\n    v12 = &v10[-s2];\n  }\n  v8 = sub_40E8DC(s1, n, s2, (unsigned __int64)v12);\n  if ( v8 )\n    result = v8;\n  else\n    result = v7;\n  return result;\n}\n"], [4255030, "sub_40ED36", "FILE *__fastcall sub_40ED36(const char *a1, const char *a2)\n{\n  int v3; // [rsp+18h] [rbp-18h]\n  int fd; // [rsp+1Ch] [rbp-14h]\n  int v5; // [rsp+20h] [rbp-10h]\n  int v6; // [rsp+24h] [rbp-Ch]\n  FILE *stream; // [rsp+28h] [rbp-8h]\n\n  stream = fopen(a1, a2);\n  if ( !stream )\n    return stream;\n  v3 = fileno(stream);\n  if ( v3 < 0 || v3 > 2 )\n    return stream;\n  fd = sub_414585((unsigned int)v3);\n  if ( fd < 0 )\n  {\n    v5 = *__errno_location();\n    sub_415E9D(stream);\n    *__errno_location() = v5;\n    return 0LL;\n  }\n  if ( !(unsigned int)sub_415E9D(stream) )\n  {\n    stream = fdopen(fd, a2);\n    if ( stream )\n      return stream;\n  }\n  v6 = *__errno_location();\n  close(fd);\n  *__errno_location() = v6;\n  return 0LL;\n}\n"], [4255260, "sub_40EE1C", "__int64 __fastcall sub_40EE1C(int a1)\n{\n  unsigned __int8 v2; // [rsp+17h] [rbp-9h]\n  const char *s1; // [rsp+18h] [rbp-8h]\n\n  v2 = 1;\n  s1 = setlocale(a1, 0LL);\n  if ( s1 && (!strcmp(s1, \"C\") || !strcmp(s1, \"POSIX\")) )\n    v2 = 0;\n  return v2;\n}\n"], [4255353, "sub_40EE79", "__int64 __fastcall sub_40EE79(__int64 a1, char a2)\n{\n  return __ROR8__(a1, a2);\n}\n"], [4255381, "sub_40EE95", "__int64 __fastcall sub_40EE95(__int64 a1)\n{\n  return *(_QWORD *)(a1 + 16);\n}\n"], [4255399, "sub_40EEA7", "__int64 __fastcall sub_40EEA7(__int64 a1)\n{\n  return *(_QWORD *)(a1 + 24);\n}\n"], [4255417, "sub_40EEB9", "__int64 __fastcall sub_40EEB9(__int64 a1)\n{\n  return *(_QWORD *)(a1 + 32);\n}\n"], [4255435, "sub_40EECB", "unsigned __int64 __fastcall sub_40EECB(__int64 a1)\n{\n  _QWORD *i; // [rsp+8h] [rbp-20h]\n  unsigned __int64 v3; // [rsp+10h] [rbp-18h]\n  _QWORD *v4; // [rsp+18h] [rbp-10h]\n  unsigned __int64 j; // [rsp+20h] [rbp-8h]\n\n  v3 = 0LL;\n  for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      v4 = i;\n      for ( j = 1LL; ; ++j )\n      {\n        v4 = (_QWORD *)v4[1];\n        if ( !v4 )\n          break;\n      }\n      if ( j > v3 )\n        v3 = j;\n    }\n  }\n  return v3;\n}\n"], [4255561, "sub_40EF49", "_BOOL8 __fastcall sub_40EF49(__int64 a1)\n{\n  _QWORD *i; // [rsp+8h] [rbp-20h]\n  __int64 v3; // [rsp+10h] [rbp-18h]\n  __int64 v4; // [rsp+18h] [rbp-10h]\n  _QWORD *v5; // [rsp+20h] [rbp-8h]\n\n  v3 = 0LL;\n  v4 = 0LL;\n  for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      v5 = i;\n      ++v3;\n      ++v4;\n      while ( 1 )\n      {\n        v5 = (_QWORD *)v5[1];\n        if ( !v5 )\n          break;\n        ++v4;\n      }\n    }\n  }\n  return *(_QWORD *)(a1 + 24) == v3 && *(_QWORD *)(a1 + 32) == v4;\n}\n"], [4255715, "sub_40EFE3", "int __fastcall sub_40EFE3(__int64 a1, FILE *a2)\n{\n  double v2; // xmm0_8\n  double v3; // xmm1_8\n  double v4; // xmm0_8\n  __int64 v6; // [rsp+10h] [rbp-20h]\n  __int64 v7; // [rsp+18h] [rbp-18h]\n  __int64 v8; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v9; // [rsp+28h] [rbp-8h]\n\n  v6 = sub_40EEB9(a1);\n  v7 = sub_40EE95(a1);\n  v8 = sub_40EEA7(a1);\n  v9 = sub_40EECB(a1);\n  fprintf(a2, \"# entries:         %lu\\n\", v6);\n  fprintf(a2, \"# buckets:         %lu\\n\", v7);\n  if ( v8 < 0 )\n    v2 = (double)(int)(v8 & 1 | ((unsigned __int64)v8 >> 1)) + (double)(int)(v8 & 1 | ((unsigned __int64)v8 >> 1));\n  else\n    v2 = (double)(int)v8;\n  v3 = 100.0 * v2;\n  if ( v7 < 0 )\n    v4 = (double)(int)(v7 & 1 | ((unsigned __int64)v7 >> 1)) + (double)(int)(v7 & 1 | ((unsigned __int64)v7 >> 1));\n  else\n    v4 = (double)(int)v7;\n  fprintf(a2, \"# buckets used:    %lu (%.2f%%)\\n\", v8, v3 / v4);\n  return fprintf(a2, \"max bucket length: %lu\\n\", v9);\n}\n"], [4255995, "sub_40F0FB", "__int64 __fastcall sub_40F0FB(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 48))(a2, *(_QWORD *)(a1 + 16));\n  if ( *(_QWORD *)(a1 + 16) <= v3 )\n    abort();\n  return 16 * v3 + *(_QWORD *)a1;\n}\n"], [4256082, "sub_40F152", "__int64 __fastcall sub_40F152(__int64 a1, __int64 a2)\n{\n  _QWORD *i; // [rsp+10h] [rbp-10h]\n  _QWORD *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = (_QWORD *)sub_40F0FB(a1, a2);\n  if ( !*v4 )\n    return 0LL;\n  for ( i = v4; i; i = (_QWORD *)i[1] )\n  {\n    if ( *i == a2 || (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(a1 + 56))(a2, *i) )\n      return *i;\n  }\n  return 0LL;\n}\n"], [4256229, "sub_40F1E5", "__int64 __fastcall sub_40F1E5(unsigned __int64 *a1)\n{\n  unsigned __int64 i; // [rsp+18h] [rbp-8h]\n\n  if ( !a1[4] )\n    return 0LL;\n  for ( i = *a1; ; i += 16LL )\n  {\n    if ( a1[1] <= i )\n      abort();\n    if ( *(_QWORD *)i )\n      break;\n  }\n  return *(_QWORD *)i;\n}\n"], [4256321, "sub_40F241", "__int64 __fastcall sub_40F241(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v3; // [rsp+10h] [rbp-10h]\n  unsigned __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40F0FB(a1, a2);\n  v4 = v3;\n  do\n  {\n    if ( *(_QWORD *)v4 == a2 && *(_QWORD *)(v4 + 8) )\n      return **(_QWORD **)(v4 + 8);\n    v4 = *(_QWORD *)(v4 + 8);\n  }\n  while ( v4 );\n  while ( 1 )\n  {\n    v3 += 16LL;\n    if ( v3 >= *(_QWORD *)(a1 + 8) )\n      break;\n    if ( *(_QWORD *)v3 )\n      return *(_QWORD *)v3;\n  }\n  return 0LL;\n}\n"], [4256475, "sub_40F2DB", "unsigned __int64 __fastcall sub_40F2DB(__int64 a1, __int64 a2, unsigned __int64 a3)\n{\n  __int64 v4; // rax\n  unsigned __int64 v5; // [rsp+20h] [rbp-18h]\n  _QWORD *i; // [rsp+28h] [rbp-10h]\n  _QWORD *j; // [rsp+30h] [rbp-8h]\n\n  v5 = 0LL;\n  for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      for ( j = i; j; j = (_QWORD *)j[1] )\n      {\n        if ( v5 >= a3 )\n          return v5;\n        v4 = v5++;\n        *(_QWORD *)(a2 + 8 * v4) = *j;\n      }\n    }\n  }\n  return v5;\n}\n"], [4256631, "sub_40F377", "__int64 __fastcall sub_40F377(__int64 a1, unsigned __int8 (__fastcall *a2)(_QWORD, __int64), __int64 a3)\n{\n  __int64 v5; // [rsp+28h] [rbp-18h]\n  _QWORD *i; // [rsp+30h] [rbp-10h]\n  _QWORD *j; // [rsp+38h] [rbp-8h]\n\n  v5 = 0LL;\n  for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      for ( j = i; j; j = (_QWORD *)j[1] )\n      {\n        if ( a2(*j, a3) != 1 )\n          return v5;\n        ++v5;\n      }\n    }\n  }\n  return v5;\n}\n"], [4256779, "sub_40F40B", "unsigned __int64 __fastcall sub_40F40B(_BYTE *a1, unsigned __int64 a2)\n{\n  unsigned __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v4 = 0LL;\n  while ( *a1 )\n    v4 = (31 * v4 + (unsigned __int8)*a1++) % a2;\n  return v4;\n}\n"], [4256865, "sub_40F461", "bool __fastcall sub_40F461(unsigned __int64 a1)\n{\n  unsigned __int64 v2; // [rsp+8h] [rbp-10h]\n  unsigned __int64 v3; // [rsp+8h] [rbp-10h]\n  unsigned __int64 v4; // [rsp+10h] [rbp-8h]\n\n  v2 = 3LL;\n  v4 = 9LL;\n  while ( v4 < a1 && a1 % v2 )\n  {\n    v3 = v2 + 1;\n    v4 += 4 * v3;\n    v2 = v3 + 1;\n  }\n  return a1 % v2 != 0;\n}\n"], [4256973, "sub_40F4CD", "__int64 __fastcall sub_40F4CD(unsigned __int64 a1)\n{\n  __int64 v2; // [rsp+0h] [rbp-8h]\n  __int64 i; // [rsp+0h] [rbp-8h]\n\n  v2 = a1;\n  if ( a1 <= 9 )\n    v2 = 10LL;\n  for ( i = v2 | 1; i != -1 && !sub_40F461(i); i += 2LL )\n    ;\n  return i;\n}\n"], [4257044, "sub_40F514", "__int64 __fastcall sub_40F514(__int64 a1)\n{\n  __int64 result; // rax\n\n  *(_DWORD *)a1 = 0;\n  *(_DWORD *)(a1 + 4) = 1065353216;\n  *(_DWORD *)(a1 + 8) = 1061997773;\n  *(_DWORD *)(a1 + 12) = 1068826100;\n  result = a1;\n  *(_BYTE *)(a1 + 16) = 0;\n  return result;\n}\n"], [4257113, "sub_40F559", "unsigned __int64 __fastcall sub_40F559(__int64 a1, unsigned __int64 a2)\n{\n  return sub_40EE79(a1, 3) % a2;\n}\n"], [4257168, "sub_40F590", "bool __fastcall sub_40F590(__int64 a1, __int64 a2)\n{\n  return a1 == a2;\n}\n"], [4257193, "sub_40F5A9", "__int64 __fastcall sub_40F5A9(__int64 a1)\n{\n  __int64 v2; // [rsp+10h] [rbp-8h]\n\n  v2 = *(_QWORD *)(a1 + 40);\n  if ( (_UNKNOWN *)v2 == &unk_4192B0 )\n    return 1LL;\n  if ( *(float *)(v2 + 8) > 0.1\n    && (float)(1.0 - 0.1) > *(float *)(v2 + 8)\n    && *(float *)(v2 + 12) > (float)(0.1 + 1.0)\n    && *(float *)v2 >= 0.0\n    && *(float *)(v2 + 4) > (float)(*(float *)v2 + 0.1)\n    && *(float *)(v2 + 4) <= 1.0\n    && *(float *)(v2 + 8) > (float)(*(float *)v2 + 0.1) )\n  {\n    return 1LL;\n  }\n  *(_QWORD *)(a1 + 40) = &unk_4192B0;\n  return 0LL;\n}\n"], [4257441, "sub_40F6A1", "unsigned __int64 __fastcall sub_40F6A1(__int64 a1, __int64 a2)\n{\n  float v2; // xmm0_4\n  unsigned __int64 result; // rax\n  unsigned __int64 v4; // [rsp+8h] [rbp-18h]\n  unsigned __int64 v5; // [rsp+8h] [rbp-18h]\n  float v6; // [rsp+1Ch] [rbp-4h]\n\n  v4 = a1;\n  if ( *(_BYTE *)(a2 + 16) != 1 )\n  {\n    if ( a1 < 0 )\n      v2 = (float)(a1 & 1 | (unsigned int)((unsigned __int64)a1 >> 1))\n         + (float)(a1 & 1 | (unsigned int)((unsigned __int64)a1 >> 1));\n    else\n      v2 = (float)(int)a1;\n    v6 = v2 / *(float *)(a2 + 8);\n    if ( v6 >= 1.8446744e19 )\n      return 0LL;\n    if ( v6 >= 9.223372e18 )\n      v4 = (unsigned int)(int)(float)(v6 - 9.223372e18) ^ 0x8000000000000000LL;\n    else\n      v4 = (unsigned int)(int)v6;\n  }\n  v5 = sub_40F4CD(v4);\n  if ( v5 <= 0x1FFFFFFFFFFFFFFFLL )\n    result = v5;\n  else\n    result = 0LL;\n  return result;\n}\n"], [4257675, "sub_40F78B", "size_t *__fastcall sub_40F78B(__int64 a1, void *a2, unsigned __int64 (__fastcall *a3)(__int64 a1, unsigned __int64 a2), bool (__fastcall *a4)(__int64 a1, __int64 a2), size_t a5)\n{\n  size_t *result; // rax\n  bool (__fastcall *v7)(__int64, __int64); // [rsp+10h] [rbp-30h]\n  unsigned __int64 (__fastcall *v8)(__int64, unsigned __int64); // [rsp+18h] [rbp-28h]\n  void *v9; // [rsp+20h] [rbp-20h]\n  size_t *ptr; // [rsp+38h] [rbp-8h]\n\n  v9 = a2;\n  v8 = a3;\n  v7 = a4;\n  if ( !a3 )\n    v8 = sub_40F559;\n  if ( !a4 )\n    v7 = sub_40F590;\n  ptr = (size_t *)malloc(0x50uLL);\n  if ( !ptr )\n    return 0LL;\n  if ( !a2 )\n    v9 = &unk_4192B0;\n  ptr[5] = (size_t)v9;\n  if ( (unsigned __int8)sub_40F5A9((__int64)ptr) == 1\n    && (ptr[2] = sub_40F6A1(a1, (__int64)v9)) != 0\n    && (*ptr = (size_t)calloc(ptr[2], 0x10uLL)) != 0 )\n  {\n    ptr[1] = 16 * ptr[2] + *ptr;\n    ptr[3] = 0LL;\n    ptr[4] = 0LL;\n    ptr[6] = (size_t)v8;\n    ptr[7] = (size_t)v7;\n    ptr[8] = a5;\n    ptr[9] = 0LL;\n    result = ptr;\n  }\n  else\n  {\n    free(ptr);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4258032, "sub_40F8F0", "__int64 __fastcall sub_40F8F0(__int64 a1)\n{\n  __int64 result; // rax\n  _QWORD *i; // [rsp+18h] [rbp-18h]\n  _QWORD *j; // [rsp+20h] [rbp-10h]\n  _QWORD *v4; // [rsp+28h] [rbp-8h]\n\n  for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      for ( j = (_QWORD *)i[1]; j; j = v4 )\n      {\n        if ( *(_QWORD *)(a1 + 64) )\n          (*(void (__fastcall **)(_QWORD))(a1 + 64))(*j);\n        *j = 0LL;\n        v4 = (_QWORD *)j[1];\n        j[1] = *(_QWORD *)(a1 + 72);\n        *(_QWORD *)(a1 + 72) = j;\n      }\n      if ( *(_QWORD *)(a1 + 64) )\n        (*(void (__fastcall **)(_QWORD))(a1 + 64))(*i);\n      *i = 0LL;\n      i[1] = 0LL;\n    }\n  }\n  *(_QWORD *)(a1 + 24) = 0LL;\n  result = a1;\n  *(_QWORD *)(a1 + 32) = 0LL;\n  return result;\n}\n"], [4258294, "sub_40F9F6", "void __fastcall sub_40F9F6(__int64 a1)\n{\n  _QWORD *i; // [rsp+18h] [rbp-18h]\n  _QWORD *j; // [rsp+18h] [rbp-18h]\n  _QWORD *ptr; // [rsp+20h] [rbp-10h]\n  _QWORD *ptra; // [rsp+20h] [rbp-10h]\n  _QWORD *ptrb; // [rsp+20h] [rbp-10h]\n  _QWORD *v6; // [rsp+28h] [rbp-8h]\n  _QWORD *v7; // [rsp+28h] [rbp-8h]\n\n  if ( *(_QWORD *)(a1 + 64) && *(_QWORD *)(a1 + 32) )\n  {\n    for ( i = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)i; i += 2 )\n    {\n      if ( *i )\n      {\n        for ( ptr = i; ptr; ptr = (_QWORD *)ptr[1] )\n          (*(void (__fastcall **)(_QWORD))(a1 + 64))(*ptr);\n      }\n    }\n  }\n  for ( j = *(_QWORD **)a1; *(_QWORD *)(a1 + 8) > (unsigned __int64)j; j += 2 )\n  {\n    for ( ptra = (_QWORD *)j[1]; ptra; ptra = v6 )\n    {\n      v6 = (_QWORD *)ptra[1];\n      free(ptra);\n    }\n  }\n  for ( ptrb = *(_QWORD **)(a1 + 72); ptrb; ptrb = v7 )\n  {\n    v7 = (_QWORD *)ptrb[1];\n    free(ptrb);\n  }\n  free(*(void **)a1);\n  free((void *)a1);\n}\n"], [4258592, "sub_40FB20", "void *__fastcall sub_40FB20(__int64 a1)\n{\n  __int64 v2; // [rsp+18h] [rbp-8h]\n\n  if ( !*(_QWORD *)(a1 + 72) )\n    return malloc(0x10uLL);\n  v2 = *(_QWORD *)(a1 + 72);\n  *(_QWORD *)(a1 + 72) = *(_QWORD *)(v2 + 8);\n  return (void *)v2;\n}\n"], [4258667, "sub_40FB6B", "__int64 __fastcall sub_40FB6B(__int64 a1, _QWORD *a2)\n{\n  __int64 result; // rax\n\n  *a2 = 0LL;\n  a2[1] = *(_QWORD *)(a1 + 72);\n  result = a1;\n  *(_QWORD *)(a1 + 72) = a2;\n  return result;\n}\n"], [4258720, "sub_40FBA0", "__int64 __fastcall sub_40FBA0(__int64 a1, __int64 a2, _QWORD *a3, char a4)\n{\n  __int64 result; // rax\n  __int64 v5; // rdx\n  _QWORD *i; // [rsp+20h] [rbp-30h]\n  _QWORD *v9; // [rsp+28h] [rbp-28h]\n  __int64 v10; // [rsp+30h] [rbp-20h]\n  _QWORD *v11; // [rsp+38h] [rbp-18h]\n  __int64 v12; // [rsp+40h] [rbp-10h]\n  _QWORD *v13; // [rsp+48h] [rbp-8h]\n\n  v9 = (_QWORD *)sub_40F0FB(a1, a2);\n  *a3 = v9;\n  if ( !*v9 )\n    return 0LL;\n  if ( *v9 == a2 || (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(a1 + 56))(a2, *v9) )\n  {\n    v12 = *v9;\n    if ( a4 )\n    {\n      if ( v9[1] )\n      {\n        v13 = (_QWORD *)v9[1];\n        v5 = v13[1];\n        *v9 = *v13;\n        v9[1] = v5;\n        sub_40FB6B(a1, v13);\n      }\n      else\n      {\n        *v9 = 0LL;\n      }\n    }\n    result = v12;\n  }\n  else\n  {\n    for ( i = v9; ; i = (_QWORD *)i[1] )\n    {\n      if ( !i[1] )\n        return 0LL;\n      if ( *(_QWORD *)i[1] == a2 || (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))(a1 + 56))(a2, *(_QWORD *)i[1]) )\n        break;\n    }\n    v10 = *(_QWORD *)i[1];\n    if ( a4 )\n    {\n      v11 = (_QWORD *)i[1];\n      i[1] = v11[1];\n      sub_40FB6B(a1, v11);\n    }\n    result = v10;\n  }\n  return result;\n}\n"], [4259125, "sub_40FD35", "__int64 __fastcall sub_40FD35(__int64 a1, __int64 a2, char a3)\n{\n  __int64 *i; // [rsp+20h] [rbp-30h]\n  __int64 *j; // [rsp+28h] [rbp-28h]\n  __int64 v7; // [rsp+30h] [rbp-20h]\n  __int64 v8; // [rsp+30h] [rbp-20h]\n  _QWORD *v9; // [rsp+38h] [rbp-18h]\n  _QWORD *v10; // [rsp+38h] [rbp-18h]\n  __int64 *v11; // [rsp+40h] [rbp-10h]\n  _QWORD *v12; // [rsp+48h] [rbp-8h]\n\n  for ( i = *(__int64 **)a2; *(_QWORD *)(a2 + 8) > (unsigned __int64)i; i += 2 )\n  {\n    if ( *i )\n    {\n      for ( j = (__int64 *)i[1]; j; j = v11 )\n      {\n        v7 = *j;\n        v9 = (_QWORD *)sub_40F0FB(a1, *j);\n        v11 = (__int64 *)j[1];\n        if ( *v9 )\n        {\n          j[1] = v9[1];\n          v9[1] = j;\n        }\n        else\n        {\n          *v9 = v7;\n          ++*(_QWORD *)(a1 + 24);\n          sub_40FB6B(a1, j);\n        }\n      }\n      v8 = *i;\n      i[1] = 0LL;\n      if ( !a3 )\n      {\n        v10 = (_QWORD *)sub_40F0FB(a1, v8);\n        if ( *v10 )\n        {\n          v12 = sub_40FB20(a1);\n          if ( !v12 )\n            return 0LL;\n          *v12 = v8;\n          v12[1] = v10[1];\n          v10[1] = v12;\n        }\n        else\n        {\n          *v10 = v8;\n          ++*(_QWORD *)(a1 + 24);\n        }\n        *i = 0LL;\n        --*(_QWORD *)(a2 + 24);\n      }\n    }\n  }\n  return 1LL;\n}\n"], [4259587, "sub_40FF03", "__int64 __fastcall sub_40FF03(__int64 a1, __int64 a2)\n{\n  __int64 result; // rax\n  unsigned __int64 nmemb; // [rsp+10h] [rbp-60h]\n  void *v4; // [rsp+20h] [rbp-50h] BYREF\n  __int64 v5; // [rsp+28h] [rbp-48h]\n  unsigned __int64 v6; // [rsp+30h] [rbp-40h]\n  __int64 v7; // [rsp+38h] [rbp-38h]\n  __int64 v8; // [rsp+40h] [rbp-30h]\n  __int64 v9; // [rsp+48h] [rbp-28h]\n  __int64 v10; // [rsp+50h] [rbp-20h]\n  __int64 v11; // [rsp+58h] [rbp-18h]\n  __int64 v12; // [rsp+60h] [rbp-10h]\n  __int64 v13; // [rsp+68h] [rbp-8h]\n\n  nmemb = sub_40F6A1(a2, *(_QWORD *)(a1 + 40));\n  if ( !nmemb )\n    return 0LL;\n  if ( *(_QWORD *)(a1 + 16) == nmemb )\n    return 1LL;\n  v4 = calloc(nmemb, 0x10uLL);\n  if ( !v4 )\n    return 0LL;\n  v6 = nmemb;\n  v5 = (__int64)v4 + 16 * nmemb;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = *(_QWORD *)(a1 + 40);\n  v10 = *(_QWORD *)(a1 + 48);\n  v11 = *(_QWORD *)(a1 + 56);\n  v12 = *(_QWORD *)(a1 + 64);\n  v13 = *(_QWORD *)(a1 + 72);\n  if ( (unsigned __int8)sub_40FD35((__int64)&v4, a1, 0) )\n  {\n    free(*(void **)a1);\n    *(_QWORD *)a1 = v4;\n    *(_QWORD *)(a1 + 8) = v5;\n    *(_QWORD *)(a1 + 16) = v6;\n    *(_QWORD *)(a1 + 24) = v7;\n    *(_QWORD *)(a1 + 72) = v13;\n    result = 1LL;\n  }\n  else\n  {\n    *(_QWORD *)(a1 + 72) = v13;\n    if ( (unsigned __int8)sub_40FD35(a1, (__int64)&v4, 1) != 1 || (unsigned __int8)sub_40FD35(a1, (__int64)&v4, 0) != 1 )\n      abort();\n    free(v4);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4260103, "sub_410107", "__int64 __fastcall sub_410107(_QWORD *a1, __int64 a2, _QWORD *a3)\n{\n  __int64 result; // rax\n  __int64 v4; // rax\n  float v5; // xmm0_4\n  __int64 v6; // rdx\n  __int64 v7; // rax\n  float v8; // xmm1_4\n  __int64 v9; // rdx\n  __int64 v10; // rax\n  float v11; // xmm0_4\n  __int64 v12; // rdx\n  __int64 v13; // rax\n  float v14; // xmm1_4\n  __int64 v15; // rdx\n  __int64 v16; // rax\n  float v17; // xmm0_4\n  __int64 v18; // rdx\n  float v19; // xmm0_4\n  __int64 v20; // rax\n  float v21; // xmm0_4\n  __int64 v22; // rdx\n  __int64 v23; // rax\n  __int64 *v25; // [rsp+30h] [rbp-20h] BYREF\n  __int64 v26; // [rsp+38h] [rbp-18h]\n  __int64 v27; // [rsp+40h] [rbp-10h]\n  _QWORD *v28; // [rsp+48h] [rbp-8h]\n\n  if ( !a2 )\n    abort();\n  v26 = sub_40FBA0((__int64)a1, a2, &v25, 0);\n  if ( v26 )\n  {\n    if ( a3 )\n      *a3 = v26;\n    result = 0LL;\n  }\n  else\n  {\n    v4 = a1[3];\n    if ( v4 < 0 )\n    {\n      v6 = a1[3] & 1LL | ((unsigned __int64)v4 >> 1);\n      v5 = (float)(int)v6 + (float)(int)v6;\n    }\n    else\n    {\n      v5 = (float)(int)v4;\n    }\n    v7 = a1[2];\n    if ( v7 < 0 )\n    {\n      v9 = a1[2] & 1LL | ((unsigned __int64)v7 >> 1);\n      v8 = (float)(int)v9 + (float)(int)v9;\n    }\n    else\n    {\n      v8 = (float)(int)v7;\n    }\n    if ( v5 > (float)(v8 * *(float *)(a1[5] + 8LL)) )\n    {\n      sub_40F5A9((__int64)a1);\n      v10 = a1[3];\n      if ( v10 < 0 )\n      {\n        v12 = a1[3] & 1LL | ((unsigned __int64)v10 >> 1);\n        v11 = (float)(int)v12 + (float)(int)v12;\n      }\n      else\n      {\n        v11 = (float)(int)v10;\n      }\n      v13 = a1[2];\n      if ( v13 < 0 )\n      {\n        v15 = a1[2] & 1LL | ((unsigned __int64)v13 >> 1);\n        v14 = (float)(int)v15 + (float)(int)v15;\n      }\n      else\n      {\n        v14 = (float)(int)v13;\n      }\n      if ( v11 > (float)(v14 * *(float *)(a1[5] + 8LL)) )\n      {\n        v27 = a1[5];\n        if ( *(_BYTE *)(v27 + 16) )\n        {\n          v16 = a1[2];\n          if ( v16 < 0 )\n          {\n            v18 = a1[2] & 1LL | ((unsigned __int64)v16 >> 1);\n            v17 = (float)(int)v18 + (float)(int)v18;\n          }\n          else\n          {\n            v17 = (float)(int)v16;\n          }\n          v19 = v17 * *(float *)(v27 + 12);\n        }\n        else\n        {\n          v20 = a1[2];\n          if ( v20 < 0 )\n          {\n            v22 = a1[2] & 1LL | ((unsigned __int64)v20 >> 1);\n            v21 = (float)(int)v22 + (float)(int)v22;\n          }\n          else\n          {\n            v21 = (float)(int)v20;\n          }\n          v19 = (float)(v21 * *(float *)(v27 + 12)) * *(float *)(v27 + 8);\n        }\n        if ( v19 >= 1.8446744e19 )\n          return 0xFFFFFFFFLL;\n        if ( v19 >= 9.223372e18 )\n          v23 = (unsigned int)(int)(float)(v19 - 9.223372e18) ^ 0x8000000000000000LL;\n        else\n          v23 = (unsigned int)(int)v19;\n        if ( (unsigned __int8)sub_40FF03((__int64)a1, v23) != 1 )\n          return 0xFFFFFFFFLL;\n        if ( sub_40FBA0((__int64)a1, a2, &v25, 0) )\n          abort();\n      }\n    }\n    if ( *v25 )\n    {\n      v28 = sub_40FB20((__int64)a1);\n      if ( v28 )\n      {\n        *v28 = a2;\n        v28[1] = v25[1];\n        v25[1] = (__int64)v28;\n        ++a1[4];\n        result = 1LL;\n      }\n      else\n      {\n        result = 0xFFFFFFFFLL;\n      }\n    }\n    else\n    {\n      *v25 = a2;\n      ++a1[4];\n      ++a1[3];\n      result = 1LL;\n    }\n  }\n  return result;\n}\n"], [4260897, "sub_410421", "__int64 __fastcall sub_410421(_QWORD *a1, __int64 a2)\n{\n  int v3; // [rsp+14h] [rbp-Ch]\n  __int64 v4; // [rsp+18h] [rbp-8h] BYREF\n\n  v3 = sub_410107(a1, a2, &v4);\n  if ( v3 == -1 )\n    return 0LL;\n  if ( v3 )\n    return a2;\n  return v4;\n}\n"], [4260970, "sub_41046A", "__int64 __fastcall sub_41046A(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rax\n  float v4; // xmm0_4\n  __int64 v5; // rdx\n  __int64 v6; // rax\n  float v7; // xmm1_4\n  __int64 v8; // rdx\n  __int64 v9; // rax\n  float v10; // xmm0_4\n  __int64 v11; // rdx\n  __int64 v12; // rax\n  float v13; // xmm1_4\n  __int64 v14; // rdx\n  __int64 v15; // rax\n  float v16; // xmm0_4\n  __int64 v17; // rdx\n  float v18; // xmm0_4\n  __int64 v19; // rax\n  __int64 v20; // rax\n  float v21; // xmm0_4\n  __int64 v22; // rdx\n  float v23; // xmm0_4\n  _QWORD *v24; // [rsp+10h] [rbp-30h] BYREF\n  void *ptr; // [rsp+18h] [rbp-28h]\n  __int64 v26; // [rsp+20h] [rbp-20h]\n  __int64 v27; // [rsp+28h] [rbp-18h]\n  __int64 v28; // [rsp+30h] [rbp-10h]\n  void *v29; // [rsp+38h] [rbp-8h]\n\n  v26 = sub_40FBA0(a1, a2, &v24, 1);\n  if ( !v26 )\n    return 0LL;\n  --*(_QWORD *)(a1 + 32);\n  if ( !*v24 )\n  {\n    v3 = --*(_QWORD *)(a1 + 24);\n    if ( v3 < 0 )\n    {\n      v5 = *(_QWORD *)(a1 + 24) & 1LL | ((unsigned __int64)v3 >> 1);\n      v4 = (float)(int)v5 + (float)(int)v5;\n    }\n    else\n    {\n      v4 = (float)(int)v3;\n    }\n    v6 = *(_QWORD *)(a1 + 16);\n    if ( v6 < 0 )\n    {\n      v8 = *(_QWORD *)(a1 + 16) & 1LL | ((unsigned __int64)v6 >> 1);\n      v7 = (float)(int)v8 + (float)(int)v8;\n    }\n    else\n    {\n      v7 = (float)(int)v6;\n    }\n    if ( (float)(v7 * **(float **)(a1 + 40)) > v4 )\n    {\n      sub_40F5A9(a1);\n      v9 = *(_QWORD *)(a1 + 24);\n      if ( v9 < 0 )\n      {\n        v11 = *(_QWORD *)(a1 + 24) & 1LL | ((unsigned __int64)v9 >> 1);\n        v10 = (float)(int)v11 + (float)(int)v11;\n      }\n      else\n      {\n        v10 = (float)(int)v9;\n      }\n      v12 = *(_QWORD *)(a1 + 16);\n      if ( v12 < 0 )\n      {\n        v14 = *(_QWORD *)(a1 + 16) & 1LL | ((unsigned __int64)v12 >> 1);\n        v13 = (float)(int)v14 + (float)(int)v14;\n      }\n      else\n      {\n        v13 = (float)(int)v12;\n      }\n      if ( (float)(v13 * **(float **)(a1 + 40)) > v10 )\n      {\n        v27 = *(_QWORD *)(a1 + 40);\n        if ( *(_BYTE *)(v27 + 16) )\n        {\n          v15 = *(_QWORD *)(a1 + 16);\n          if ( v15 < 0 )\n          {\n            v17 = *(_QWORD *)(a1 + 16) & 1LL | ((unsigned __int64)v15 >> 1);\n            v16 = (float)(int)v17 + (float)(int)v17;\n          }\n          else\n          {\n            v16 = (float)(int)v15;\n          }\n          v18 = v16 * *(float *)(v27 + 4);\n          if ( v18 >= 9.223372e18 )\n            v19 = (unsigned int)(int)(float)(v18 - 9.223372e18) ^ 0x8000000000000000LL;\n          else\n            v19 = (unsigned int)(int)v18;\n        }\n        else\n        {\n          v20 = *(_QWORD *)(a1 + 16);\n          if ( v20 < 0 )\n          {\n            v22 = *(_QWORD *)(a1 + 16) & 1LL | ((unsigned __int64)v20 >> 1);\n            v21 = (float)(int)v22 + (float)(int)v22;\n          }\n          else\n          {\n            v21 = (float)(int)v20;\n          }\n          v23 = (float)(v21 * *(float *)(v27 + 4)) * *(float *)(v27 + 8);\n          if ( v23 >= 9.223372e18 )\n            v19 = (unsigned int)(int)(float)(v23 - 9.223372e18) ^ 0x8000000000000000LL;\n          else\n            v19 = (unsigned int)(int)v23;\n        }\n        v28 = v19;\n        if ( (unsigned __int8)sub_40FF03(a1, v19) != 1 )\n        {\n          for ( ptr = *(void **)(a1 + 72); ptr; ptr = v29 )\n          {\n            v29 = (void *)*((_QWORD *)ptr + 1);\n            free(ptr);\n          }\n          *(_QWORD *)(a1 + 72) = 0LL;\n        }\n      }\n    }\n  }\n  return v26;\n}\n"], [4261657, "sub_410719", "_QWORD *__fastcall sub_410719(__int64 (__fastcall *a1)(), __int64 a2)\n{\n  __int64 (__fastcall *v2)(); // rax\n  __int64 v4; // [rsp+0h] [rbp-20h]\n  _QWORD *v5; // [rsp+18h] [rbp-8h]\n\n  v4 = a2;\n  v5 = (_QWORD *)sub_414F92(32LL);\n  if ( !a2 )\n    v4 = 1LL;\n  *v5 = sub_414E49(v4, 8LL);\n  *(_QWORD *)*v5 = 0LL;\n  v5[1] = v4;\n  v5[2] = 0LL;\n  if ( a1 )\n    v2 = a1;\n  else\n    v2 = sub_4107A7;\n  v5[3] = v2;\n  return v5;\n}\n"], [4261799, "sub_4107A7", "__int64 sub_4107A7()\n{\n  return 0LL;\n}\n"], [4261818, "sub_4107BA", "void __fastcall sub_4107BA(void **a1)\n{\n  free(*a1);\n  free(a1);\n}\n"], [4261859, "sub_4107E3", "__int64 __fastcall sub_4107E3(_QWORD *a1, __int64 a2)\n{\n  __int64 v2; // rdx\n\n  if ( (unsigned __int64)(a1[1] - 1LL) <= a1[2] )\n    *a1 = sub_414ED3(*a1, a1 + 1, 8LL);\n  v2 = *a1;\n  ++a1[2];\n  *(_QWORD *)(8LL * a1[2] + v2) = a2;\n  sub_410A45(*a1, a1[2], a1[3]);\n  return 0LL;\n}\n"], [4262028, "sub_41088C", "__int64 __fastcall sub_41088C(_QWORD *a1)\n{\n  _QWORD *v2; // rsi\n  __int64 v3; // rdi\n  __int64 v4; // rax\n  __int64 v6; // [rsp+18h] [rbp-8h]\n\n  if ( !a1[2] )\n    return 0LL;\n  v6 = *(_QWORD *)(*a1 + 8LL);\n  v2 = (_QWORD *)(*a1 + 8LL);\n  v3 = *a1;\n  v4 = a1[2];\n  a1[2] = v4 - 1;\n  *v2 = *(_QWORD *)(v3 + 8 * v4);\n  sub_41091B(*a1, a1[2], 1LL, a1[3]);\n  return v6;\n}\n"], [4262171, "sub_41091B", "unsigned __int64 __fastcall sub_41091B(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, int (__fastcall *a4)(_QWORD, __int64))\n{\n  unsigned __int64 i; // [rsp+28h] [rbp-18h]\n  __int64 v7; // [rsp+30h] [rbp-10h]\n  __int64 v8; // [rsp+38h] [rbp-8h]\n\n  v8 = *(_QWORD *)(8 * a3 + a1);\n  for ( i = a3; a2 >> 1 >= i; i = v7 )\n  {\n    v7 = 2 * i;\n    if ( 2 * i < a2 && a4(*(_QWORD *)(16 * i + a1), *(_QWORD *)(8 * (2 * i + 1) + a1)) < 0 )\n      ++v7;\n    if ( a4(*(_QWORD *)(8 * v7 + a1), v8) <= 0 )\n      break;\n    *(_QWORD *)(a1 + 8 * i) = *(_QWORD *)(8 * v7 + a1);\n  }\n  *(_QWORD *)(a1 + 8 * i) = v8;\n  return i;\n}\n"], [4262469, "sub_410A45", "__int64 __fastcall sub_410A45(__int64 a1, unsigned __int64 a2, int (__fastcall *a3)(_QWORD, __int64))\n{\n  __int64 result; // rax\n  unsigned __int64 v5; // [rsp+20h] [rbp-10h]\n  __int64 v6; // [rsp+28h] [rbp-8h]\n\n  v5 = a2;\n  v6 = *(_QWORD *)(8 * a2 + a1);\n  while ( v5 != 1 && a3(*(_QWORD *)(8 * (v5 >> 1) + a1), v6) <= 0 )\n  {\n    *(_QWORD *)(a1 + 8 * v5) = *(_QWORD *)(8 * (v5 >> 1) + a1);\n    v5 >>= 1;\n  }\n  result = v6;\n  *(_QWORD *)(a1 + 8 * v5) = v6;\n  return result;\n}\n"], [4262663, "sub_410B07", "__int64 __fastcall sub_410B07(unsigned int a1, __int64 a2)\n{\n  __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v4 = a2 + 10;\n  *(_BYTE *)(a2 + 10) = 0;\n  do\n  {\n    *(_BYTE *)--v4 = a1 % 0xA + 48;\n    a1 /= 0xAu;\n  }\n  while ( a1 );\n  return v4;\n}\n"], [4262769, "sub_410B71", "__int64 __fastcall sub_410B71(unsigned __int64 a1, __int64 a2)\n{\n  __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v4 = a2 + 20;\n  *(_BYTE *)(a2 + 20) = 0;\n  do\n  {\n    *(_BYTE *)--v4 = a1 % 0xA + 48;\n    a1 /= 0xAuLL;\n  }\n  while ( a1 );\n  return v4;\n}\n"], [4262902, "sub_410BF6", "__int64 __fastcall sub_410BF6(const char *a1, unsigned int a2)\n{\n  size_t v2; // rax\n\n  v2 = strlen(a1);\n  return sub_410C28(a1, v2, a2);\n}\n"], [4262952, "sub_410C28", "__int64 __fastcall sub_410C28(char *a1, __int64 a2, char a3)\n{\n  int v3; // eax\n  char *v5; // rax\n  unsigned __int8 v7; // [rsp+2Bh] [rbp-45h]\n  wchar_t pwc; // [rsp+2Ch] [rbp-44h] BYREF\n  unsigned int v9; // [rsp+30h] [rbp-40h]\n  int v10; // [rsp+34h] [rbp-3Ch]\n  char *v11; // [rsp+38h] [rbp-38h]\n  size_t v12; // [rsp+40h] [rbp-30h]\n  char *v13; // [rsp+48h] [rbp-28h]\n  mbstate_t s[4]; // [rsp+50h] [rbp-20h] BYREF\n\n  s[1] = (mbstate_t)__readfsqword(0x28u);\n  v11 = a1;\n  v13 = &a1[a2];\n  v9 = 0;\n  if ( __ctype_get_mb_cur_max() <= 1 )\n  {\n    while ( 1 )\n    {\n      do\n      {\n        while ( 1 )\n        {\n          if ( v11 >= v13 )\n            return v9;\n          v5 = v11++;\n          v7 = *v5;\n          if ( ((*__ctype_b_loc())[v7] & 0x4000) == 0 )\n            break;\n          if ( v9 == 0x7FFFFFFF )\n            return 0x7FFFFFFFLL;\n          ++v9;\n        }\n        if ( (a3 & 2) != 0 )\n          return 0xFFFFFFFFLL;\n      }\n      while ( ((*__ctype_b_loc())[v7] & 2) != 0 );\n      if ( v9 == 0x7FFFFFFF )\n        return 0x7FFFFFFFLL;\n      ++v9;\n    }\n  }\n  while ( 1 )\n  {\nLABEL_31:\n    if ( v11 >= v13 )\n      return v9;\n    v3 = *v11;\n    if ( v3 > 63 )\n      break;\n    if ( v3 < 37 && (unsigned int)(v3 - 32) > 3 )\n      goto LABEL_11;\nLABEL_10:\n    ++v11;\n    ++v9;\n  }\n  if ( v3 >= 65 && (v3 <= 95 || (unsigned int)(v3 - 97) <= 0x1D) )\n    goto LABEL_10;\nLABEL_11:\n  memset(s, 0, 8uLL);\n  while ( 1 )\n  {\n    v12 = mbrtowc(&pwc, v11, v13 - v11, s);\n    if ( v12 == -1LL )\n    {\n      if ( (a3 & 1) == 0 )\n      {\n        ++v11;\n        ++v9;\n        goto LABEL_31;\n      }\n      return 0xFFFFFFFFLL;\n    }\n    if ( v12 == -2LL )\n      break;\n    if ( !v12 )\n      v12 = 1LL;\n    v10 = wcwidth(pwc);\n    if ( v10 < 0 )\n    {\n      if ( (a3 & 2) != 0 )\n        return 0xFFFFFFFFLL;\n      if ( !iswcntrl(pwc) )\n      {\n        if ( v9 == 0x7FFFFFFF )\n          return 0x7FFFFFFFLL;\n        ++v9;\n      }\n    }\n    else\n    {\n      if ( (int)(0x7FFFFFFF - v9) < v10 )\n        return 0x7FFFFFFFLL;\n      v9 += v10;\n    }\n    v11 += v12;\n    if ( mbsinit(s) )\n      goto LABEL_31;\n  }\n  if ( (a3 & 1) == 0 )\n  {\n    v11 = v13;\n    ++v9;\n    goto LABEL_31;\n  }\n  return 0xFFFFFFFFLL;\n}\n"], [4263604, "sub_410EB4", "__int64 sub_410EB4()\n{\n  __int64 result; // rax\n  cpu_set_t cpuset; // [rsp+10h] [rbp-80h] BYREF\n\n  if ( sched_getaffinity(0, 0x80uLL, &cpuset) || (LODWORD(result) = __sched_cpucount(0x80uLL, &cpuset), !(_DWORD)result) )\n    result = 0LL;\n  else\n    result = (int)result;\n  return result;\n}\n"], [4263693, "sub_410F0D", "__int64 __fastcall sub_410F0D(int a1)\n{\n  __int64 result; // rax\n  int v2; // [rsp+Ch] [rbp-44h]\n  char *endptr; // [rsp+18h] [rbp-38h] BYREF\n  char *nptr; // [rsp+20h] [rbp-30h]\n  __int64 v5; // [rsp+28h] [rbp-28h]\n  unsigned __int64 v6; // [rsp+30h] [rbp-20h]\n  __int64 v7; // [rsp+38h] [rbp-18h]\n  __int64 v8; // [rsp+40h] [rbp-10h]\n  __int64 v9; // [rsp+48h] [rbp-8h]\n\n  v2 = a1;\n  if ( a1 == 2 )\n  {\n    nptr = getenv(\"OMP_NUM_THREADS\");\n    if ( nptr )\n    {\n      while ( *nptr && (unsigned __int8)sub_416BCD((unsigned int)*nptr) )\n        ++nptr;\n      if ( (unsigned __int8)sub_416AF7((unsigned int)*nptr) )\n      {\n        endptr = 0LL;\n        v6 = strtoul(nptr, &endptr, 10);\n        if ( endptr )\n        {\n          while ( *endptr && (unsigned __int8)sub_416BCD((unsigned int)*endptr) )\n            ++endptr;\n          if ( !*endptr )\n          {\n            if ( v6 )\n              result = v6;\n            else\n              result = 1LL;\n            return result;\n          }\n        }\n      }\n    }\n    v2 = 1;\n  }\n  if ( v2 == 1 )\n  {\n    v7 = sub_410EB4();\n    if ( v7 )\n      return v7;\n    v8 = sysconf(84);\n    if ( v8 > 0 )\n      return v8;\n  }\n  else\n  {\n    v5 = sysconf(83);\n    if ( v5 == 1 )\n    {\n      v9 = sub_410EB4();\n      if ( v9 )\n        v5 = v9;\n    }\n    if ( v5 > 0 )\n      return v5;\n  }\n  return 1LL;\n}\n"], [4264053, "sub_411075", "double sub_411075()\n{\n  double v0; // rax\n  double v2; // [rsp+10h] [rbp-10h]\n  double v3; // [rsp+18h] [rbp-8h]\n\n  v2 = (double)(int)sysconf(85);\n  v3 = (double)(int)sysconf(30);\n  if ( v2 < 0.0 || v3 < 0.0 )\n    v0 = 67108864.0;\n  else\n    v0 = v2 * v3;\n  return v0;\n}\n"], [4264173, "sub_4110ED", "__int64 sub_4110ED()\n{\n  double v0; // xmm0_8\n  double v2; // [rsp+10h] [rbp-10h]\n  double v3; // [rsp+18h] [rbp-8h]\n\n  v2 = (double)(int)sysconf(86);\n  v3 = (double)(int)sysconf(30);\n  if ( v2 < 0.0 || v3 < 0.0 )\n    v0 = sub_411075() / 4.0;\n  else\n    v0 = v2 * v3;\n  return *(_QWORD *)&v0;\n}\n"], [4264300, "sub_41116C", "__int64 sub_41116C()\n{\n  __int64 result; // rax\n  char *endptr; // [rsp+0h] [rbp-20h] BYREF\n  __int64 v2; // [rsp+8h] [rbp-18h]\n  char *nptr; // [rsp+10h] [rbp-10h]\n  __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v2 = 200809LL;\n  nptr = getenv(\"_POSIX2_VERSION\");\n  if ( nptr )\n  {\n    if ( *nptr )\n    {\n      v4 = strtol(nptr, &endptr, 10);\n      if ( !*endptr )\n        v2 = v4;\n    }\n  }\n  if ( v2 < (__int64)0xFFFFFFFF80000000LL )\n    return 0x80000000LL;\n  result = 0x7FFFFFFFLL;\n  if ( v2 <= 0x7FFFFFFF )\n    result = v2;\n  return result;\n}\n"], [4264432, "sub_4111F0", "char *__fastcall sub_4111F0(const char *a1)\n{\n  char *v1; // rax\n  char *result; // rax\n  char *s; // [rsp+8h] [rbp-18h]\n  char *v4; // [rsp+10h] [rbp-10h]\n  char *s1; // [rsp+18h] [rbp-8h]\n\n  s = (char *)a1;\n  if ( !a1 )\n  {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\", 1uLL, 0x37uLL, stderr);\n    abort();\n  }\n  v4 = strrchr(a1, 47);\n  if ( v4 )\n    v1 = v4 + 1;\n  else\n    v1 = (char *)a1;\n  s1 = v1;\n  if ( v1 - a1 > 6 && !strncmp(v1 - 7, \"/.libs/\", 7uLL) )\n  {\n    s = s1;\n    if ( !strncmp(s1, \"lt-\", 3uLL) )\n    {\n      s = s1 + 3;\n      program_invocation_short_name = (__int64)(s1 + 3);\n    }\n  }\n  qword_61DBB0 = (__int64)s;\n  result = s;\n  program_invocation_name = (__int64)s;\n  return result;\n}\n"], [4264663, "sub_4112D7", "__int64 __fastcall sub_4112D7(unsigned int a1, __int64 a2)\n{\n  return sub_412786(a1, 6LL, a2);\n}\n"], [4264699, "sub_4112FB", "__int64 __fastcall sub_4112FB(__int64 a1)\n{\n  return sub_4112D7(0, a1);\n}\n"], [4264730, "sub_41131A", "__int64 __fastcall sub_41131A(__int64 *a1)\n{\n  __int64 *v1; // rax\n  int v3; // [rsp+14h] [rbp-Ch]\n  __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v3 = *__errno_location();\n  if ( a1 )\n    v1 = a1;\n  else\n    v1 = &qword_61DBC0;\n  v4 = sub_4150B6(v1, 56LL);\n  *__errno_location() = v3;\n  return v4;\n}\n"], [4264803, "sub_411363", "__int64 __fastcall sub_411363(__int64 *a1)\n{\n  __int64 *v1; // rax\n\n  if ( a1 )\n    v1 = a1;\n  else\n    v1 = &qword_61DBC0;\n  return *(unsigned int *)v1;\n}\n"], [4264833, "sub_411381", "__int64 *__fastcall sub_411381(__int64 *a1, int a2)\n{\n  __int64 *result; // rax\n\n  if ( a1 )\n    result = a1;\n  else\n    result = &qword_61DBC0;\n  *(_DWORD *)result = a2;\n  return result;\n}\n"], [4264869, "sub_4113A5", "__int64 __fastcall sub_4113A5(__int64 *a1, unsigned __int8 a2, char a3)\n{\n  __int64 *v3; // rax\n  unsigned int v5; // [rsp+24h] [rbp-Ch]\n\n  if ( a1 )\n    v3 = a1;\n  else\n    v3 = &qword_61DBC0;\n  v5 = (*((_DWORD *)v3 + (a2 >> 5) + 2) >> (a2 & 0x1F)) & 1;\n  *((_DWORD *)v3 + (a2 >> 5) + 2) ^= (v5 ^ a3 & 1) << (a2 & 0x1F);\n  return v5;\n}\n"], [4265005, "sub_41142D", "__int64 __fastcall sub_41142D(__int64 *a1, int a2)\n{\n  __int64 *v3; // [rsp+4h] [rbp-18h]\n  unsigned int v4; // [rsp+18h] [rbp-4h]\n\n  v3 = a1;\n  if ( !a1 )\n    v3 = &qword_61DBC0;\n  v4 = *((_DWORD *)v3 + 1);\n  *((_DWORD *)v3 + 1) = a2;\n  return v4;\n}\n"], [4265056, "sub_411460", "__int64 *__fastcall sub_411460(__int64 *a1, __int64 a2, __int64 a3)\n{\n  __int64 *result; // rax\n  __int64 *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = a1;\n  if ( !a1 )\n    v4 = &qword_61DBC0;\n  *(_DWORD *)v4 = 8;\n  if ( !a2 || !a3 )\n    abort();\n  v4[5] = a2;\n  result = v4;\n  v4[6] = a3;\n  return result;\n}\n"], [4265146, "sub_4114BA", "_QWORD *__fastcall sub_4114BA(_QWORD *a1, int a2)\n{\n  __int64 v3[7]; // [rsp+10h] [rbp-40h] BYREF\n\n  memset(v3, 0, sizeof(v3));\n  if ( a2 == 8 )\n    abort();\n  LODWORD(v3[0]) = a2;\n  *a1 = v3[0];\n  a1[1] = v3[1];\n  a1[2] = v3[2];\n  a1[3] = v3[3];\n  a1[4] = v3[4];\n  a1[5] = v3[5];\n  a1[6] = v3[6];\n  return a1;\n}\n"], [4265266, "sub_411532", "char *__fastcall sub_411532(const char *a1, int a2)\n{\n  char *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = gettext(a1);\n  if ( v3 == a1 && a2 == 7 )\n    v3 = (char *)asc_4194A0;\n  return v3;\n}\n"], [4265327, "sub_41156F", "unsigned __int64 __fastcall sub_41156F(__int64 a1, unsigned __int64 a2, __int64 a3, size_t a4, unsigned int a5, int a6, __int64 a7, char *a8, char *a9)\n{\n  int v9; // eax\n  bool v10; // al\n  int v11; // eax\n  char v20; // [rsp+65h] [rbp-6Bh]\n  bool v21; // [rsp+66h] [rbp-6Ah]\n  unsigned __int8 v22; // [rsp+67h] [rbp-69h]\n  char v23; // [rsp+68h] [rbp-68h]\n  char v24; // [rsp+69h] [rbp-67h]\n  bool v25; // [rsp+6Ah] [rbp-66h]\n  bool v26; // [rsp+6Bh] [rbp-65h]\n  wchar_t pwc; // [rsp+6Ch] [rbp-64h] BYREF\n  __int64 i; // [rsp+70h] [rbp-60h]\n  unsigned __int64 v29; // [rsp+78h] [rbp-58h]\n  char *s; // [rsp+80h] [rbp-50h]\n  size_t n; // [rsp+88h] [rbp-48h]\n  unsigned __int64 v32; // [rsp+90h] [rbp-40h]\n  unsigned __int64 j; // [rsp+98h] [rbp-38h]\n  size_t v34; // [rsp+A0h] [rbp-30h]\n  unsigned __int64 v35; // [rsp+A8h] [rbp-28h]\n  mbstate_t p; // [rsp+B0h] [rbp-20h] BYREF\n  unsigned __int64 v37; // [rsp+B8h] [rbp-18h]\n\n  v37 = __readfsqword(0x28u);\n  v29 = 0LL;\n  s = 0LL;\n  n = 0LL;\n  v20 = 0;\n  v26 = __ctype_get_mb_cur_max() == 1;\n  v21 = (a6 & 2) != 0;\n  if ( a5 == 3 )\n    goto LABEL_11;\n  if ( a5 > 3 )\n  {\n    if ( a5 == 5 )\n    {\n      v20 = 1;\n      v21 = 0;\n      goto LABEL_33;\n    }\n    if ( a5 >= 5 )\n    {\n      if ( a5 > 8 )\n        abort();\n      if ( a5 != 8 )\n      {\n        a8 = sub_411532((const char *)&asc_4194A0[1], a5);\n        a9 = sub_411532((const char *)&asc_4194A0[2], a5);\n      }\n      if ( (a6 & 2) == 0 )\n      {\n        for ( s = a8; *s; ++s )\n        {\n          if ( v29 < a2 )\n            *(_BYTE *)(v29 + a1) = *s;\n          ++v29;\n        }\n      }\n      v20 = 1;\n      s = a9;\n      n = strlen(a9);\n      goto LABEL_33;\n    }\n    a5 = 3;\n    v21 = 1;\nLABEL_11:\n    if ( !v21 )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(a1 + v29) = 34;\n      ++v29;\n    }\n    v20 = 1;\n    s = (char *)asc_4194A0;\n    n = 1LL;\n    goto LABEL_33;\n  }\n  if ( a5 == 1 )\n  {\n    a5 = 2;\n    v21 = 1;\n    goto LABEL_27;\n  }\n  if ( a5 > 1 )\n  {\nLABEL_27:\n    if ( !v21 )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(a1 + v29) = 39;\n      ++v29;\n    }\n    s = (_BYTE *)(asc_4194A0 + 4);\n    n = 1LL;\n    goto LABEL_33;\n  }\n  v21 = 0;\nLABEL_33:\n  for ( i = 0LL; a4 == -1LL ? *(_BYTE *)(a3 + i) != 0 : i != a4; ++i )\n  {\n    v24 = 0;\n    if ( v20 && n && i + n <= a4 && !memcmp((const void *)(a3 + i), s, n) )\n    {\n      if ( v21 )\n        return sub_41156F(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n      v24 = 1;\n    }\n    v22 = *(_BYTE *)(a3 + i);\n    if ( v22 > 0x3Au )\n    {\n      if ( v22 == 94 )\n        goto LABEL_144;\n      if ( v22 > 0x5Eu )\n      {\n        if ( v22 <= 0x7Au )\n        {\n          if ( v22 >= 0x61u || v22 == 95 )\n            goto LABEL_206;\n          goto LABEL_144;\n        }\n        if ( v22 != 124 )\n        {\n          if ( v22 < 0x7Cu || v22 == 125 )\n          {\n            if ( a4 == -1LL )\n              v10 = *(_BYTE *)(a3 + 1) != 0;\n            else\n              v10 = a4 != 1;\n            if ( v10 )\n              goto LABEL_206;\n          }\n          else if ( v22 != 126 )\n          {\nLABEL_157:\n            if ( v26 )\n            {\n              v32 = 1LL;\n              v25 = ((*__ctype_b_loc())[v22] & 0x4000) != 0;\n            }\n            else\n            {\n              memset(&p, 0, sizeof(p));\n              v32 = 0LL;\n              v25 = 1;\n              if ( a4 == -1LL )\n                a4 = strlen((const char *)a3);\n              do\n              {\n                v34 = mbrtowc(&pwc, (const char *)(v32 + i + a3), a4 - (v32 + i), &p);\n                if ( !v34 )\n                  break;\n                if ( v34 == -1LL )\n                {\n                  v25 = 0;\n                  break;\n                }\n                if ( v34 == -2LL )\n                {\n                  v25 = 0;\n                  while ( i + v32 < a4 && *(_BYTE *)(v32 + i + a3) )\n                    ++v32;\n                  break;\n                }\n                if ( v21 && a5 == 2 )\n                {\n                  for ( j = 1LL; j < v34; ++j )\n                  {\n                    v11 = *(char *)(j + v32 + i + a3);\n                    if ( v11 == 94 )\n                      return sub_41156F(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    if ( v11 > 94 )\n                    {\n                      if ( v11 == 96 || v11 == 124 )\n                        return sub_41156F(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    }\n                    else if ( (unsigned int)(v11 - 91) <= 1 )\n                    {\n                      return sub_41156F(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                    }\n                  }\n                }\n                if ( !iswprint(pwc) )\n                  v25 = 0;\n                v32 += v34;\n              }\n              while ( !mbsinit(&p) );\n            }\n            if ( v32 > 1 || v20 && !v25 )\n            {\n              v35 = i + v32;\n              while ( 1 )\n              {\n                if ( v20 && !v25 )\n                {\n                  if ( v21 )\n                    return sub_41156F(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                  if ( v29 < a2 )\n                    *(_BYTE *)(a1 + v29) = 92;\n                  if ( ++v29 < a2 )\n                    *(_BYTE *)(v29 + a1) = (v22 >> 6) + 48;\n                  if ( ++v29 < a2 )\n                    *(_BYTE *)(v29 + a1) = ((v22 >> 3) & 7) + 48;\n                  ++v29;\n                  v22 = (v22 & 7) + 48;\n                }\n                else if ( v24 )\n                {\n                  if ( v29 < a2 )\n                    *(_BYTE *)(a1 + v29) = 92;\n                  ++v29;\n                  v24 = 0;\n                }\n                if ( i + 1 >= v35 )\n                  break;\n                if ( v29 < a2 )\n                  *(_BYTE *)(v29 + a1) = v22;\n                ++v29;\n                ++i;\n                v22 = *(_BYTE *)(a3 + i);\n              }\n              goto LABEL_215;\n            }\n            goto LABEL_206;\n          }\n          goto LABEL_143;\n        }\nLABEL_144:\n        if ( a5 == 2 && v21 )\n          return sub_41156F(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        goto LABEL_206;\n      }\n      if ( v22 > 0x5Au )\n      {\n        if ( v22 == 92 )\n        {\n          v23 = *(_BYTE *)(a3 + i);\n          if ( v20 && v21 && n )\n            goto LABEL_215;\n          goto LABEL_134;\n        }\n        if ( v22 <= 0x5Cu )\n          goto LABEL_144;\n      }\n      else\n      {\n        if ( v22 >= 0x41u )\n          goto LABEL_206;\n        if ( v22 <= 0x3Eu )\n          goto LABEL_144;\n        if ( v22 != 63 )\n          goto LABEL_157;\n        if ( a5 == 2 )\n        {\n          if ( v21 )\n            return sub_41156F(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        }\n        else if ( a5 == 3 && (a6 & 4) != 0 && i + 2 < a4 && *(_BYTE *)(i + 1 + a3) == 63 )\n        {\n          v9 = *(char *)(i + 2 + a3);\n          if ( v9 != 45 )\n          {\n            if ( v9 > 45 )\n            {\n              if ( v9 != 47 && (v9 < 47 || (unsigned int)(v9 - 60) > 2) )\n                goto LABEL_206;\n            }\n            else if ( v9 != 33 && (v9 < 33 || (unsigned int)(v9 - 39) > 2) )\n            {\n              goto LABEL_206;\n            }\n          }\n          if ( v21 )\n            return sub_41156F(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          v22 = *(_BYTE *)(i + 2 + a3);\n          i += 2LL;\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 63;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 34;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 34;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 63;\n          ++v29;\n        }\n      }\n    }\n    else\n    {\n      if ( v22 >= 0x2Bu )\n        goto LABEL_206;\n      if ( v22 > 0x22u )\n      {\n        if ( v22 != 38 )\n        {\n          if ( v22 > 0x26u )\n          {\n            if ( v22 == 39 )\n            {\n              if ( a5 == 2 )\n              {\n                if ( v21 )\n                  return sub_41156F(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n                if ( v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 39;\n                if ( ++v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 92;\n                if ( ++v29 < a2 )\n                  *(_BYTE *)(a1 + v29) = 39;\n                ++v29;\n              }\n              goto LABEL_206;\n            }\n            goto LABEL_144;\n          }\n          if ( v22 != 36 )\n          {\n            if ( v22 > 0x24u )\n              goto LABEL_206;\nLABEL_143:\n            if ( i )\n              goto LABEL_206;\n          }\n        }\n        goto LABEL_144;\n      }\n      if ( v22 >= 0x20u )\n        goto LABEL_144;\n      if ( v22 == 9 )\n      {\n        v23 = 116;\n        goto LABEL_134;\n      }\n      if ( v22 > 9u )\n      {\n        if ( v22 == 11 )\n        {\n          v23 = 118;\n        }\n        else\n        {\n          if ( v22 < 0xBu )\n          {\n            v23 = 110;\n            goto LABEL_134;\n          }\n          if ( v22 == 12 )\n          {\n            v23 = 102;\n          }\n          else\n          {\n            if ( v22 != 13 )\n              goto LABEL_157;\n            v23 = 114;\nLABEL_134:\n            if ( a5 == 2 && v21 )\n              return sub_41156F(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          }\n        }\nLABEL_136:\n        if ( v20 )\n        {\n          v22 = v23;\nLABEL_211:\n          if ( v21 )\n            return sub_41156F(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 92;\n          ++v29;\n          goto LABEL_215;\n        }\n        goto LABEL_206;\n      }\n      if ( v22 == 7 )\n      {\n        v23 = 97;\n        goto LABEL_136;\n      }\n      if ( v22 > 7u )\n      {\n        v23 = 98;\n        goto LABEL_136;\n      }\n      if ( v22 )\n        goto LABEL_157;\n      if ( v20 )\n      {\n        if ( v21 )\n          return sub_41156F(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n        if ( v29 < a2 )\n          *(_BYTE *)(a1 + v29) = 92;\n        ++v29;\n        if ( i + 1 < a4 && *(char *)(i + 1 + a3) > 47 && *(char *)(i + 1 + a3) <= 57 )\n        {\n          if ( v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 48;\n          if ( ++v29 < a2 )\n            *(_BYTE *)(a1 + v29) = 48;\n          ++v29;\n        }\n        v22 = 48;\n      }\n      else if ( (a6 & 1) != 0 )\n      {\n        continue;\n      }\n    }\nLABEL_206:\n    if ( (v20 == 1 || v21) && a7 && (*(_DWORD *)(4LL * (v22 >> 5) + a7) & (1 << (v22 & 0x1F))) != 0 || v24 == 1 )\n      goto LABEL_211;\nLABEL_215:\n    if ( v29 < a2 )\n      *(_BYTE *)(v29 + a1) = v22;\n    ++v29;\n  }\n  if ( !v29 && a5 == 2 && v21 )\n    return sub_41156F(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, (__int64)a8, (__int64)a9);\n  if ( s && !v21 )\n  {\n    while ( *s )\n    {\n      if ( v29 < a2 )\n        *(_BYTE *)(v29 + a1) = *s;\n      ++v29;\n      ++s;\n    }\n  }\n  if ( v29 < a2 )\n    *(_BYTE *)(a1 + v29) = 0;\n  return v29;\n}\n"], [4268474, "sub_4121BA", "unsigned __int64 __fastcall sub_4121BA(__int64 a1, unsigned __int64 a2, __int64 a3, size_t a4, __int64 *a5)\n{\n  __int64 *v5; // rax\n  int v9; // [rsp+4Ch] [rbp-14h]\n  __int64 *v10; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+58h] [rbp-8h]\n\n  if ( a5 )\n    v5 = a5;\n  else\n    v5 = &qword_61DBC0;\n  v10 = v5;\n  v9 = *__errno_location();\n  v11 = sub_41156F(\n          a1,\n          a2,\n          a3,\n          a4,\n          *(_DWORD *)v10,\n          *((_DWORD *)v10 + 1),\n          (__int64)(v10 + 1),\n          (char *)v10[5],\n          (char *)v10[6]);\n  *__errno_location() = v9;\n  return v11;\n}\n"], [4268634, "sub_41225A", "__int64 __fastcall sub_41225A(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_41228C(a1, a2, 0LL, a3);\n}\n"], [4268684, "sub_41228C", "__int64 __fastcall sub_41228C(__int64 a1, size_t a2, _QWORD *a3, __int64 *a4)\n{\n  __int64 *v4; // rax\n  int v7; // [rsp+40h] [rbp-20h]\n  int v8; // [rsp+44h] [rbp-1Ch]\n  __int64 *v9; // [rsp+48h] [rbp-18h]\n  unsigned __int64 v10; // [rsp+50h] [rbp-10h]\n  __int64 v11; // [rsp+58h] [rbp-8h]\n\n  if ( a4 )\n    v4 = a4;\n  else\n    v4 = &qword_61DBC0;\n  v9 = v4;\n  v7 = *__errno_location();\n  v8 = *((_DWORD *)v9 + 1) | (a3 == 0LL);\n  v10 = sub_41156F(0LL, 0LL, a1, a2, *(_DWORD *)v9, v8, (__int64)(v9 + 1), (char *)v9[5], (char *)v9[6]) + 1;\n  v11 = sub_414F78(v10);\n  sub_41156F(v11, v10, a1, a2, *(_DWORD *)v9, v8, (__int64)(v9 + 1), (char *)v9[5], (char *)v9[6]);\n  *__errno_location() = v7;\n  if ( a3 )\n    *a3 = v10 - 1;\n  return v11;\n}\n"], [4268984, "sub_4123B8", "void sub_4123B8()\n{\n  unsigned int i; // [rsp+4h] [rbp-Ch]\n  void **ptr; // [rsp+8h] [rbp-8h]\n\n  ptr = (void **)off_61D550;\n  for ( i = 1; i < dword_61D530; ++i )\n    free(ptr[2 * i + 1]);\n  if ( ptr[1] != &unk_61DC00 )\n  {\n    free(ptr[1]);\n    qword_61D540 = 256LL;\n    off_61D548 = &unk_61DC00;\n  }\n  if ( ptr != (void **)&qword_61D540 )\n  {\n    free(ptr);\n    off_61D550 = &qword_61D540;\n  }\n  dword_61D530 = 1;\n}\n"], [4269155, "sub_412463", "void *__fastcall sub_412463(int a1, __int64 a2, size_t a3, __int64 a4)\n{\n  __int64 *v4; // rax\n  void *v5; // rdx\n  bool v9; // [rsp+4Bh] [rbp-45h]\n  int v10; // [rsp+4Ch] [rbp-44h]\n  int v11; // [rsp+54h] [rbp-3Ch]\n  __int64 *v12; // [rsp+58h] [rbp-38h]\n  void *ptr; // [rsp+60h] [rbp-30h]\n  __int64 v14; // [rsp+68h] [rbp-28h]\n  unsigned __int64 v15; // [rsp+70h] [rbp-20h]\n  unsigned __int64 v16; // [rsp+70h] [rbp-20h]\n  unsigned __int64 v17; // [rsp+78h] [rbp-18h]\n\n  v10 = *__errno_location();\n  v12 = off_61D550;\n  if ( a1 < 0 )\n    abort();\n  if ( dword_61D530 <= (unsigned int)a1 )\n  {\n    v14 = (unsigned int)(a1 + 1);\n    v9 = off_61D550 == &qword_61D540;\n    if ( off_61D550 == &qword_61D540 )\n      v4 = 0LL;\n    else\n      v4 = off_61D550;\n    v12 = (__int64 *)sub_414FC7(v4, 16 * v14);\n    off_61D550 = v12;\n    if ( v9 )\n    {\n      v5 = off_61D548;\n      *v12 = qword_61D540;\n      v12[1] = (__int64)v5;\n    }\n    memset(&v12[2 * (unsigned int)dword_61D530], 0, 16 * (v14 - (unsigned int)dword_61D530));\n    dword_61D530 = a1 + 1;\n  }\n  v15 = v12[2 * a1];\n  ptr = (void *)v12[2 * a1 + 1];\n  v11 = *(_DWORD *)(a4 + 4) | 1;\n  v17 = sub_41156F((__int64)ptr, v15, a2, a3, *(_DWORD *)a4, v11, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 48));\n  if ( v15 <= v17 )\n  {\n    v16 = v17 + 1;\n    v12[2 * a1] = v17 + 1;\n    if ( ptr != &unk_61DC00 )\n      free(ptr);\n    ptr = (void *)sub_414F78(v16);\n    v12[2 * a1 + 1] = (__int64)ptr;\n    sub_41156F((__int64)ptr, v16, a2, a3, *(_DWORD *)a4, v11, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 48));\n  }\n  *__errno_location() = v10;\n  return ptr;\n}\n"], [4269801, "sub_4126E9", "void *__fastcall sub_4126E9(int a1, __int64 a2)\n{\n  return sub_412463(a1, a2, 0xFFFFFFFFFFFFFFFFLL, (__int64)&qword_61DBC0);\n}\n"], [4269844, "sub_412714", "void *__fastcall sub_412714(int a1, __int64 a2, size_t a3)\n{\n  return sub_412463(a1, a2, a3, (__int64)&qword_61DBC0);\n}\n"], [4269888, "sub_412740", "void *__fastcall sub_412740(__int64 a1)\n{\n  return sub_4126E9(0, a1);\n}\n"], [4269919, "sub_41275F", "void *__fastcall sub_41275F(__int64 a1, size_t a2)\n{\n  return sub_412714(0, a1, a2);\n}\n"], [4269958, "sub_412786", "void *__fastcall sub_412786(int a1, int a2, __int64 a3)\n{\n  _QWORD v5[8]; // [rsp+10h] [rbp-40h] BYREF\n\n  sub_4114BA(v5, a2);\n  return sub_412463(a1, a3, 0xFFFFFFFFFFFFFFFFLL, (__int64)v5);\n}\n"], [4270023, "sub_4127C7", "void *__fastcall sub_4127C7(int a1, int a2, __int64 a3, size_t a4)\n{\n  _QWORD v7[8]; // [rsp+20h] [rbp-40h] BYREF\n\n  sub_4114BA(v7, a2);\n  return sub_412463(a1, a3, a4, (__int64)v7);\n}\n"], [4270086, "sub_412806", "void *__fastcall sub_412806(int a1, __int64 a2)\n{\n  return sub_412786(0, a1, a2);\n}\n"], [4270122, "sub_41282A", "void *__fastcall sub_41282A(int a1, __int64 a2, size_t a3)\n{\n  return sub_4127C7(0, a1, a2, a3);\n}\n"], [4270166, "sub_412856", "void *__fastcall sub_412856(__int64 a1, size_t a2, unsigned __int8 a3)\n{\n  __int64 v4[8]; // [rsp+20h] [rbp-40h] BYREF\n\n  v4[0] = qword_61DBC0;\n  v4[1] = qword_61DBC8;\n  v4[2] = qword_61DBD0;\n  v4[3] = qword_61DBD8;\n  v4[4] = qword_61DBE0;\n  v4[5] = qword_61DBE8;\n  v4[6] = qword_61DBF0;\n  sub_4113A5(v4, a3, 1);\n  return sub_412463(0, a1, a2, (__int64)v4);\n}\n"], [4270314, "sub_4128EA", "void *__fastcall sub_4128EA(__int64 a1, unsigned __int8 a2)\n{\n  return sub_412856(a1, 0xFFFFFFFFFFFFFFFFLL, a2);\n}\n"], [4270356, "sub_412914", "void *__fastcall sub_412914(__int64 a1)\n{\n  return sub_4128EA(a1, 0x3Au);\n}\n"], [4270387, "sub_412933", "void *__fastcall sub_412933(__int64 a1, size_t a2)\n{\n  return sub_412856(a1, a2, 0x3Au);\n}\n"], [4270429, "sub_41295D", "__int64 __fastcall sub_41295D(unsigned int a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  return sub_412993(a1, a2, a3, a4, -1LL);\n}\n"], [4270483, "sub_412993", "void *__fastcall sub_412993(int a1, __int64 a2, __int64 a3, __int64 a4, size_t a5)\n{\n  __int64 v8[8]; // [rsp+30h] [rbp-40h] BYREF\n\n  v8[0] = qword_61DBC0;\n  v8[1] = qword_61DBC8;\n  v8[2] = qword_61DBD0;\n  v8[3] = qword_61DBD8;\n  v8[4] = qword_61DBE0;\n  v8[5] = qword_61DBE8;\n  v8[6] = qword_61DBF0;\n  sub_411460(v8, a2, a3);\n  return sub_412463(a1, a4, a5, (__int64)v8);\n}\n"], [4270634, "sub_412A2A", "__int64 __fastcall sub_412A2A(__int64 a1, __int64 a2, __int64 a3)\n{\n  return sub_41295D(0, a1, a2, a3);\n}\n"], [4270681, "sub_412A59", "void *__fastcall sub_412A59(__int64 a1, __int64 a2, __int64 a3, size_t a4)\n{\n  return sub_412993(0, a1, a2, a3, a4);\n}\n"], [4270739, "sub_412A93", "void __fastcall __noreturn sub_412A93(__int64 a1)\n{\n  void *v1; // r12\n  const char *v2; // rax\n  char *v3; // rbx\n  int *v4; // rax\n\n  if ( a1 )\n  {\n    v1 = sub_412914(a1);\n    if ( *__errno_location() )\n      v2 = \"%s: read error\";\n    else\n      v2 = \"%s: end of file\";\n    v3 = gettext(v2);\n    v4 = __errno_location();\n    error(status, *v4, v3, v1);\n  }\n  abort();\n}\n"], [4270846, "sub_412AFE", "_QWORD *__fastcall sub_412AFE(__int64 a1, __int64 a2)\n{\n  _QWORD *result; // rax\n\n  result = (_QWORD *)sub_414F92(4152LL);\n  *result = a1;\n  result[1] = sub_412A93;\n  result[2] = a2;\n  return result;\n}\n"], [4270917, "sub_412B45", "unsigned __int64 __fastcall sub_412B45(char *a1, unsigned __int64 a2, size_t a3)\n{\n  size_t v3; // rax\n  __int64 v4; // rax\n  __int64 v5; // rax\n  __int64 v6; // rax\n  __int64 v7; // rax\n  unsigned __int64 result; // rax\n  __int64 v9; // rax\n  int fd; // [rsp+24h] [rbp-4Ch]\n  unsigned __int64 v12; // [rsp+28h] [rbp-48h]\n  size_t n; // [rsp+38h] [rbp-38h]\n  size_t v14; // [rsp+40h] [rbp-30h]\n  size_t v15; // [rsp+48h] [rbp-28h]\n  size_t v16; // [rsp+50h] [rbp-20h]\n  size_t v17; // [rsp+58h] [rbp-18h]\n  struct timeval tv; // [rsp+60h] [rbp-10h] BYREF\n\n  v12 = 0LL;\n  fd = open(\"/dev/urandom\", 0);\n  if ( fd >= 0 )\n  {\n    v3 = a2;\n    if ( a3 <= a2 )\n      v3 = a3;\n    v12 = read(fd, a1, v3);\n    if ( (v12 & 0x8000000000000000LL) != 0LL )\n      v12 = 0LL;\n    close(fd);\n  }\n  if ( v12 < a2 )\n  {\n    v4 = a2 - v12;\n    if ( a2 - v12 > 0x10 )\n      v4 = 16LL;\n    n = v4;\n    gettimeofday(&tv, 0LL);\n    memcpy(&a1[v12], &tv, n);\n    v12 += n;\n  }\n  if ( v12 < a2 )\n  {\n    v5 = a2 - v12;\n    if ( a2 - v12 > 4 )\n      v5 = 4LL;\n    v14 = v5;\n    LODWORD(tv.tv_sec) = getpid();\n    memcpy(&a1[v12], &tv, v14);\n    v12 += v14;\n  }\n  if ( v12 < a2 )\n  {\n    v6 = a2 - v12;\n    if ( a2 - v12 > 4 )\n      v6 = 4LL;\n    v15 = v6;\n    LODWORD(tv.tv_sec) = getppid();\n    memcpy(&a1[v12], &tv, v15);\n    v12 += v15;\n  }\n  if ( v12 < a2 )\n  {\n    v7 = a2 - v12;\n    if ( a2 - v12 > 4 )\n      v7 = 4LL;\n    v16 = v7;\n    LODWORD(tv.tv_sec) = getuid();\n    memcpy(&a1[v12], &tv, v16);\n    v12 += v16;\n  }\n  result = v12;\n  if ( v12 < a2 )\n  {\n    v9 = a2 - v12;\n    if ( a2 - v12 > 4 )\n      v9 = 4LL;\n    v17 = v9;\n    LODWORD(tv.tv_sec) = getgid();\n    memcpy(&a1[v12], &tv, v17);\n    result = v12 + v17;\n  }\n  return result;\n}\n"], [4271530, "sub_412DAA", "char *__fastcall sub_412DAA(const char *a1, size_t a2)\n{\n  size_t v3; // rax\n  FILE *stream; // [rsp+10h] [rbp-10h]\n  char *v5; // [rsp+18h] [rbp-8h]\n\n  if ( !a2 )\n    return (char *)sub_412AFE(0LL, 0LL);\n  stream = 0LL;\n  if ( a1 )\n  {\n    stream = sub_40ED36(a1, \"rb\");\n    if ( !stream )\n      return 0LL;\n  }\n  v5 = (char *)sub_412AFE((__int64)stream, (__int64)a1);\n  if ( stream )\n  {\n    v3 = 4096LL;\n    if ( a2 <= 0x1000 )\n      v3 = a2;\n    setvbuf(stream, v5 + 24, 0, v3);\n  }\n  else\n  {\n    *((_QWORD *)v5 + 3) = 0LL;\n    sub_412B45(v5 + 32, 0x800uLL, a2);\n    sub_4138F7(v5 + 32);\n  }\n  return v5;\n}\n"], [4271769, "sub_412E99", "__int64 __fastcall sub_412E99(__int64 a1, __int64 a2)\n{\n  __int64 result; // rax\n\n  result = a1;\n  *(_QWORD *)(a1 + 8) = a2;\n  return result;\n}\n"], [4271795, "sub_412EB3", "__int64 __fastcall sub_412EB3(__int64 a1, __int64 a2)\n{\n  __int64 result; // rax\n\n  result = a1;\n  *(_QWORD *)(a1 + 16) = a2;\n  return result;\n}\n"], [4271821, "sub_412ECD", "size_t __fastcall sub_412ECD(__int64 a1, char *a2, size_t a3)\n{\n  size_t result; // rax\n  int *v4; // rbx\n  int v5; // eax\n  int v8; // [rsp+24h] [rbp-1Ch]\n  size_t v9; // [rsp+28h] [rbp-18h]\n\n  while ( 1 )\n  {\n    v9 = fread_unlocked(a2, 1uLL, a3, *(FILE **)a1);\n    v8 = *__errno_location();\n    a2 += v9;\n    result = v9;\n    a3 -= v9;\n    if ( !a3 )\n      break;\n    v4 = __errno_location();\n    if ( ferror_unlocked(*(FILE **)a1) )\n      v5 = v8;\n    else\n      v5 = 0;\n    *v4 = v5;\n    (*(void (__fastcall **)(_QWORD))(a1 + 8))(*(_QWORD *)(a1 + 16));\n  }\n  return result;\n}\n"], [4271981, "sub_412F6D", "size_t *__fastcall sub_412F6D(size_t *a1, char *a2, size_t a3)\n{\n  size_t *result; // rax\n  size_t i; // [rsp+20h] [rbp-10h]\n  char *v7; // [rsp+28h] [rbp-8h]\n\n  for ( i = *a1; a3 > i; i = 2048LL )\n  {\n    memcpy(a2, (char *)a1 + 2048 - i + 2080, i);\n    a2 += i;\n    a3 -= i;\n    if ( ((unsigned __int8)a2 & 7) == 0 )\n    {\n      v7 = a2;\n      while ( a3 > 0x7FF )\n      {\n        sub_41318F(a1 + 1, v7);\n        v7 += 2048;\n        a3 -= 2048LL;\n        if ( !a3 )\n        {\n          result = a1;\n          *a1 = 0LL;\n          return result;\n        }\n      }\n      a2 = v7;\n    }\n    sub_41318F(a1 + 1, a1 + 260);\n  }\n  memcpy(a2, (char *)a1 + 2048 - i + 2080, a3);\n  result = a1;\n  *a1 = i - a3;\n  return result;\n}\n"], [4272291, "sub_4130A3", "size_t __fastcall sub_4130A3(_QWORD *a1, char *a2, size_t a3)\n{\n  size_t result; // rax\n\n  if ( *a1 )\n    result = sub_412ECD((__int64)a1, a2, a3);\n  else\n    result = (size_t)sub_412F6D(a1 + 3, a2, a3);\n  return result;\n}\n"], [4272377, "sub_4130F9", "__int64 __fastcall sub_4130F9(__int64 *a1)\n{\n  __int64 result; // rax\n  __int64 v2; // [rsp+18h] [rbp-8h]\n\n  v2 = *a1;\n  memset(a1, 0, 0x1038uLL);\n  free(a1);\n  if ( v2 )\n    result = sub_415E9D(v2);\n  else\n    result = 0LL;\n  return result;\n}\n"], [4272462, "sub_41314E", "__int64 __fastcall sub_41314E(__int64 a1)\n{\n  return a1;\n}\n"], [4272491, "sub_41316B", "__int64 __fastcall sub_41316B(__int64 a1, __int16 a2)\n{\n  return *(_QWORD *)((a2 & 0x7F8) + a1);\n}\n"], [4272527, "sub_41318F", "__int64 *__fastcall sub_41318F(__int64 *a1, __int64 *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rax\n  __int64 v4; // rax\n  __int64 v5; // rax\n  __int64 v6; // rax\n  __int64 v7; // rax\n  __int64 v8; // rax\n  __int64 v9; // rax\n  __int64 v10; // rax\n  __int64 v11; // rax\n  __int64 v12; // rax\n  __int64 v13; // rax\n  __int64 v14; // rax\n  __int64 v15; // rax\n  __int64 v16; // rax\n  __int64 *result; // rax\n  unsigned __int64 v18; // [rsp+10h] [rbp-A8h]\n  __int64 v19; // [rsp+10h] [rbp-A8h]\n  unsigned __int64 v20; // [rsp+10h] [rbp-A8h]\n  __int64 v21; // [rsp+10h] [rbp-A8h]\n  __int64 v22; // [rsp+10h] [rbp-A8h]\n  unsigned __int64 v23; // [rsp+10h] [rbp-A8h]\n  __int64 v24; // [rsp+10h] [rbp-A8h]\n  __int64 v25; // [rsp+18h] [rbp-A0h]\n  __int64 v26; // [rsp+18h] [rbp-A0h]\n  __int64 v27; // [rsp+18h] [rbp-A0h]\n  __int64 v28; // [rsp+18h] [rbp-A0h]\n  __int64 v29; // [rsp+18h] [rbp-A0h]\n  __int64 v30; // [rsp+18h] [rbp-A0h]\n  __int64 v31; // [rsp+18h] [rbp-A0h]\n  __int64 *v32; // [rsp+20h] [rbp-98h]\n  __int64 v34; // [rsp+30h] [rbp-88h]\n  __int64 v35; // [rsp+38h] [rbp-80h]\n  __int64 v36; // [rsp+40h] [rbp-78h]\n  __int64 v37; // [rsp+50h] [rbp-68h]\n  __int64 v38; // [rsp+60h] [rbp-58h]\n  __int64 v39; // [rsp+70h] [rbp-48h]\n  __int64 v40; // [rsp+78h] [rbp-40h]\n  __int64 v41; // [rsp+80h] [rbp-38h]\n  __int64 v42; // [rsp+90h] [rbp-28h]\n  __int64 v43; // [rsp+A0h] [rbp-18h]\n\n  v18 = a1[256];\n  v2 = a1[257];\n  ++a1[258];\n  v25 = v2 + a1[258];\n  v32 = a1;\n  do\n  {\n    v19 = v32[128] - (v18 ^ (v18 << 21)) - 1;\n    v34 = *v32;\n    v35 = sub_41316B((__int64)a1, *v32) + v19 + v25;\n    *v32 = v35;\n    v3 = sub_41316B((__int64)a1, (unsigned int)v35 >> 8);\n    v26 = sub_41314E(v34 + v3);\n    *a2 = v26;\n    v20 = (v19 ^ ((unsigned __int64)sub_41314E(v19) >> 5)) + v32[129];\n    v36 = v32[1];\n    v4 = sub_41316B((__int64)a1, v36);\n    v32[1] = v4 + v20 + v26;\n    v5 = sub_41316B((__int64)a1, (unsigned int)(v4 + v20 + v26) >> 8);\n    v27 = sub_41314E(v36 + v5);\n    a2[1] = v27;\n    v21 = (v20 ^ (v20 << 12)) + v32[130];\n    v37 = v32[2];\n    v6 = sub_41316B((__int64)a1, v37);\n    v32[2] = v6 + v21 + v27;\n    v7 = sub_41316B((__int64)a1, (unsigned int)(v6 + v21 + v27) >> 8);\n    v28 = sub_41314E(v37 + v7);\n    a2[2] = v28;\n    v18 = (v21 ^ ((unsigned __int64)sub_41314E(v21) >> 33)) + v32[131];\n    v38 = v32[3];\n    v8 = sub_41316B((__int64)a1, v38);\n    v32[3] = v8 + v18 + v28;\n    v9 = sub_41316B((__int64)a1, (unsigned int)(v8 + v18 + v28) >> 8);\n    v25 = sub_41314E(v38 + v9);\n    a2[3] = v25;\n    a2 += 4;\n    v32 += 4;\n  }\n  while ( v32 < a1 + 128 );\n  do\n  {\n    v22 = *(v32 - 128) - (v18 ^ (v18 << 21)) - 1;\n    v39 = *v32;\n    v40 = sub_41316B((__int64)a1, *v32) + v22 + v25;\n    *v32 = v40;\n    v10 = sub_41316B((__int64)a1, (unsigned int)v40 >> 8);\n    v29 = sub_41314E(v39 + v10);\n    *a2 = v29;\n    v23 = (v22 ^ ((unsigned __int64)sub_41314E(v22) >> 5)) + *(v32 - 127);\n    v41 = v32[1];\n    v11 = sub_41316B((__int64)a1, v41);\n    v32[1] = v11 + v23 + v29;\n    v12 = sub_41316B((__int64)a1, (unsigned int)(v11 + v23 + v29) >> 8);\n    v30 = sub_41314E(v41 + v12);\n    a2[1] = v30;\n    v24 = (v23 ^ (v23 << 12)) + *(v32 - 126);\n    v42 = v32[2];\n    v13 = sub_41316B((__int64)a1, v42);\n    v32[2] = v13 + v24 + v30;\n    v14 = sub_41316B((__int64)a1, (unsigned int)(v13 + v24 + v30) >> 8);\n    v31 = sub_41314E(v42 + v14);\n    a2[2] = v31;\n    v18 = (v24 ^ ((unsigned __int64)sub_41314E(v24) >> 33)) + *(v32 - 125);\n    v43 = v32[3];\n    v15 = sub_41316B((__int64)a1, v43);\n    v32[3] = v15 + v18 + v31;\n    v16 = sub_41316B((__int64)a1, (unsigned int)(v15 + v18 + v31) >> 8);\n    v25 = sub_41314E(v43 + v16);\n    a2[3] = v25;\n    a2 += 4;\n    v32 += 4;\n  }\n  while ( v32 < a1 + 256 );\n  a1[256] = v18;\n  result = a1;\n  a1[257] = v25;\n  return result;\n}\n"], [4274423, "sub_4138F7", "_QWORD *__fastcall sub_4138F7(_QWORD *a1)\n{\n  _QWORD *result; // rax\n  int i; // [rsp+10h] [rbp-48h]\n  int j; // [rsp+14h] [rbp-44h]\n  __int64 v4; // [rsp+18h] [rbp-40h]\n  unsigned __int64 v5; // [rsp+18h] [rbp-40h]\n  unsigned __int64 v6; // [rsp+18h] [rbp-40h]\n  unsigned __int64 v7; // [rsp+18h] [rbp-40h]\n  unsigned __int64 v8; // [rsp+18h] [rbp-40h]\n  unsigned __int64 v9; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v10; // [rsp+20h] [rbp-38h]\n  __int64 v11; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v12; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v13; // [rsp+20h] [rbp-38h]\n  __int64 v14; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v15; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v16; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v17; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v18; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v19; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v20; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v21; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v22; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v23; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v24; // [rsp+30h] [rbp-28h]\n  __int64 v25; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v26; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v27; // [rsp+30h] [rbp-28h]\n  __int64 v28; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v29; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v30; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v31; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v32; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v33; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v34; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v35; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v36; // [rsp+38h] [rbp-20h]\n  __int64 v37; // [rsp+40h] [rbp-18h]\n  __int64 v38; // [rsp+40h] [rbp-18h]\n  unsigned __int64 v39; // [rsp+40h] [rbp-18h]\n  __int64 v40; // [rsp+40h] [rbp-18h]\n  __int64 v41; // [rsp+40h] [rbp-18h]\n  unsigned __int64 v42; // [rsp+40h] [rbp-18h]\n  __int64 v43; // [rsp+40h] [rbp-18h]\n  unsigned __int64 v44; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v45; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v46; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v47; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v48; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v49; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v50; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v51; // [rsp+50h] [rbp-8h]\n  __int64 v52; // [rsp+50h] [rbp-8h]\n  unsigned __int64 v53; // [rsp+50h] [rbp-8h]\n  unsigned __int64 v54; // [rsp+50h] [rbp-8h]\n  __int64 v55; // [rsp+50h] [rbp-8h]\n  unsigned __int64 v56; // [rsp+50h] [rbp-8h]\n  unsigned __int64 v57; // [rsp+50h] [rbp-8h]\n\n  v4 = 0x647C4677A2884B7CLL;\n  v9 = 0xB9F8B322C73AC862LL;\n  v16 = 0x8C0EA5053D4712A0LL;\n  v23 = 0xB29B2E824A595524LL;\n  v30 = 0x82F053DB8355E0CELL;\n  v37 = 0x48FE4A0FA5A09315LL;\n  v44 = 0xAE985BF2CBFC89EDLL;\n  v51 = 0x98F5704F6C44C0ABLL;\n  for ( i = 0; i <= 255; i += 8 )\n  {\n    v10 = a1[i + 1] + v9;\n    v17 = a1[i + 2] + v16;\n    v24 = a1[i + 3] + v23;\n    v31 = a1[i + 4] + v30;\n    v38 = a1[i + 5] + v37;\n    v45 = a1[i + 6] + v44;\n    v52 = a1[i + 7] + v51;\n    v5 = a1[i] + v4 - v31;\n    v39 = ((unsigned __int64)sub_41314E(v52) >> 9) ^ v38;\n    v53 = v5 + v52;\n    v11 = v10 - v39;\n    v46 = (v5 << 9) ^ v45;\n    v6 = v11 + v5;\n    v18 = v17 - v46;\n    v54 = ((unsigned __int64)sub_41314E(v11) >> 23) ^ v53;\n    v12 = v18 + v11;\n    v25 = v24 - v54;\n    v4 = (v18 << 15) ^ v6;\n    v19 = v25 + v18;\n    v32 = v31 - v4;\n    v9 = ((unsigned __int64)sub_41314E(v25) >> 14) ^ v12;\n    v26 = v32 + v25;\n    v40 = v39 - v9;\n    v16 = (v32 << 20) ^ v19;\n    v33 = v40 + v32;\n    v47 = v46 - v16;\n    v23 = ((unsigned __int64)sub_41314E(v40) >> 17) ^ v26;\n    v37 = v47 + v40;\n    v51 = v54 - v23;\n    v30 = (v47 << 14) ^ v33;\n    v44 = v51 + v47;\n    a1[i] = v4;\n    a1[i + 1] = v9;\n    a1[i + 2] = v16;\n    a1[i + 3] = v23;\n    a1[i + 4] = v30;\n    a1[i + 5] = v37;\n    a1[i + 6] = v44;\n    a1[i + 7] = v51;\n  }\n  for ( j = 0; j <= 255; j += 8 )\n  {\n    v13 = a1[j + 1] + v9;\n    v20 = a1[j + 2] + v16;\n    v27 = a1[j + 3] + v23;\n    v34 = a1[j + 4] + v30;\n    v41 = a1[j + 5] + v37;\n    v48 = a1[j + 6] + v44;\n    v55 = a1[j + 7] + v51;\n    v7 = a1[j] + v4 - v34;\n    v42 = ((unsigned __int64)sub_41314E(v55) >> 9) ^ v41;\n    v56 = v7 + v55;\n    v14 = v13 - v42;\n    v49 = (v7 << 9) ^ v48;\n    v8 = v14 + v7;\n    v21 = v20 - v49;\n    v57 = ((unsigned __int64)sub_41314E(v14) >> 23) ^ v56;\n    v15 = v21 + v14;\n    v28 = v27 - v57;\n    v4 = (v21 << 15) ^ v8;\n    v22 = v28 + v21;\n    v35 = v34 - v4;\n    v9 = ((unsigned __int64)sub_41314E(v28) >> 14) ^ v15;\n    v29 = v35 + v28;\n    v43 = v42 - v9;\n    v16 = (v35 << 20) ^ v22;\n    v36 = v43 + v35;\n    v50 = v49 - v16;\n    v23 = ((unsigned __int64)sub_41314E(v43) >> 17) ^ v29;\n    v37 = v50 + v43;\n    v51 = v57 - v23;\n    v30 = (v50 << 14) ^ v36;\n    v44 = v51 + v50;\n    a1[j] = v4;\n    a1[j + 1] = v9;\n    a1[j + 2] = v16;\n    a1[j + 3] = v23;\n    a1[j + 4] = v30;\n    a1[j + 5] = v37;\n    a1[j + 6] = v44;\n    a1[j + 7] = v51;\n  }\n  a1[258] = 0LL;\n  a1[257] = a1[258];\n  result = a1;\n  a1[256] = a1[257];\n  return result;\n}\n"], [4275838, "sub_413E7E", "int __fastcall sub_413E7E(__int64 a1)\n{\n  *(_QWORD *)a1 = 0LL;\n  *(_QWORD *)(a1 + 8) = 0LL;\n  *(_QWORD *)(a1 + 16) = 0LL;\n  _obstack_begin((struct obstack *)(a1 + 24), 0, 0, (void *(*)(__int64))malloc, free);\n  _obstack_begin((struct obstack *)(a1 + 112), 0, 0, (void *(*)(__int64))malloc, free);\n  return _obstack_begin((struct obstack *)(a1 + 200), 0, 0, (void *(*)(__int64))malloc, free);\n}\n"], [4276000, "sub_413F20", "void __fastcall sub_413F20(__int64 a1)\n{\n  obstack_free((struct obstack *)(a1 + 24), 0LL);\n  obstack_free((struct obstack *)(a1 + 112), 0LL);\n  obstack_free((struct obstack *)(a1 + 200), 0LL);\n}\n"], [4276307, "sub_414053", "__int64 __fastcall sub_414053(__int64 a1)\n{\n  __int64 result; // rax\n  __int64 src[2]; // [rsp+20h] [rbp-40h] BYREF\n  __int64 v3; // [rsp+30h] [rbp-30h]\n  __int64 v4; // [rsp+38h] [rbp-28h]\n  __int64 v5; // [rsp+40h] [rbp-20h]\n  struct obstack *v6; // [rsp+48h] [rbp-18h]\n  struct obstack *v7; // [rsp+50h] [rbp-10h]\n  struct obstack *v8; // [rsp+58h] [rbp-8h]\n\n  src[1] = a1 + 24;\n  src[0] = (unsigned int)(*(_DWORD *)(a1 + 48) - *(_DWORD *)(a1 + 40) - 1);\n  v3 = a1 + 24;\n  v4 = *(_QWORD *)(a1 + 40);\n  if ( *(_QWORD *)(a1 + 48) == v4 )\n    *(_BYTE *)(v3 + 80) |= 2u;\n  *(_QWORD *)(v3 + 24) = (*(int *)(v3 + 48) + *(_QWORD *)(v3 + 24)) & ~*(_DWORD *)(v3 + 48);\n  if ( *(_QWORD *)(v3 + 24) - *(_QWORD *)(v3 + 8) > *(_QWORD *)(v3 + 32) - *(_QWORD *)(v3 + 8) )\n    *(_QWORD *)(v3 + 24) = *(_QWORD *)(v3 + 32);\n  *(_QWORD *)(v3 + 16) = *(_QWORD *)(v3 + 24);\n  v5 = v4;\n  v6 = (struct obstack *)(a1 + 112);\n  if ( (unsigned __int64)(*(_QWORD *)(a1 + 136) + 8LL) > *(_QWORD *)(a1 + 144) )\n    _obstack_newchunk(v6, 8);\n  v7 = v6;\n  *(_QWORD *)v6->next_free = v5;\n  v7->next_free += 8;\n  v8 = (struct obstack *)(a1 + 200);\n  if ( (unsigned __int64)(*(_QWORD *)(a1 + 224) + 8LL) > *(_QWORD *)(a1 + 232) )\n    _obstack_newchunk(v8, 8);\n  memcpy(v8->next_free, src, 8uLL);\n  v8->next_free += 8;\n  result = a1;\n  ++*(_QWORD *)a1;\n  return result;\n}\n"], [4276797, "sub_41423D", "bool __fastcall sub_41423D(FILE *a1, __int64 a2)\n{\n  _BYTE *v2; // rax\n  _BYTE *v3; // rax\n  int v5; // [rsp+1Ch] [rbp-54h]\n  __int64 v6; // [rsp+50h] [rbp-20h]\n  __int64 v7; // [rsp+60h] [rbp-10h]\n\n  while ( 1 )\n  {\n    v5 = fgetc(a1);\n    if ( v5 == -1 )\n      break;\n    if ( (unsigned __int64)(*(_QWORD *)(a2 + 48) + 1LL) > *(_QWORD *)(a2 + 56) )\n      _obstack_newchunk((struct obstack *)(a2 + 24), 1);\n    v3 = *(_BYTE **)(a2 + 48);\n    *(_QWORD *)(a2 + 48) = v3 + 1;\n    *v3 = v5;\n    if ( !v5 )\n      sub_414053(a2);\n  }\n  if ( *(_DWORD *)(a2 + 48) != *(_DWORD *)(a2 + 40) )\n  {\n    if ( (unsigned __int64)(*(_QWORD *)(a2 + 48) + 1LL) > *(_QWORD *)(a2 + 56) )\n      _obstack_newchunk((struct obstack *)(a2 + 24), 1);\n    v2 = *(_BYTE **)(a2 + 48);\n    *(_QWORD *)(a2 + 48) = v2 + 1;\n    *v2 = 0;\n    sub_414053(a2);\n  }\n  if ( (unsigned __int64)(*(_QWORD *)(a2 + 136) + 8LL) > *(_QWORD *)(a2 + 144) )\n    _obstack_newchunk((struct obstack *)(a2 + 112), 8);\n  **(_QWORD **)(a2 + 136) = 0LL;\n  *(_QWORD *)(a2 + 136) += 8LL;\n  v6 = *(_QWORD *)(a2 + 128);\n  if ( *(_QWORD *)(a2 + 136) == v6 )\n    *(_BYTE *)(a2 + 192) |= 2u;\n  *(_QWORD *)(a2 + 136) = (*(int *)(a2 + 160) + *(_QWORD *)(a2 + 136)) & ~*(_DWORD *)(a2 + 160);\n  if ( *(_QWORD *)(a2 + 136) - *(_QWORD *)(a2 + 120) > *(_QWORD *)(a2 + 144) - *(_QWORD *)(a2 + 120) )\n    *(_QWORD *)(a2 + 136) = *(_QWORD *)(a2 + 144);\n  *(_QWORD *)(a2 + 128) = *(_QWORD *)(a2 + 136);\n  *(_QWORD *)(a2 + 8) = v6;\n  v7 = *(_QWORD *)(a2 + 216);\n  if ( *(_QWORD *)(a2 + 224) == v7 )\n    *(_BYTE *)(a2 + 280) |= 2u;\n  *(_QWORD *)(a2 + 224) = (*(int *)(a2 + 248) + *(_QWORD *)(a2 + 224)) & ~*(_DWORD *)(a2 + 248);\n  if ( *(_QWORD *)(a2 + 224) - *(_QWORD *)(a2 + 208) > *(_QWORD *)(a2 + 232) - *(_QWORD *)(a2 + 208) )\n    *(_QWORD *)(a2 + 224) = *(_QWORD *)(a2 + 232);\n  *(_QWORD *)(a2 + 216) = *(_QWORD *)(a2 + 224);\n  *(_QWORD *)(a2 + 16) = v7;\n  return ferror(a1) == 0;\n}\n"], [4277604, "sub_414564", "__int64 __fastcall sub_414564(char *a1)\n{\n  unsigned int v1; // eax\n\n  v1 = mkstemp(a1);\n  return sub_4145AB(v1);\n}\n"], [4277637, "sub_414585", "__int64 __fastcall sub_414585(int a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  return sub_415F52(a1, 0, 3, a4, a5, a6);\n}\n"], [4277675, "sub_4145AB", "__int64 __fastcall sub_4145AB(int a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  unsigned int fd; // [rsp+Ch] [rbp-14h]\n  unsigned int v8; // [rsp+18h] [rbp-8h]\n  int v9; // [rsp+1Ch] [rbp-4h]\n\n  fd = a1;\n  if ( a1 >= 0 && a1 <= 2 )\n  {\n    v8 = sub_414585(a1, a2, a3, a4, a5, a6);\n    v9 = *__errno_location();\n    close(a1);\n    *__errno_location() = v9;\n    fd = v8;\n  }\n  return fd;\n}\n"], [4277752, "sub_4145F8", "int __fastcall sub_4145F8(FILE *a1, const char *a2, const char *a3, const char *a4, __int64 *a5, unsigned __int64 a6)\n{\n  char *v6; // rax\n  char *v7; // rax\n  __int64 v8; // rbx\n  char *v9; // rax\n  __int64 v10; // r12\n  __int64 v11; // rbx\n  char *v12; // rax\n  __int64 v13; // r13\n  __int64 v14; // r12\n  __int64 v15; // rbx\n  char *v16; // rax\n  int result; // eax\n  __int64 v18; // r14\n  __int64 v19; // r13\n  __int64 v20; // r12\n  __int64 v21; // rbx\n  char *v22; // rax\n  __int64 v23; // r13\n  __int64 v24; // r15\n  __int64 v25; // r14\n  __int64 v26; // r12\n  __int64 v27; // rbx\n  char *v28; // rax\n  __int64 v29; // r14\n  __int64 v30; // r13\n  __int64 v31; // r15\n  __int64 v32; // r12\n  __int64 v33; // rbx\n  char *v34; // rax\n  __int64 v35; // r15\n  __int64 v36; // r14\n  __int64 v37; // r13\n  __int64 v38; // r12\n  __int64 v39; // rbx\n  char *v40; // rax\n  __int64 v41; // r15\n  __int64 v42; // r14\n  __int64 v43; // r13\n  __int64 v44; // r12\n  __int64 v45; // rbx\n  char *v46; // rax\n  __int64 v47; // r15\n  __int64 v48; // r14\n  __int64 v49; // r13\n  __int64 v50; // r12\n  __int64 v51; // rbx\n  char *v52; // rax\n  __int64 v53; // [rsp+30h] [rbp-80h]\n  __int64 v54; // [rsp+38h] [rbp-78h]\n  __int64 v55; // [rsp+38h] [rbp-78h]\n  __int64 v56; // [rsp+40h] [rbp-70h]\n  __int64 v57; // [rsp+40h] [rbp-70h]\n  __int64 v58; // [rsp+40h] [rbp-70h]\n  __int64 v59; // [rsp+48h] [rbp-68h]\n  __int64 v60; // [rsp+48h] [rbp-68h]\n  __int64 v61; // [rsp+48h] [rbp-68h]\n  __int64 v62; // [rsp+48h] [rbp-68h]\n\n  if ( a2 )\n    fprintf(a1, \"%s (%s) %s\\n\", a2, a3, a4);\n  else\n    fprintf(a1, \"%s %s\\n\", a3, a4);\n  v6 = gettext(\"(C)\");\n  fprintf(a1, \"Copyright %s %d Free Software Foundation, Inc.\", v6, 2011LL);\n  v7 = gettext(\n         \"\\n\"\n         \"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\"\n         \"\\n\");\n  fputs_unlocked(v7, a1);\n  if ( a6 == 4 )\n  {\n    v18 = a5[3];\n    v19 = a5[2];\n    v20 = a5[1];\n    v21 = *a5;\n    v22 = gettext(\"Written by %s, %s, %s,\\nand %s.\\n\");\n    result = fprintf(a1, v22, v21, v20, v19, v18);\n  }\n  else if ( a6 > 4 )\n  {\n    if ( a6 == 7 )\n    {\n      v35 = a5[6];\n      v36 = a5[5];\n      v37 = a5[4];\n      v60 = a5[3];\n      v56 = a5[2];\n      v38 = a5[1];\n      v39 = *a5;\n      v40 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\");\n      result = fprintf(a1, v40, v39, v38, v56, v60, v37, v36, v35);\n    }\n    else if ( a6 > 7 )\n    {\n      if ( a6 == 8 )\n      {\n        v61 = a5[7];\n        v41 = a5[6];\n        v42 = a5[5];\n        v43 = a5[4];\n        v57 = a5[3];\n        v54 = a5[2];\n        v44 = a5[1];\n        v45 = *a5;\n        v46 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\");\n        result = fprintf(a1, v46, v45, v44, v54, v57, v43, v42, v41, v61);\n      }\n      else\n      {\n        v62 = a5[8];\n        v58 = a5[7];\n        v47 = a5[6];\n        v48 = a5[5];\n        v49 = a5[4];\n        v55 = a5[3];\n        v53 = a5[2];\n        v50 = a5[1];\n        v51 = *a5;\n        if ( a6 == 9 )\n          v52 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\");\n        else\n          v52 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\");\n        result = fprintf(a1, v52, v51, v50, v53, v55, v49, v48, v47, v58, v62);\n      }\n    }\n    else if ( a6 == 5 )\n    {\n      v23 = a5[4];\n      v24 = a5[3];\n      v25 = a5[2];\n      v26 = a5[1];\n      v27 = *a5;\n      v28 = gettext(\"Written by %s, %s, %s,\\n%s, and %s.\\n\");\n      result = fprintf(a1, v28, v27, v26, v25, v24, v23);\n    }\n    else\n    {\n      v29 = a5[5];\n      v30 = a5[4];\n      v59 = a5[3];\n      v31 = a5[2];\n      v32 = a5[1];\n      v33 = *a5;\n      v34 = gettext(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\");\n      result = fprintf(a1, v34, v33, v32, v31, v59, v30, v29);\n    }\n  }\n  else\n  {\n    switch ( a6 )\n    {\n      case 1uLL:\n        v8 = *a5;\n        v9 = gettext(\"Written by %s.\\n\");\n        result = fprintf(a1, v9, v8);\n        break;\n      case 0uLL:\n        abort();\n      case 2uLL:\n        v10 = a5[1];\n        v11 = *a5;\n        v12 = gettext(\"Written by %s and %s.\\n\");\n        result = fprintf(a1, v12, v11, v10);\n        break;\n      default:\n        v13 = a5[2];\n        v14 = a5[1];\n        v15 = *a5;\n        v16 = gettext(\"Written by %s, %s, and %s.\\n\");\n        result = fprintf(a1, v16, v15, v14, v13);\n        break;\n    }\n  }\n  return result;\n}\n"], [4279267, "sub_414BE3", "int __fastcall sub_414BE3(FILE *a1, const char *a2, const char *a3, const char *a4, __int64 *a5)\n{\n  unsigned __int64 i; // [rsp+38h] [rbp-8h]\n\n  for ( i = 0LL; a5[i]; ++i )\n    ;\n  return sub_4145F8(a1, a2, a3, a4, a5, i);\n}\n"], [4279377, "sub_414C51", "int __fastcall sub_414C51(FILE *a1, const char *a2, const char *a3, const char *a4, unsigned int *a5)\n{\n  __int64 *v5; // rax\n  unsigned __int64 i; // [rsp+38h] [rbp-58h]\n  __int64 v8[10]; // [rsp+40h] [rbp-50h] BYREF\n\n  for ( i = 0LL; i <= 9; ++i )\n  {\n    if ( *a5 >= 0x30 )\n    {\n      v5 = (__int64 *)*((_QWORD *)a5 + 1);\n      *((_QWORD *)a5 + 1) = v5 + 1;\n    }\n    else\n    {\n      v5 = (__int64 *)(*((_QWORD *)a5 + 2) + *a5);\n      *a5 += 8;\n    }\n    v8[i] = *v5;\n    if ( !v8[i] )\n      break;\n  }\n  return sub_4145F8(a1, a2, a3, a4, v8, i);\n}\n"], [4279594, "sub_414D2A", "int sub_414D2A(FILE *a1, const char *a2, const char *a3, const char *a4, ...)\n{\n  gcc_va_list va; // [rsp+28h] [rbp-C8h] BYREF\n\n  va_start(va, a4);\n  return sub_414C51(a1, a2, a3, a4, (unsigned int *)va);\n}\n"], [4279776, "sub_414DE0", "int sub_414DE0()\n{\n  char *v0; // rax\n  char *v1; // rax\n  FILE *v2; // rbx\n  char *v3; // rax\n\n  v0 = gettext(\"\\nReport bugs to: %s\\n\");\n  printf(v0, \"bug-coreutils@gnu.org\");\n  v1 = gettext(\"%s home page: <%s>\\n\");\n  printf(v1, \"GNU coreutils\", \"http://www.gnu.org/software/coreutils/\");\n  v2 = stdout;\n  v3 = gettext(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\");\n  return fputs_unlocked(v3, v2);\n}\n"], [4279881, "sub_414E49", "__int64 __fastcall sub_414E49(unsigned __int64 a1, unsigned __int64 a2)\n{\n  if ( 0xFFFFFFFFFFFFFFFFLL / a2 < a1 )\n    sub_415114(a1, a2, 0xFFFFFFFFFFFFFFFFLL % a2);\n  return sub_414F92(a2 * a1);\n}\n"], [4279943, "sub_414E87", "__int64 __fastcall sub_414E87(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)\n{\n  unsigned __int64 v3; // rax\n  unsigned __int64 v4; // rdx\n\n  v3 = 0xFFFFFFFFFFFFFFFFLL / a3;\n  v4 = 0xFFFFFFFFFFFFFFFFLL % a3;\n  if ( v3 < a2 )\n    sub_415114(a1, a2, v4);\n  return sub_414FC7(a1, a3 * a2);\n}\n"], [4280019, "sub_414ED3", "__int64 __fastcall sub_414ED3(__int64 a1, unsigned __int64 *a2, unsigned __int64 a3)\n{\n  unsigned __int64 v3; // rdx\n  unsigned __int64 v6; // [rsp+28h] [rbp-8h]\n\n  v6 = *a2;\n  if ( a1 )\n  {\n    v3 = 0xAAAAAAAAAAAAAAAALL % a3;\n    if ( 0xAAAAAAAAAAAAAAAALL / a3 <= v6 )\n      sub_415114(a1, a2, v3);\n    v6 += (v6 + 1) >> 1;\n  }\n  else if ( !v6 )\n  {\n    v6 = (0x80 / a3 == 0) + 0x80 / a3;\n  }\n  *a2 = v6;\n  return sub_414FC7(a1, a3 * v6);\n}\n"], [4280184, "sub_414F78", "__int64 __fastcall sub_414F78(__int64 a1)\n{\n  return sub_414F92(a1);\n}\n"], [4280210, "sub_414F92", "void *__fastcall sub_414F92(size_t a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  void *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = malloc(a1);\n  if ( !v4 && a1 )\n    sub_415114(a1, a2, v2);\n  return v4;\n}\n"], [4280263, "sub_414FC7", "void *__fastcall sub_414FC7(void *a1, size_t a2)\n{\n  void *result; // rax\n  __int64 v3; // rdx\n  void *ptr; // [rsp+8h] [rbp-8h]\n\n  if ( a2 || !a1 )\n  {\n    ptr = realloc(a1, a2);\n    if ( !ptr )\n    {\n      if ( a2 )\n        sub_415114(a1, a2, v3);\n    }\n    result = ptr;\n  }\n  else\n  {\n    free(a1);\n    result = 0LL;\n  }\n  return result;\n}\n"], [4280360, "sub_415028", "__int64 __fastcall sub_415028(__int64 a1, unsigned __int64 *a2)\n{\n  return sub_414ED3(a1, a2, 1uLL);\n}\n"], [4280402, "sub_415052", "void *__fastcall sub_415052(size_t a1, __int64 a2)\n{\n  void *v2; // rax\n\n  v2 = sub_414F92(a1, a2);\n  return memset(v2, 0, a1);\n}\n"], [4280445, "sub_41507D", "void *__fastcall sub_41507D(size_t a1, size_t a2)\n{\n  __int64 v2; // rdx\n  void *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = calloc(a1, a2);\n  if ( !v4 )\n    sub_415114(a1, a2, v2);\n  return v4;\n}\n"], [4280502, "sub_4150B6", "void *__fastcall sub_4150B6(const void *a1, size_t a2)\n{\n  void *v2; // rax\n\n  v2 = sub_414F92(a2, a2);\n  return memcpy(v2, a1, a2);\n}\n"], [4280551, "sub_4150E7", "void *__fastcall sub_4150E7(const char *a1)\n{\n  size_t v1; // rax\n\n  v1 = strlen(a1);\n  return sub_4150B6(a1, v1 + 1);\n}\n"], [4280596, "sub_415114", "void __noreturn sub_415114()\n{\n  char *v0; // rax\n\n  v0 = gettext(\"memory exhausted\");\n  error(status, 0, \"%s\", v0);\n  abort();\n}\n"], [4280649, "sub_415149", "void __fastcall sub_415149(int a1, __int64 a2, size_t a3, __int64 a4, size_t a5)\n{\n  char *v5; // rax\n  char *v6; // rax\n  void *v7; // r12\n  void *v8; // rbx\n  char *v9; // rax\n\n  v5 = gettext(\"string comparison failed\");\n  error(0, a1, v5);\n  v6 = gettext(\"Set LC_ALL='C' to work around the problem.\");\n  error(0, 0, v6);\n  v7 = sub_4127C7(1, 6, a4, a5);\n  v8 = sub_4127C7(0, 6, a2, a3);\n  v9 = gettext(\"The strings compared were %s and %s.\");\n  error(status, 0, v9, v8, v7);\n}\n"], [4280860, "sub_41521C", "__int64 __fastcall sub_41521C(__int64 a1, size_t a2, __int64 a3, size_t a4)\n{\n  unsigned int v7; // [rsp+28h] [rbp-8h]\n  int v8; // [rsp+2Ch] [rbp-4h]\n\n  v7 = sub_416F6C(a1, a2, a3, a4);\n  v8 = *__errno_location();\n  if ( v8 )\n    sub_415149(v8, a1, a2, a3, a4);\n  return v7;\n}\n"], [4280961, "sub_415281", "__int64 __fastcall sub_415281(__int64 a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  unsigned int v7; // [rsp+28h] [rbp-8h]\n  int v8; // [rsp+2Ch] [rbp-4h]\n\n  v7 = sub_417048(a1, a2, a3, a4);\n  v8 = *__errno_location();\n  if ( v8 )\n    sub_415149(v8, a1, a2 - 1, a3, a4 - 1);\n  return v7;\n}\n"], [4281076, "sub_4152F4", "__int64 __fastcall sub_4152F4(double a1)\n{\n  __int64 v1; // rdx\n  __int64 v3[2]; // [rsp+10h] [rbp-10h] BYREF\n\n  v3[0] = sub_416D32(a1);\n  v3[1] = v1;\n  do\n  {\n    *__errno_location() = 0;\n    if ( !(unsigned int)sub_416342(v3, 0LL) )\n      return 0LL;\n  }\n  while ( *__errno_location() == 4 || !*__errno_location() );\n  return 0xFFFFFFFFLL;\n}\n"], [4281189, "sub_415365", "__int64 __fastcall sub_415365(unsigned __int64 *a1, int a2)\n{\n  __int64 result; // rax\n\n  if ( 0xFFFFFFFFFFFFFFFFLL / a2 >= *a1 )\n  {\n    *a1 *= a2;\n    result = 0LL;\n  }\n  else\n  {\n    *a1 = -1LL;\n    result = 1LL;\n  }\n  return result;\n}\n"], [4281284, "sub_4153C4", "__int64 __fastcall sub_4153C4(unsigned __int64 *a1, int a2, int a3)\n{\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; a3--; i |= sub_415365(a1, a2) )\n    ;\n  return i;\n}\n"], [4281349, "sub_415405", "__int64 __fastcall sub_415405(const char *a1, char **a2, int a3, _QWORD *a4, const char *a5)\n{\n  char **v5; // rax\n  int v7; // eax\n  int v8; // eax\n  unsigned __int8 i; // [rsp+3Fh] [rbp-31h]\n  unsigned int v13; // [rsp+40h] [rbp-30h]\n  int v14; // [rsp+44h] [rbp-2Ch]\n  int v15; // [rsp+48h] [rbp-28h]\n  int v16; // [rsp+4Ch] [rbp-24h]\n  char v17; // [rsp+50h] [rbp-20h] BYREF\n  unsigned __int64 v18; // [rsp+58h] [rbp-18h] BYREF\n  unsigned __int8 *v19; // [rsp+60h] [rbp-10h]\n  char **endptr; // [rsp+68h] [rbp-8h]\n\n  v13 = 0;\n  if ( a3 < 0 || a3 > 36 )\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\", \"../../src/lib/xstrtol.c\", 0x53u, \"xstrtoul\");\n  if ( a2 )\n    v5 = a2;\n  else\n    v5 = (char **)&v17;\n  endptr = v5;\n  v19 = (unsigned __int8 *)a1;\n  for ( i = *a1; ((*__ctype_b_loc())[i] & 0x2000) != 0; i = *v19 )\n    ++v19;\n  if ( i == 45 )\n    return 4LL;\n  *__errno_location() = 0;\n  v18 = strtoul(a1, endptr, a3);\n  if ( *endptr == a1 )\n  {\n    if ( !a5 || !**endptr || !strchr(a5, **endptr) )\n      return 4LL;\n    v18 = 1LL;\n  }\n  else if ( *__errno_location() )\n  {\n    if ( *__errno_location() != 34 )\n      return 4LL;\n    v13 = 1;\n  }\n  if ( !a5 )\n  {\n    *a4 = v18;\n    return v13;\n  }\n  if ( !**endptr )\n    goto LABEL_76;\n  v14 = 1024;\n  v15 = 1;\n  if ( !strchr(a5, **endptr) )\n  {\n    *a4 = v18;\n    return v13 | 2;\n  }\n  if ( strchr(a5, 48) )\n  {\n    v7 = (*endptr)[1];\n    if ( v7 == 68 )\n      goto LABEL_35;\n    if ( v7 != 105 )\n    {\n      if ( v7 != 66 )\n        goto LABEL_36;\nLABEL_35:\n      v14 = 1000;\n      v15 = 2;\n      goto LABEL_36;\n    }\n    if ( (*endptr)[2] == 66 )\n      v15 = 3;\n  }\nLABEL_36:\n  v8 = **endptr;\n  if ( v8 != 89 )\n  {\n    if ( v8 > 89 )\n    {\n      if ( v8 == 103 )\n      {\nLABEL_65:\n        v16 = sub_4153C4(&v18, v14, 3);\n        goto LABEL_74;\n      }\n      if ( v8 <= 103 )\n      {\n        switch ( v8 )\n        {\n          case 'b':\n            v16 = sub_415365(&v18, 512);\n            break;\n          case 'c':\n            v16 = 0;\n            break;\n          case 'Z':\n            v16 = sub_4153C4(&v18, v14, 7);\n            break;\n          default:\n            goto LABEL_73;\n        }\n        goto LABEL_74;\n      }\n      if ( v8 == 109 )\n        goto LABEL_67;\n      if ( v8 > 109 )\n      {\n        if ( v8 != 116 )\n        {\n          if ( v8 != 119 )\n            goto LABEL_73;\n          v16 = sub_415365(&v18, 2);\n          goto LABEL_74;\n        }\nLABEL_69:\n        v16 = sub_4153C4(&v18, v14, 4);\n        goto LABEL_74;\n      }\n      if ( v8 != 107 )\n        goto LABEL_73;\n    }\n    else if ( v8 != 75 )\n    {\n      if ( v8 <= 75 )\n      {\n        if ( v8 == 69 )\n        {\n          v16 = sub_4153C4(&v18, v14, 6);\n          goto LABEL_74;\n        }\n        if ( v8 != 71 )\n        {\n          if ( v8 != 66 )\n          {\nLABEL_73:\n            *a4 = v18;\n            return v13 | 2;\n          }\n          v16 = sub_415365(&v18, 1024);\n          goto LABEL_74;\n        }\n        goto LABEL_65;\n      }\n      if ( v8 == 80 )\n      {\n        v16 = sub_4153C4(&v18, v14, 5);\n        goto LABEL_74;\n      }\n      if ( v8 != 84 )\n      {\n        if ( v8 != 77 )\n          goto LABEL_73;\nLABEL_67:\n        v16 = sub_4153C4(&v18, v14, 2);\n        goto LABEL_74;\n      }\n      goto LABEL_69;\n    }\n    v16 = sub_4153C4(&v18, v14, 1);\n    goto LABEL_74;\n  }\n  v16 = sub_4153C4(&v18, v14, 8);\nLABEL_74:\n  v13 |= v16;\n  *endptr += v15;\n  if ( **endptr )\n    v13 |= 2u;\nLABEL_76:\n  *a4 = v18;\n  return v13;\n}\n"], [4282481, "sub_415871", "void __fastcall sub_415871(unsigned int a1, int a2, char a3, __int64 a4, __int64 a5, int a6)\n{\n  char *v6; // rax\n  char v9[8]; // [rsp+20h] [rbp-20h] BYREF\n  const char *v10; // [rsp+28h] [rbp-18h]\n  char *msgid; // [rsp+30h] [rbp-10h]\n  char *v12; // [rsp+38h] [rbp-8h]\n\n  v10 = \"--\";\n  if ( a1 > 3 )\n  {\n    if ( a1 != 4 )\n      goto LABEL_6;\n    msgid = \"invalid %s%s argument `%s'\";\n  }\n  else if ( a1 >= 2 )\n  {\n    msgid = \"invalid suffix in %s%s argument `%s'\";\n  }\n  else\n  {\n    if ( a1 != 1 )\nLABEL_6:\n      abort();\n    msgid = \"%s%s argument `%s' too large\";\n  }\n  if ( a2 >= 0 )\n  {\n    v12 = *(char **)(32LL * a2 + a4);\n  }\n  else\n  {\n    v10 -= a2;\n    v9[0] = a3;\n    v9[1] = 0;\n    v12 = v9;\n  }\n  v6 = gettext(msgid);\n  error(a6, 0, v6, v10, v12, a5);\n}\n"], [4282699, "sub_41594B", "void __fastcall __noreturn sub_41594B(unsigned int a1, int a2, char a3, __int64 a4, __int64 a5)\n{\n  sub_415871(a1, a2, a3, a4, a5, status);\n  abort();\n}\n"], [4282769, "sub_415991", "__int64 __fastcall sub_415991(unsigned __int64 *a1, int a2)\n{\n  __int64 result; // rax\n\n  if ( 0xFFFFFFFFFFFFFFFFLL / a2 >= *a1 )\n  {\n    *a1 *= a2;\n    result = 0LL;\n  }\n  else\n  {\n    *a1 = -1LL;\n    result = 1LL;\n  }\n  return result;\n}\n"], [4282864, "sub_4159F0", "__int64 __fastcall sub_4159F0(unsigned __int64 *a1, int a2, int a3)\n{\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; a3--; i |= sub_415991(a1, a2) )\n    ;\n  return i;\n}\n"], [4282929, "sub_415A31", "__int64 __fastcall sub_415A31(const char *a1, char **a2, int a3, uintmax_t *a4, const char *a5)\n{\n  char **v5; // rax\n  int v7; // eax\n  int v8; // eax\n  unsigned __int8 i; // [rsp+3Fh] [rbp-31h]\n  unsigned int v13; // [rsp+40h] [rbp-30h]\n  int v14; // [rsp+44h] [rbp-2Ch]\n  int v15; // [rsp+48h] [rbp-28h]\n  int v16; // [rsp+4Ch] [rbp-24h]\n  char v17; // [rsp+50h] [rbp-20h] BYREF\n  uintmax_t v18; // [rsp+58h] [rbp-18h] BYREF\n  unsigned __int8 *v19; // [rsp+60h] [rbp-10h]\n  char **endptr; // [rsp+68h] [rbp-8h]\n\n  v13 = 0;\n  if ( a3 < 0 || a3 > 36 )\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\", \"../../src/lib/xstrtol.c\", 0x53u, \"xstrtoumax\");\n  if ( a2 )\n    v5 = a2;\n  else\n    v5 = (char **)&v17;\n  endptr = v5;\n  v19 = (unsigned __int8 *)a1;\n  for ( i = *a1; ((*__ctype_b_loc())[i] & 0x2000) != 0; i = *v19 )\n    ++v19;\n  if ( i == 45 )\n    return 4LL;\n  *__errno_location() = 0;\n  v18 = strtoumax(a1, endptr, a3);\n  if ( *endptr == a1 )\n  {\n    if ( !a5 || !**endptr || !strchr(a5, **endptr) )\n      return 4LL;\n    v18 = 1LL;\n  }\n  else if ( *__errno_location() )\n  {\n    if ( *__errno_location() != 34 )\n      return 4LL;\n    v13 = 1;\n  }\n  if ( !a5 )\n  {\n    *a4 = v18;\n    return v13;\n  }\n  if ( !**endptr )\n    goto LABEL_76;\n  v14 = 1024;\n  v15 = 1;\n  if ( !strchr(a5, **endptr) )\n  {\n    *a4 = v18;\n    return v13 | 2;\n  }\n  if ( strchr(a5, 48) )\n  {\n    v7 = (*endptr)[1];\n    if ( v7 == 68 )\n      goto LABEL_35;\n    if ( v7 != 105 )\n    {\n      if ( v7 != 66 )\n        goto LABEL_36;\nLABEL_35:\n      v14 = 1000;\n      v15 = 2;\n      goto LABEL_36;\n    }\n    if ( (*endptr)[2] == 66 )\n      v15 = 3;\n  }\nLABEL_36:\n  v8 = **endptr;\n  if ( v8 != 89 )\n  {\n    if ( v8 > 89 )\n    {\n      if ( v8 == 103 )\n      {\nLABEL_65:\n        v16 = sub_4159F0(&v18, v14, 3);\n        goto LABEL_74;\n      }\n      if ( v8 <= 103 )\n      {\n        switch ( v8 )\n        {\n          case 'b':\n            v16 = sub_415991(&v18, 512);\n            break;\n          case 'c':\n            v16 = 0;\n            break;\n          case 'Z':\n            v16 = sub_4159F0(&v18, v14, 7);\n            break;\n          default:\n            goto LABEL_73;\n        }\n        goto LABEL_74;\n      }\n      if ( v8 == 109 )\n        goto LABEL_67;\n      if ( v8 > 109 )\n      {\n        if ( v8 != 116 )\n        {\n          if ( v8 != 119 )\n            goto LABEL_73;\n          v16 = sub_415991(&v18, 2);\n          goto LABEL_74;\n        }\nLABEL_69:\n        v16 = sub_4159F0(&v18, v14, 4);\n        goto LABEL_74;\n      }\n      if ( v8 != 107 )\n        goto LABEL_73;\n    }\n    else if ( v8 != 75 )\n    {\n      if ( v8 <= 75 )\n      {\n        if ( v8 == 69 )\n        {\n          v16 = sub_4159F0(&v18, v14, 6);\n          goto LABEL_74;\n        }\n        if ( v8 != 71 )\n        {\n          if ( v8 != 66 )\n          {\nLABEL_73:\n            *a4 = v18;\n            return v13 | 2;\n          }\n          v16 = sub_415991(&v18, 1024);\n          goto LABEL_74;\n        }\n        goto LABEL_65;\n      }\n      if ( v8 == 80 )\n      {\n        v16 = sub_4159F0(&v18, v14, 5);\n        goto LABEL_74;\n      }\n      if ( v8 != 84 )\n      {\n        if ( v8 != 77 )\n          goto LABEL_73;\nLABEL_67:\n        v16 = sub_4159F0(&v18, v14, 2);\n        goto LABEL_74;\n      }\n      goto LABEL_69;\n    }\n    v16 = sub_4159F0(&v18, v14, 1);\n    goto LABEL_74;\n  }\n  v16 = sub_4159F0(&v18, v14, 8);\nLABEL_74:\n  v13 |= v16;\n  *endptr += v15;\n  if ( **endptr )\n    v13 |= 2u;\nLABEL_76:\n  *a4 = v18;\n  return v13;\n}\n"], [4284061, "sub_415E9D", "int __fastcall sub_415E9D(FILE *a1)\n{\n  int v2; // eax\n  int v3; // [rsp+14h] [rbp-Ch]\n  int v4; // [rsp+18h] [rbp-8h]\n\n  v3 = 0;\n  if ( fileno(a1) < 0 )\n    return fclose(a1);\n  if ( !__freading(a1) || (v2 = fileno(a1), lseek(v2, 0LL, 1) != -1) )\n  {\n    if ( (unsigned int)sub_41623F(a1) )\n      v3 = *__errno_location();\n  }\n  v4 = fclose(a1);\n  if ( v3 )\n  {\n    *__errno_location() = v3;\n    v4 = -1;\n  }\n  return v4;\n}\n"], [4284242, "sub_415F52", "__int64 __fastcall sub_415F52(int a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __m128 a7, __m128 a8, __m128 a9, __m128 a10, __m128 a11, __m128 a12, __m128 a13, __m128 a14)\n{\n  int v14; // ecx\n  int v15; // er8\n  int v16; // er9\n  int v18; // [rsp+10h] [rbp-E0h]\n  int v19; // [rsp+14h] [rbp-DCh]\n  int v20; // [rsp+18h] [rbp-D8h]\n  int v21; // [rsp+1Ch] [rbp-D4h]\n  __int64 v22; // [rsp+50h] [rbp-A0h]\n  __int64 v23; // [rsp+58h] [rbp-98h]\n  __int64 v24; // [rsp+60h] [rbp-90h]\n  __int64 v25; // [rsp+68h] [rbp-88h]\n  __m128 v26; // [rsp+70h] [rbp-80h]\n  __m128 v27; // [rsp+80h] [rbp-70h]\n  __m128 v28; // [rsp+90h] [rbp-60h]\n  __m128 v29; // [rsp+A0h] [rbp-50h]\n  __m128 v30; // [rsp+B0h] [rbp-40h]\n  __m128 v31; // [rsp+C0h] [rbp-30h]\n  __m128 v32; // [rsp+D0h] [rbp-20h]\n  __m128 v33; // [rsp+E0h] [rbp-10h]\n\n  v22 = a3;\n  v23 = a4;\n  v24 = a5;\n  v25 = a6;\n  v26 = a7;\n  v27 = a8;\n  v28 = a9;\n  v29 = a10;\n  v30 = a11;\n  v31 = a12;\n  v32 = a13;\n  v33 = a14;\n  if ( a2 != 1030 )\n    return (unsigned int)fcntl(a1, a2, v22);\n  v19 = v22;\n  if ( dword_61DD00 < 0 )\n  {\n    v18 = sub_415F52(a1, 0, v22, a4, a5, a6);\n  }\n  else\n  {\n    v18 = fcntl(a1, 1030, (unsigned int)v22);\n    if ( v18 < 0 && *__errno_location() == 22 )\n    {\n      v18 = sub_415F52(a1, 0, v19, v14, v15, v16);\n      if ( v18 < 0 )\n        return (unsigned int)v18;\n      dword_61DD00 = -1;\n    }\n    else\n    {\n      dword_61DD00 = 1;\n    }\n  }\n  if ( v18 >= 0 && dword_61DD00 == -1 )\n  {\n    v20 = fcntl(v18, 1);\n    if ( v20 < 0 || fcntl(v18, 2, v20 | 1u) == -1 )\n    {\n      v21 = *__errno_location();\n      close(v18);\n      *__errno_location() = v21;\n      v18 = -1;\n    }\n  }\n  return (unsigned int)v18;\n}\n"], [4284940, "sub_41620C", "__int64 __fastcall sub_41620C(_DWORD *a1)\n{\n  __int64 result; // rax\n\n  result = *a1 & 0x100;\n  if ( (_DWORD)result )\n    result = sub_41628A(a1, 0LL, 1LL);\n  return result;\n}\n"], [4284991, "sub_41623F", "int __fastcall sub_41623F(FILE *a1)\n{\n  if ( !a1 || !__freading(a1) )\n    return fflush(a1);\n  sub_41620C(a1);\n  return fflush(a1);\n}\n"], [4285066, "sub_41628A", "int __fastcall sub_41628A(FILE *a1, __off_t a2, int a3)\n{\n  int v3; // eax\n  __off_t v6; // [rsp+28h] [rbp-8h]\n\n  if ( a1->_IO_read_end != a1->_IO_read_ptr || a1->_IO_write_ptr != a1->_IO_write_base || a1->_IO_save_base )\n    return fseeko(a1, a2, a3);\n  v3 = fileno(a1);\n  v6 = lseek(v3, a2, a3);\n  if ( v6 == -1 )\n    return -1;\n  a1->_flags &= 0xFFFFFFEF;\n  a1->_offset = v6;\n  return 0;\n}\n"], [4285250, "sub_416342", "int __fastcall sub_416342(__time_t *a1, struct timespec *a2)\n{\n  int result; // eax\n  int v3; // [rsp+1Ch] [rbp-24h]\n  __time_t v4; // [rsp+20h] [rbp-20h]\n  struct timespec requested_time; // [rsp+30h] [rbp-10h] BYREF\n\n  if ( a1[1] >= 0 && a1[1] <= 999999999 )\n  {\n    v4 = *a1;\n    for ( requested_time.tv_nsec = a1[1]; ; requested_time.tv_nsec = 0LL )\n    {\n      if ( v4 <= 2073600 )\n      {\n        requested_time.tv_sec = v4;\n        return nanosleep(&requested_time, a2);\n      }\n      requested_time.tv_sec = 2073600LL;\n      v3 = nanosleep(&requested_time, a2);\n      v4 -= 2073600LL;\n      if ( v3 )\n        break;\n    }\n    if ( a2 )\n      a2->tv_sec += v4;\n    result = v3;\n  }\n  else\n  {\n    *__errno_location() = 22;\n    result = -1;\n  }\n  return result;\n}\n"], [4285473, "sub_416421", "__int64 __fastcall sub_416421(_BYTE *a1, _BYTE *a2, char a3)\n{\n  _BYTE *v4; // [rsp+4h] [rbp-10h]\n  _BYTE *v5; // [rsp+Ch] [rbp-8h]\n\n  v5 = a1;\n  v4 = a2;\n  if ( *a1 == a3 && *a2 == a3 )\n  {\n    while ( *++v5 == *++v4 )\n    {\n      if ( (unsigned int)((char)*v5 - 48) > 9 )\n        return 0LL;\n    }\n    if ( (unsigned int)((char)*v5 - 48) <= 9 && (unsigned int)((char)*v4 - 48) <= 9 )\n      return (unsigned int)((char)*v5 - (char)*v4);\n    if ( (unsigned int)((char)*v5 - 48) > 9 )\n    {\n      if ( (unsigned int)((char)*v4 - 48) > 9 )\n        return 0LL;\nLABEL_21:\n      while ( *v4 == 48 )\n        ++v4;\n      return (unsigned int)-((unsigned int)((char)*v4 - 48) <= 9);\n    }\n  }\n  else\n  {\n    v5 = a1 + 1;\n    if ( *a1 != a3 )\n    {\n      v4 = a2 + 1;\n      if ( *a2 != a3 )\n        return 0LL;\n      goto LABEL_21;\n    }\n  }\n  while ( *v5 == 48 )\n    ++v5;\n  return (unsigned int)((char)*v5 - 48) <= 9;\n}\n"], [4285828, "sub_416584", "__int64 __fastcall sub_416584(unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4)\n{\n  __int64 result; // rax\n  unsigned __int8 *v5; // [rsp+8h] [rbp-30h]\n  unsigned __int8 *v6; // [rsp+10h] [rbp-28h]\n  unsigned __int8 v7; // [rsp+22h] [rbp-16h]\n  unsigned __int8 v8; // [rsp+22h] [rbp-16h]\n  unsigned __int8 v9; // [rsp+23h] [rbp-15h]\n  unsigned __int8 v10; // [rsp+23h] [rbp-15h]\n  unsigned __int8 v11; // [rsp+23h] [rbp-15h]\n  unsigned int v12; // [rsp+24h] [rbp-14h]\n  unsigned int v13; // [rsp+24h] [rbp-14h]\n  unsigned __int64 v14; // [rsp+28h] [rbp-10h]\n  unsigned __int64 v15; // [rsp+28h] [rbp-10h]\n  unsigned __int64 v16; // [rsp+30h] [rbp-8h]\n  unsigned __int64 v17; // [rsp+30h] [rbp-8h]\n\n  v6 = a1;\n  v5 = a2;\n  v7 = *a1;\n  v9 = *a2;\n  if ( *a1 == 45 )\n  {\n    do\n    {\n      do\n        v8 = *++v6;\n      while ( *v6 == 48 );\n    }\n    while ( v8 == a4 );\n    if ( v9 == 45 )\n    {\n      do\n      {\n        do\n          v10 = *++v5;\n        while ( *v5 == 48 );\n      }\n      while ( v10 == a4 );\n      while ( v8 == v10 && (unsigned int)v8 - 48 <= 9 )\n      {\n        do\n          v8 = *++v6;\n        while ( *v6 == a4 );\n        do\n          v10 = *++v5;\n        while ( *v5 == a4 );\n      }\n      if ( v8 == a3 && (unsigned int)v10 - 48 > 9 || v10 == a3 && (unsigned int)v8 - 48 > 9 )\n      {\n        result = sub_416421(v5, v6, a3);\n      }\n      else\n      {\n        v12 = v10 - v8;\n        v14 = 0LL;\n        while ( (unsigned int)v8 - 48 <= 9 )\n        {\n          do\n            v8 = *++v6;\n          while ( *v6 == a4 );\n          ++v14;\n        }\n        v16 = 0LL;\n        while ( (unsigned int)v10 - 48 <= 9 )\n        {\n          do\n            v10 = *++v5;\n          while ( *v5 == a4 );\n          ++v16;\n        }\n        if ( v14 == v16 )\n        {\n          if ( v14 )\n            result = v12;\n          else\n            result = 0LL;\n        }\n        else if ( v14 >= v16 )\n        {\n          result = 0xFFFFFFFFLL;\n        }\n        else\n        {\n          result = 1LL;\n        }\n      }\n    }\n    else\n    {\n      if ( v8 == a3 )\n      {\n        do\n          v8 = *++v6;\n        while ( *v6 == 48 );\n      }\n      if ( (unsigned int)v8 - 48 > 9 )\n      {\n        while ( v9 == 48 || v9 == a4 )\n          v9 = *++v5;\n        if ( v9 == a3 )\n        {\n          do\n            v9 = *++v5;\n          while ( *v5 == 48 );\n        }\n        result = (unsigned int)-((unsigned int)v9 - 48 <= 9);\n      }\n      else\n      {\n        result = 0xFFFFFFFFLL;\n      }\n    }\n  }\n  else if ( v9 == 45 )\n  {\n    do\n    {\n      do\n        v11 = *++v5;\n      while ( *v5 == 48 );\n    }\n    while ( v11 == a4 );\n    if ( v11 == a3 )\n    {\n      do\n        v11 = *++v5;\n      while ( *v5 == 48 );\n    }\n    if ( (unsigned int)v11 - 48 > 9 )\n    {\n      while ( v7 == 48 || v7 == a4 )\n        v7 = *++v6;\n      if ( v7 == a3 )\n      {\n        do\n          v7 = *++v6;\n        while ( *v6 == 48 );\n      }\n      result = (unsigned int)v7 - 48 <= 9;\n    }\n    else\n    {\n      result = 1LL;\n    }\n  }\n  else\n  {\n    while ( v7 == 48 || v7 == a4 )\n      v7 = *++v6;\n    while ( v9 == 48 || v9 == a4 )\n      v9 = *++v5;\n    while ( v7 == v9 && (unsigned int)v7 - 48 <= 9 )\n    {\n      do\n        v7 = *++v6;\n      while ( *v6 == a4 );\n      do\n        v9 = *++v5;\n      while ( *v5 == a4 );\n    }\n    if ( v7 == a3 && (unsigned int)v9 - 48 > 9 || v9 == a3 && (unsigned int)v7 - 48 > 9 )\n    {\n      result = sub_416421(v6, v5, a3);\n    }\n    else\n    {\n      v13 = v7 - v9;\n      v15 = 0LL;\n      while ( (unsigned int)v7 - 48 <= 9 )\n      {\n        do\n          v7 = *++v6;\n        while ( *v6 == a4 );\n        ++v15;\n      }\n      v17 = 0LL;\n      while ( (unsigned int)v9 - 48 <= 9 )\n      {\n        do\n          v9 = *++v5;\n        while ( *v5 == a4 );\n        ++v17;\n      }\n      if ( v15 == v17 )\n      {\n        if ( v15 )\n          result = v13;\n        else\n          result = 0LL;\n      }\n      else if ( v15 >= v17 )\n      {\n        result = 1LL;\n      }\n      else\n      {\n        result = 0xFFFFFFFFLL;\n      }\n    }\n  }\n  return result;\n}\n"], [4286961, "sub_4169F1", "__int64 __fastcall sub_4169F1(unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4)\n{\n  return sub_416584(a1, a2, a3, a4);\n}\n"], [4287007, "sub_416A1F", "_BOOL8 __fastcall sub_416A1F(int a1)\n{\n  return a1 >= 0 && a1 <= 127;\n}\n"], [4287043, "sub_416A43", "_BOOL8 __fastcall sub_416A43(int a1)\n{\n  return a1 > 47 && a1 <= 57 || (int)(a1 & 0xFFFFFFDF) > 64 && (int)(a1 & 0xFFFFFFDF) <= 90;\n}\n"], [4287101, "sub_416A7D", "_BOOL8 __fastcall sub_416A7D(int a1)\n{\n  return (int)(a1 & 0xFFFFFFDF) > 64 && (int)(a1 & 0xFFFFFFDF) <= 90;\n}\n"], [4287147, "sub_416AAB", "_BOOL8 __fastcall sub_416AAB(int a1)\n{\n  return a1 == 32 || a1 == 9;\n}\n"], [4287183, "sub_416ACF", "_BOOL8 __fastcall sub_416ACF(int a1)\n{\n  return (a1 & 0xFFFFFFE0) == 0 || a1 == 127;\n}\n"], [4287223, "sub_416AF7", "_BOOL8 __fastcall sub_416AF7(int a1)\n{\n  return a1 > 47 && a1 <= 57;\n}\n"], [4287259, "sub_416B1B", "_BOOL8 __fastcall sub_416B1B(int a1)\n{\n  return a1 > 96 && a1 <= 122;\n}\n"], [4287295, "sub_416B3F", "_BOOL8 __fastcall sub_416B3F(int a1)\n{\n  return a1 > 32 && a1 <= 126;\n}\n"], [4287331, "sub_416B63", "_BOOL8 __fastcall sub_416B63(int a1)\n{\n  return a1 > 31 && a1 <= 126;\n}\n"], [4287367, "sub_416B87", "_BOOL8 __fastcall sub_416B87(int a1)\n{\n  return a1 > 32 && a1 <= 126 && (a1 <= 47 || a1 > 57) && ((int)(a1 & 0xFFFFFFDF) <= 64 || (int)(a1 & 0xFFFFFFDF) > 90);\n}\n"], [4287437, "sub_416BCD", "_BOOL8 __fastcall sub_416BCD(int a1)\n{\n  return a1 == 32 || a1 == 9 || a1 == 10 || a1 == 11 || a1 == 12 || a1 == 13;\n}\n"], [4287497, "sub_416C09", "_BOOL8 __fastcall sub_416C09(int a1)\n{\n  return a1 > 64 && a1 <= 90;\n}\n"], [4287533, "sub_416C2D", "_BOOL8 __fastcall sub_416C2D(int a1)\n{\n  return a1 > 47 && a1 <= 57 || (int)(a1 & 0xFFFFFFDF) > 64 && (int)(a1 & 0xFFFFFFDF) <= 70;\n}\n"], [4287591, "sub_416C67", "__int64 __fastcall sub_416C67(int a1)\n{\n  __int64 result; // rax\n\n  if ( a1 <= 64 || a1 > 90 )\n    result = (unsigned int)a1;\n  else\n    result = (unsigned int)(a1 + 32);\n  return result;\n}\n"], [4287623, "sub_416C87", "__int64 __fastcall sub_416C87(int a1)\n{\n  __int64 result; // rax\n\n  if ( a1 <= 96 || a1 > 122 )\n    result = (unsigned int)a1;\n  else\n    result = (unsigned int)(a1 - 32);\n  return result;\n}\n"], [4287655, "sub_416CA7", "__int64 __fastcall sub_416CA7(FILE *a1)\n{\n  bool v2; // [rsp+1Dh] [rbp-3h]\n  bool v3; // [rsp+1Eh] [rbp-2h]\n  bool v4; // [rsp+1Fh] [rbp-1h]\n\n  v2 = __fpending(a1) != 0;\n  v3 = ferror_unlocked(a1) != 0;\n  v4 = sub_415E9D(a1) != 0;\n  if ( !v3 && (!v4 || !v2 && *__errno_location() == 9) )\n    return 0LL;\n  if ( !v4 )\n    *__errno_location() = 0;\n  return 0xFFFFFFFFLL;\n}\n"], [4287794, "sub_416D32", "__int64 __fastcall sub_416D32(double a1)\n{\n  __int64 v2; // [rsp+10h] [rbp-38h]\n  signed __int64 v3; // [rsp+18h] [rbp-30h]\n\n  if ( a1 <= -9.223372036854776e18 )\n    return 0x8000000000000000LL;\n  if ( a1 >= 9.223372036854776e18 )\n    return 0x7FFFFFFFFFFFFFFFLL;\n  v3 = ((a1 - (double)(int)a1) * 1000000000.0 > (double)(int)((a1 - (double)(int)a1) * 1000000000.0))\n     + (unsigned __int64)(unsigned int)(int)((a1 - (double)(int)a1) * 1000000000.0);\n  v2 = v3 / 1000000000 + (unsigned int)(int)a1;\n  if ( v3 % 1000000000 < 0 )\n    --v2;\n  return v2;\n}\n"], [4288155, "sub_416E9B", "__int64 __fastcall sub_416E9B(const char *a1, __int64 a2, const char *a3, __int64 a4)\n{\n  unsigned int v10; // [rsp+2Ch] [rbp-14h]\n  size_t v11; // [rsp+30h] [rbp-10h]\n  size_t v12; // [rsp+38h] [rbp-8h]\n\n  while ( 1 )\n  {\n    *__errno_location() = 0;\n    v10 = strcoll(a1, a3);\n    if ( v10 || *__errno_location() )\n      break;\n    v11 = strlen(a1) + 1;\n    v12 = strlen(a3) + 1;\n    a1 += v11;\n    a3 += v12;\n    a2 -= v11;\n    a4 -= v12;\n    if ( !a2 )\n      return (unsigned int)-(a4 != 0);\n    if ( !a4 )\n      return 1LL;\n  }\n  return v10;\n}\n"], [4288364, "sub_416F6C", "__int64 __fastcall sub_416F6C(const char *a1, size_t a2, const char *a3, __int64 a4)\n{\n  char v7; // [rsp+2Ah] [rbp-6h]\n  char v8; // [rsp+2Bh] [rbp-5h]\n  unsigned int v9; // [rsp+2Ch] [rbp-4h]\n\n  if ( a2 == a4 && !memcmp(a1, a3, a2) )\n  {\n    *__errno_location() = 0;\n    v9 = 0;\n  }\n  else\n  {\n    v7 = a1[a2];\n    v8 = a3[a4];\n    a1[a2] = 0;\n    a3[a4] = 0;\n    v9 = sub_416E9B(a1, a2 + 1, a3, a4 + 1);\n    a1[a2] = v7;\n    a3[a4] = v8;\n  }\n  return v9;\n}\n"], [4288584, "sub_417048", "__int64 __fastcall sub_417048(const char *a1, size_t a2, const char *a3, __int64 a4)\n{\n  if ( a2 != a4 || memcmp(a1, a3, a2) )\n    return sub_416E9B(a1, a2, a3, a4);\n  *__errno_location() = 0;\n  return 0LL;\n}\n"], [4288704, "init", "void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)\n{\n  __int64 v4; // rbx\n  signed __int64 v5; // rbp\n\n  v4 = 0LL;\n  v5 = &off_61CE08 - off_61CE00;\n  init_proc();\n  if ( v5 )\n  {\n    do\n      ((void (__fastcall *)(_QWORD, __int64, __int64))off_61CE00[v4++])(a1, a2, a3);\n    while ( v4 != v5 );\n  }\n}\n"], [4288816, "fini", "void fini(void)\n{\n  ;\n}\n"], [4288832, "sub_417140", "int __fastcall sub_417140(void (__fastcall *a1)(void *))\n{\n  void *v1; // rdx\n\n  if ( qword_61D3E8 )\n    v1 = (void *)qword_61D3E8[0];\n  else\n    v1 = 0LL;\n  return __cxa_atexit(a1, 0LL, v1);\n}\n"], [4288864, "sub_417160", "int __fastcall sub_417160(char *filename, struct stat *stat_buf)\n{\n  return __xstat(1, filename, stat_buf);\n}\n"], [4288880, "sub_417170", "int __fastcall sub_417170(int fildes, struct stat *stat_buf)\n{\n  return __fxstat(1, fildes, stat_buf);\n}\n"], [4288896, ".term_proc", "void term_proc()\n{\n  ;\n}\n"]]